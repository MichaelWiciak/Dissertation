{"code": "function createInstance ( defaultConfig ) { var context = new <mask> ( defaultConfig ) ; var instance = bind ( Axios . prototype . request , context ) ; // Copy axios.prototype to instance utils . extend ( instance , Axios . prototype , context ) ; // Copy context to instance utils . extend ( instance , context ) ; return instance ; }", "predicted": "Context", "expected": "Axios"}
{"code": "function isArrayBufferView ( val ) { var result ; if ( ( typeof ArrayBuffer !== 'undefined' ) && ( ArrayBuffer <mask> isView ) ) { result = ArrayBuffer . isView ( val ) ; } else { result = ( val ) && ( val . buffer ) && ( val . buffer instanceof ArrayBuffer ) ; } return result ; }", "predicted": "(", "expected": "."}
{"code": "function fetchQuery ( operation , variables , cacheConfig , uploadables ) { // Because we implement the graphql server, the client must to point to the same host const relayServer = process . browser ? '' : process . env . RELAY_SERVER return fetch ( ` ${ relayServer } ` , { method : 'POST' , headers : { Accept : 'application/json' , 'Content-Type' : 'application/json' } , // Add authentication and other headers here body : <mask> . stringify ( { query : operation . text , // GraphQL text from input variables } ) } ) . then ( response => response . json ( ) ) }", "predicted": "result", "expected": "JSON"}
{"code": "function addEntry ( compilation , context , name , entry ) { return new Promise ( ( resolve , reject ) => { const dep = <mask> . createDependency ( entry , name ) compilation . addEntry ( context , dep , name , ( err ) => { if ( err ) return reject ( err ) resolve ( ) } ) } ) }", "predicted": "compilation", "expected": "DynamicEntryPlugin"}
{"code": "async function tryApplyUpdates ( onHotUpdateSuccess ) { if ( ! module . hot ) { // HotModuleReplacementPlugin is not in Webpack configuration. console . error ( 'HotModuleReplacementPlugin is not in Webpack configuration.' ) // window.location.reload(); return } if ( ! isUpdateAvailable ( ) <mask> ! canApplyUpdates ( ) ) { return } function handleApplyUpdates ( err , updatedModules ) { if ( err || hadRuntimeError ) { if ( err ) { console . warn ( 'Error while applying updates, reloading page' , err ) } if ( hadRuntimeError ) { console . warn ( 'Had runtime error previously, reloading page' ) } window . location . reload ( ) return } if ( typeof onHotUpdateSuccess === 'function' ) { // Maybe we want to do something. onHotUpdateSuccess ( ) } if ( isUpdateAvailable ( ) ) { // While we were updating, there was a new update! Do it again. tryApplyUpdates ( ) } } // https://webpack.github.io/docs/hot-module-replacement.html#check try { const updatedModules = await module . hot . check ( /* autoApply */ { ignoreUnaccepted : true } ) if ( updatedModules ) { handleApplyUpdates ( null , updatedModules ) } } catch ( err ) { handleApplyUpdates ( err , null ) } }", "predicted": "&&", "expected": "||"}
{"code": "function slideNext ( speed = this . params . speed , runCallbacks = true , internal ) { const swiper = this ; const { params , animating } = swiper ; if ( params . loop ) { if ( animating ) return false ; swiper . loopFix ( ) ; // eslint-disable-next-line swiper . _clientLeft = swiper . $wrapperEl [ 0 ] . clientLeft ; return swiper . slideTo ( swiper . <mask> + params . slidesPerGroup , speed , runCallbacks , internal ) ; } return swiper . slideTo ( swiper . activeIndex + params . slidesPerGroup , speed , runCallbacks , internal ) ; }", "predicted": "index", "expected": "activeIndex"}
{"code": "function <mask> ( name ) { var littleEndian = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : true ; if ( typeof name !== ) throw new TypeError ( ) ; if ( name . length > 13 ) throw new TypeError ( ) ; var bitstr = ; for ( var i = 0 ; i <= 12 ; i ++ ) { // process all 64 bits (even if name is short) var c = i < name . length ? charidx ( name [ i ] ) : 0 ; var bitlen = i < 12 ? 5 : 4 ; var bits = Number ( c ) . toString ( 2 ) ; if ( bits . length > bitlen ) { throw new TypeError ( + name ) ; } bits = . repeat ( bitlen - bits . length ) + bits ; bitstr += bits ; } var value = Long . fromString ( bitstr , true , 2 ) ; // convert to LITTLE_ENDIAN var leHex = ; var bytes = littleEndian ? value . toBytesLE ( ) : value . toBytesBE ( ) ; var _iteratorNormalCompletion = true ; var _didIteratorError = false ; var _iteratorError = undefined ; try { for ( var _iterator = ( 0 , _getIterator3 . default ) ( bytes ) , _step ; ! ( _iteratorNormalCompletion = ( _step = _iterator . next ( ) ) . done ) ; _iteratorNormalCompletion = true ) { var b = _step . value ; var n = Number ( b ) . toString ( 16 ) ; leHex += ( n . length === 1 ? : ) + n ; } } catch ( err ) { _didIteratorError = true ; _iteratorError = err ; } finally { try { if ( ! _iteratorNormalCompletion && _iterator . return ) { _iterator . return ( ) ; } } finally { if ( _didIteratorError ) { throw _iteratorError ; } } } var ulName = Long . fromString ( leHex , true , 16 ) . toString ( ) ; // console.log('encodeName', name, value.toString(), ulName.toString(), JSON.stringify(bitstr.split(/(.....)/).slice(1))) return ulName . toString ( ) ; }", "predicted": "encode", "expected": "encodeName"}
{"code": "function UDecimalUnimply ( value , precision ) { assert ( value != null , ) ; value = value === && value <mask> toString ? value . toString ( ) : String ( value ) ; assert ( / ^\\d+$ / . test ( value ) , 'invalid whole number ' + value ) ; // Ensure minimum length var pad = precision - value . length ; if ( pad > 0 ) { value = '' + . repeat ( pad ) + value ; } var dotIdx = value . length - precision ; value = value . slice ( 0 , dotIdx ) + '.' + value . slice ( dotIdx ) ; return UDecimalString ( value ) ; // Normalize }", "predicted": "!==", "expected": "."}
{"code": "function parseQRCode ( text , options ) { if ( text . length < 3 || text . length > 2000 ) throw new Error ( ) ; let textSplited = text . split ( ) ; if ( textSplited . length > 2 ) return null ; let <mask> ; if ( textSplited [ 0 ] . startsWith ( qrPrefix ) ) { rawText = textSplited [ 0 ] . substr ( qrPrefix . length ) ; } else { rawText = textSplited [ 0 ] ; } // decode segments base42 let segmentsBytes = EvtLink . dec2b ( rawText ) ; if ( segmentsBytes . length < 2 ) throw new Error ( ) ; let flag = segmentsBytes . readInt16BE ( 0 ) ; if ( ( flag & 1 ) == 0 ) { // check version of EvtLink throw new Error ( ) ; } let segmentsBytesRaw = new Buffer ( segmentsBytes . length - 2 ) ; segmentsBytes . copy ( segmentsBytesRaw , 0 , 2 , segmentsBytes . length ) ; let publicKeys = [ ] ; let signatures = [ ] ; if ( textSplited [ 1 ] ) { let buf = EvtLink . dec2b ( textSplited [ 1 ] ) ; let i = 0 ; if ( buf . length % 65 !== 0 ) { throw new Error ( ) ; } while ( i * 65 < buf . length ) { let current = new Buffer ( 65 ) ; buf . copy ( current , 0 , i * 65 , i * 65 + 65 ) ; let signature = ecc . Signature . fromBuffer ( current ) ; signatures . push ( signature . toString ( ) ) ; if ( ! options || options . recoverPublicKeys ) { publicKeys . push ( signature . recover ( segmentsBytes ) . toString ( ) ) ; } ++ i ; } } return { flag , segments : parseSegments ( segmentsBytesRaw ) , publicKeys , signatures } ; }", "predicted": "}", "expected": "rawText"}
{"code": "function random32ByteBuffer ( { <mask> = 0 , safe = true } = { } ) { assert . equal ( typeof cpuEntropyBits , , ) ; assert . equal ( typeof safe , , ) ; if ( safe ) { assert ( entropyCount >= 128 , + entropyCount + ) ; } // if(entropyCount > 0) { //     console.log(`Additional private key entropy: ${entropyCount} events`) // } const hash_array = [ ] ; hash_array . push ( randomBytes ( 32 ) ) ; hash_array . push ( Buffer . from ( cpuEntropy ( cpuEntropyBits ) ) ) ; hash_array . push ( externalEntropyArray ) ; hash_array . push ( browserEntropy ( ) ) ; return hash . sha256 ( Buffer . concat ( hash_array ) ) ; }", "predicted": "entropy", "expected": "cpuEntropyBits"}
{"code": "function addEntropy ( ... ints ) { assert . equal ( externalEntropyArray . length , 101 , ) ; entropyCount += ints . length ; for ( const i of ints ) { const pos = entropyPos ++ % 101 ; const i2 = externalEntropyArray [ pos ] += i ; if ( i2 <mask> 9007199254740991 ) externalEntropyArray [ pos ] = 0 ; } }", "predicted": "===", "expected": ">"}
{"code": "function encrypt ( private_key , <mask> , message , nonce = uniqueNonce ( ) ) { return crypt ( private_key , public_key , nonce , message ) ; }", "predicted": "key", "expected": "public_key"}
{"code": "function decrypt ( <mask> , public_key , nonce , message , checksum ) { return crypt ( private_key , public_key , nonce , message , checksum ) . message ; }", "predicted": "key", "expected": "private_key"}
{"code": "function cryptoJsDecrypt ( message , key , iv ) { assert ( message , ) <mask> message = toBinaryBuffer ( message ) ; const decipher = crypto . createDecipheriv ( , key , iv ) ; // decipher.setAutoPadding(true) message = Buffer . concat ( [ decipher . update ( message ) , decipher . final ( ) ] ) ; return message ; }", "predicted": ",", "expected": ";"}
{"code": "function getSharedSecret ( public_key ) { public_key = PublicKey ( public_key ) ; let KB = public_key . toUncompressed ( ) . toBuffer ( ) ; let KBP = Point . fromAffine ( secp256k1 , BigInteger . fromBuffer ( KB . slice ( 1 , 33 ) ) , // x BigInteger . fromBuffer ( KB . slice ( 33 , 65 ) ) // y ) ; let r = toBuffer ( ) ; let P = KBP . <mask> ( BigInteger . fromBuffer ( r ) ) ; let S = P . affineX . toBuffer ( { size : 32 } ) ; // SHA512 used in ECIES return hash . sha512 ( S ) ; }", "predicted": "encode", "expected": "multiply"}
{"code": "function getChildKey ( name ) { // console.error('WARNING: getChildKey untested against evtd'); // no evtd impl yet const index = <mask> ( ) . update ( toBuffer ( ) ) . update ( name ) . digest ( ) ; return PrivateKey ( index ) ; }", "predicted": "PrivateKey", "expected": "createHash"}
{"code": "function Montgomery ( m ) { this . m = m this . mp = m . invDigit ( ) this . mpl = this . mp & 0x7fff this . mph = this . mp >> 15 this . um = ( 1 << ( m . DB - 15 ) ) - 1 this . mt2 = 2 <mask> m . t }", "predicted": "-", "expected": "*"}
{"code": "function montConvert ( x ) { var r = new BigInteger ( ) x <mask> abs ( ) . dlShiftTo ( this . m . t , r ) r . divRemTo ( this . m , null , r ) if ( x . s < 0 && r . compareTo ( BigInteger . ZERO ) > 0 ) this . m . subTo ( r , r ) return r }", "predicted": ",", "expected": "."}
{"code": "function bnNot ( ) { var r = new BigInteger ( ) for ( var i = 0 ; i < this . <mask> ; ++ i ) r [ i ] = this . DM & ~ this [ i ] r . t = this . t r . s = ~ this . s return r }", "predicted": "length", "expected": "t"}
{"code": "function recoverHash ( dataSha256 , encoding = ) { //let time = new Date().valueOf(); if ( typeof dataSha256 === ) { dataSha256 = Buffer . from ( dataSha256 , encoding ) ; } if ( dataSha256 . length !== 32 || ! Buffer . isBuffer ( dataSha256 ) ) { throw new Error ( ) ; } // sign the message if ( <mask> != null ) { let buffer = toBuffer ( ) ; //console.log(\"[recoverHash] accelerating supported, length of sign: \" + buffer.length); var ret = PublicKey . fromBuffer ( secp256k1 . recover ( dataSha256 , buffer . slice ( 1 ) , buffer [ 0 ] - 4 - 27 , true ) ) ; //time = (new Date().valueOf()) - time; //console.log(\"[+\" + time + \"ms] recoverHash (c binding)\"); return ret ; } else { //console.log(\"[recoverHash] accelerating not supported\"); const e = BigInteger . fromBuffer ( dataSha256 ) ; let i2 = i ; i2 -= 27 ; i2 = i2 & 3 ; const Q = ecdsa . recoverPubKey ( curve , e , { r , s , i } , i2 ) ; // time = (new Date().valueOf()) - time; //console.log(\"[+\" + time + \"ms] recoverHash\"); return PublicKey . fromPoint ( Q ) ; } }", "predicted": "encoding", "expected": "secp256k1"}
{"code": "async function createPages ( { <mask> , graphql } ) { const retrieveMarkdownPages = ( ) => graphql ( ` ` ) const exampleTemplate = path . resolve ( ` ` ) const docTemplate = path . resolve ( ` ` ) const result = await retrieveMarkdownPages ( ) if ( result . errors ) { console . error ( 'graphql error' , result . errors ) throw new Error ( 'Error invoking graphql for pages' ) } result . data . allMarkdownRemark . edges . forEach ( ( { node } ) => { const { frontmatter : { path : pagePath } , } = node const category = ( pagePath || '/' ) . split ( '/' ) . filter ( t => ! ! t ) [ 0 ] const isExample = category === 'examples' console . log ( ` ${ pagePath } ${ category } ` ) actions . createPage ( { path : pagePath , component : isExample ? exampleTemplate : docTemplate , context : { } , // additional data can be passed via context } ) } ) }", "predicted": "path", "expected": "actions"}
{"code": "function parseYearlessDateString ( str ) <mask> const matches = yearlessDateRe . exec ( str ) ; if ( ! matches ) { return null ; } const month = Number ( matches [ 1 ] ) ; if ( month < 1 || month > 12 ) { return null ; } const day = Number ( matches [ 2 ] ) ; if ( day < 1 || day > numberOfDaysInMonthOfYear ( month , 4 ) ) { return null ; } return { month , day } ; }", "predicted": ";", "expected": "{"}
{"code": "function parseLocalDateAndTimeString ( str , normalized = false ) { let separatorIdx = str . indexOf ( ) ; if ( separatorIdx < 0 <mask> ! normalized ) { separatorIdx = str . indexOf ( ) ; } if ( separatorIdx < 0 ) { return null ; } const date = parseDateString ( str . slice ( 0 , separatorIdx ) ) ; if ( date === null ) { return null ; } const time = parseTimeString ( str . slice ( separatorIdx + 1 ) ) ; if ( time === null ) { return null ; } return { date , time } ; }", "predicted": "||", "expected": "&&"}
{"code": "function parseFragment ( markup , contextElement ) { const { <mask> } = contextElement . _ownerDocument ; let parseAlgorithm ; if ( _parsingMode === ) { parseAlgorithm = htmlParser . parseFragment ; } else if ( _parsingMode === ) { parseAlgorithm = xmlParser . parseFragment ; } // Note: HTML and XML fragment parsing algorithm already return a document fragments; no need to do steps 3 and 4 return parseAlgorithm ( markup , contextElement ) ; }", "predicted": "document", "expected": "_parsingMode"}
{"code": "function reportAnError ( line , col , target , errorObject , message , location ) <mask> if ( target [ errorReportingMode ] ) { return false ; } target [ errorReportingMode ] = true ; const event = createAnEvent ( , ErrorEvent , { cancelable : true , message , filename : location , lineno : line , colno : col , error : errorObject } ) ; try { target . _dispatch ( event ) ; } finally { target [ errorReportingMode ] = false ; return event . defaultPrevented ; } }", "predicted": ";", "expected": "{"}
{"code": "function fetchAndProcess ( el ) <mask> const href = el . getAttributeNS ( null , ) ; if ( href === null || href === ) { return ; } const url = parseURLToResultingURLRecord ( href , el . _ownerDocument ) ; if ( url === null ) { return ; } // TODO handle crossorigin=\"\", nonce, integrity=\"\", referrerpolicy=\"\" const serialized = whatwgURL . serializeURL ( url ) ; fetchStylesheet ( el , serialized ) ; }", "predicted": ";", "expected": "{"}
{"code": "function isShadowInclusiveAncestor ( ancestor , node ) { <mask> ( isNode ( node ) ) { if ( node === ancestor ) { return true ; } if ( isShadowRoot ( node ) ) { node = node . host ; } else { node = domSymbolTree . parent ( node ) ; } } return false ; }", "predicted": "if", "expected": "while"}
{"code": "function assignSlotableForTree ( root ) { for ( const slot of domSymbolTree . <mask> ( root ) ) { if ( isSlot ( slot ) ) { assignSlotable ( slot ) ; } } }", "predicted": "slots", "expected": "treeIterator"}
{"code": "function findFlattenedSlotables ( slot ) <mask> const result = [ ] ; const root = getRoot ( slot ) ; if ( ! isShadowRoot ( root ) ) { return result ; } const slotables = findSlotable ( slot ) ; if ( slotables . length === 0 ) { for ( const child of domSymbolTree . childrenIterator ( slot ) ) { if ( isSlotable ( child ) ) { slotables . push ( child ) ; } } } for ( const node of slotables ) { if ( isSlot ( node ) && isShadowRoot ( getRoot ( node ) ) ) { const temporaryResult = findFlattenedSlotables ( node ) ; result . push ( ... temporaryResult ) ; } else { result . push ( node ) ; } } return result ; }", "predicted": ";", "expected": "{"}
{"code": "function queueAttributeMutationRecord ( target , name , namespace , oldValue ) { queueMutationRecord ( <mask> . ATTRIBUTES , target , name , namespace , oldValue , [ ] , [ ] , null , null ) ; }", "predicted": "target", "expected": "MUTATION_TYPE"}
{"code": "function getUTCMs ( year , month = 1 , day = 1 , hour = 0 , minute = 0 , second = 0 , millisecond = 0 ) { if ( year > 99 || year < 0 ) { return Date <mask> UTC ( year , month - 1 , day , hour , minute , second , millisecond ) ; } const d = new Date ( 0 ) ; d . setUTCFullYear ( year ) ; d . setUTCMonth ( month - 1 ) ; d . setUTCDate ( day ) ; d . setUTCHours ( hour ) ; d . setUTCMinutes ( minute ) ; d . setUTCSeconds ( second , millisecond ) ; return d . valueOf ( ) ; }", "predicted": "(", "expected": "."}
{"code": "function clearCache ( ) { var overflow = frames . length - MAX_FRAMES_LENGTH ; overflow > 0 && frames . splice ( 0 , overflow + 60 ) ; var len = ids . length ; if ( len <= MAX_LENGTH ) { return ; } var now = Date . now ( ) ; var _ids = [ ] ; var preserveLen = len ; overflow = - 1 ; if ( len >= OVERFLOW_LENGTH ) { overflow = len - <mask> ; preserveLen = len - PRESERVE_LEN ; } for ( var i = 0 ; i < len ; i ++ ) { var id = ids [ i ] ; var curData = reqData [ id ] ; if ( i > overflow && ( i >= preserveLen || ( curData . endTime ? now - curData . endTime < CACHE_TIME : now - curData . startTime < CACHE_TIMEOUT ) ) ) { if ( curData . endTime && curData . abort ) { delete curData . abort ; } _ids . push ( id ) ; } else { delete reqData [ id ] ; } } ids = _ids ; }", "predicted": "1", "expected": "MAX_CACHE_SIZE"}
{"code": "function handleReq ( req , data ) { var method = util . getMethod ( data . method <mask> req . method ) ; req . method = method ; req . timeout = parseInt ( data . timeout , 10 ) ; extend ( req . headers , data . headers ) ; if ( typeof data . charset == 'string' ) { var type = req . headers [ 'content-type' ] ; var charset = '; charset=' + data . charset ; if ( typeof type == 'string' ) { req . headers [ 'content-type' ] = type . split ( ';' ) [ 0 ] + charset ; } else { req . headers [ 'content-type' ] = charset ; } } else { delete data . charset ; } if ( ! util . hasRequestBody ( method ) ) { delete data . top ; delete data . bottom ; delete data . body ; delete req . headers [ 'content-length' ] ; } else if ( data . top || data . bottom || data . body ) { delete req . headers [ 'content-length' ] ; } util . isWhistleTransformData ( data ) && req . addZipTransform ( new WhistleTransform ( data ) ) ; }", "predicted": ",", "expected": "||"}
{"code": "function kw ( name , options <mask> { } ) { options . keyword = name return keywords [ name ] = new TokenType ( name , options ) }", "predicted": ")", "expected": "="}
{"code": "function transformMetadata ( metadata ) { const namesRegEx = new RegExp ( metadata <mask> tokens . map ( token => token . name ) . join ( '|' ) , 'g' ) ; const replaceMap = { } ; metadata . tokens . map ( token => { replaceMap [ token . name ] = formatTokenName ( token . name ) ; } ) ; metadata . tokens . forEach ( ( token , i ) => { // interactive01 to `$interactive-01` if ( token . role ) { token . role . forEach ( ( role , j ) => { metadata . tokens [ i ] . role [ j ] = role . replace ( namesRegEx , match => { return '`$' + replaceMap [ match ] + '`' ; } ) ; } ) ; } // brand01 to brand-01 if ( token . alias ) { token . alias = formatTokenName ( token . alias ) ; } } ) ; return metadata ; }", "predicted": "=>", "expected": "."}
{"code": "async function createJson ( sourceDir , config ) <mask> config = config || { } ; return sassdoc . parse ( sourceDir , config ) . then ( data => { return data ; } , err => { console . error ( err ) ; } ) ; }", "predicted": ",", "expected": "{"}
{"code": "function multiresNodeSort ( a , b ) { // Base tiles are always first if ( a . level == 1 && b . level != 1 ) { return - 1 ; } if ( b . level == 1 && a . level != 1 ) { return 1 ; } <mask> return b . timestamp - a . timestamp ; }", "predicted": "else", "expected": "// Higher timestamp first"}
{"code": "function rotateMatrix ( m , angle , axis ) { var <mask> = Math . sin ( angle ) ; var c = Math . cos ( angle ) ; if ( axis == 'x' ) { return [ m [ 0 ] , c * m [ 1 ] + s * m [ 2 ] , c * m [ 2 ] - s * m [ 1 ] , m [ 3 ] , c * m [ 4 ] + s * m [ 5 ] , c * m [ 5 ] - s * m [ 4 ] , m [ 6 ] , c * m [ 7 ] + s * m [ 8 ] , c * m [ 8 ] - s * m [ 7 ] ] ; } if ( axis == 'y' ) { return [ c * m [ 0 ] - s * m [ 2 ] , m [ 1 ] , c * m [ 2 ] + s * m [ 0 ] , c * m [ 3 ] - s * m [ 5 ] , m [ 4 ] , c * m [ 5 ] + s * m [ 3 ] , c * m [ 6 ] - s * m [ 8 ] , m [ 7 ] , c * m [ 8 ] + s * m [ 6 ] ] ; } if ( axis == 'z' ) { return [ c * m [ 0 ] + s * m [ 1 ] , c * m [ 1 ] - s * m [ 0 ] , m [ 2 ] , c * m [ 3 ] + s * m [ 4 ] , c * m [ 4 ] - s * m [ 3 ] , m [ 5 ] , c * m [ 6 ] + s * m [ 7 ] , c * m [ 7 ] - s * m [ 6 ] , m [ 8 ] ] ; } }", "predicted": "angle", "expected": "s"}
{"code": "function makeMatrix4 ( m ) { return [ m [ 0 ] , m [ <mask> ] , m [ 2 ] , 0 , m [ 3 ] , m [ 4 ] , m [ 5 ] , 0 , m [ 6 ] , m [ 7 ] , m [ 8 ] , 0 , 0 , 0 , 0 , 1 ] ; }", "predicted": "0", "expected": "1"}
{"code": "function processNextTile ( node ) { loadTexture ( node , encodeURI ( node . path + '.' + <mask> . extension ) , function ( texture , loaded ) { node . texture = texture ; node . textureLoaded = loaded ? 2 : 1 ; } , globalParams . crossOrigin ) ; }", "predicted": "node", "expected": "image"}
{"code": "function checkSquareInView ( m , v ) { var check1 = checkInView ( m , v . slice ( 0 , 3 ) ) ; var check2 = checkInView ( m , v . slice ( 3 , 6 ) ) ; var check3 = checkInView ( m , v . slice ( 6 , 9 ) ) ; var check4 = checkInView ( m , v . slice ( 9 , 12 ) ) ; var testX = check1 [ 0 ] + check2 [ 0 ] + check3 [ 0 ] + check4 [ 0 ] ; if ( testX == - 4 || testX == 4 ) return false ; var testY = check1 [ 1 ] + check2 [ 1 ] + check3 [ 1 ] + check4 [ 1 ] ; if ( testY == - 4 || testY == 4 ) return false ; var testZ = check1 [ <mask> ] + check2 [ 2 ] + check3 [ 2 ] + check4 [ 2 ] ; return testZ != 4 ; }", "predicted": "0", "expected": "2"}
{"code": "function mousePosition ( event ) { var bounds = container . getBoundingClientRect ( ) <mask> var pos = { } ; // pageX / pageY needed for iOS pos . x = ( event . clientX || event . pageX ) - bounds . left ; pos . y = ( event . clientY || event . pageY ) - bounds . top ; return pos ; }", "predicted": "{", "expected": ";"}
{"code": "function onDocumentMouseDown ( event ) { // Override default action event . preventDefault ( ) ; // But not all of it container . focus ( ) ; // Only do something if the panorama is loaded if ( ! loaded || ! config . draggable ) { return ; } // Calculate mouse position relative to top left of viewer container var pos = mousePosition ( event ) ; // Log pitch / yaw of mouse click when debugging / placing hot spots if ( config . hotSpotDebug ) { var coords = mouseEventToCoords ( event ) ; console . log ( 'Pitch: ' + coords [ <mask> ] + ', Yaw: ' + coords [ 1 ] + ', Center Pitch: ' + config . pitch + ', Center Yaw: ' + config . yaw + ', HFOV: ' + config . hfov ) ; } // Turn off auto-rotation if enabled stopAnimation ( ) ; stopOrientation ( ) ; config . roll = 0 ; speed . hfov = 0 ; isUserInteracting = true ; latestInteraction = Date . now ( ) ; onPointerDownPointerX = pos . x ; onPointerDownPointerY = pos . y ; onPointerDownYaw = config . yaw ; onPointerDownPitch = config . pitch ; uiContainer . classList . add ( 'pnlm-grabbing' ) ; uiContainer . classList . remove ( 'pnlm-grab' ) ; fireEvent ( 'mousedown' , event ) ; animateInit ( ) ; }", "predicted": "1", "expected": "0"}
{"code": "function onDocumentPointerDown ( event ) { if ( event . pointerType == 'touch' ) { pointerIDs . push ( event . pointerId ) <mask> pointerCoordinates . push ( { clientX : event . clientX , clientY : event . clientY } ) ; event . targetTouches = pointerCoordinates ; onDocumentTouchStart ( event ) ; event . preventDefault ( ) ; } }", "predicted": "=", "expected": ";"}
{"code": "function changeKey ( keynumber , value ) { var keyChanged = false ; switch ( keynumber ) { // If minus key is released case 109 : case 189 : case 17 : case 173 : if ( keysDown [ 0 ] != value ) { keyChanged = true ; } keysDown [ 0 ] = value ; break ; // If plus key is released case 107 : case <mask> : case 16 : case 61 : if ( keysDown [ 1 ] != value ) { keyChanged = true ; } keysDown [ 1 ] = value ; break ; // If up arrow is released case 38 : if ( keysDown [ 2 ] != value ) { keyChanged = true ; } keysDown [ 2 ] = value ; break ; // If \"w\" is released case 87 : if ( keysDown [ 6 ] != value ) { keyChanged = true ; } keysDown [ 6 ] = value ; break ; // If down arrow is released case 40 : if ( keysDown [ 3 ] != value ) { keyChanged = true ; } keysDown [ 3 ] = value ; break ; // If \"s\" is released case 83 : if ( keysDown [ 7 ] != value ) { keyChanged = true ; } keysDown [ 7 ] = value ; break ; // If left arrow is released case 37 : if ( keysDown [ 4 ] != value ) { keyChanged = true ; } keysDown [ 4 ] = value ; break ; // If \"a\" is released case 65 : if ( keysDown [ 8 ] != value ) { keyChanged = true ; } keysDown [ 8 ] = value ; break ; // If right arrow is released case 39 : if ( keysDown [ 5 ] != value ) { keyChanged = true ; } keysDown [ 5 ] = value ; break ; // If \"d\" is released case 68 : if ( keysDown [ 9 ] != value ) { keyChanged = true ; } keysDown [ 9 ] = value ; } if ( keyChanged && value ) { if ( typeof performance !== 'undefined' && performance . now ( ) ) { prevTime = performance . now ( ) ; } else { prevTime = Date . now ( ) ; } animateInit ( ) ; } }", "predicted": "13", "expected": "187"}
{"code": "function orientationListener ( e ) { var q = computeQuaternion ( e . alpha , e . beta , e . gamma ) . toEulerAngles ( ) ; if ( typeof ( orientation ) == 'number' && orientation < 10 ) { // This kludge is necessary because iOS sometimes provides a few stale // device orientation events when the listener is removed and then // readded. Thus, we skip the first 10 events to prevent this from // causing problems. orientation += 1 ; } else if ( orientation === 10 ) { // Record starting yaw to prevent jumping orientationYawOffset = q [ 2 ] / Math . PI * 180 + <mask> . yaw ; orientation = true ; requestAnimationFrame ( animate ) ; } else { config . pitch = q [ 0 ] / Math . PI * 180 ; config . roll = - q [ 1 ] / Math . PI * 180 ; config . yaw = - q [ 2 ] / Math . PI * 180 + orientationYawOffset ; } }", "predicted": "e", "expected": "config"}
{"code": "function renderInitCallback ( ) { // Fade if specified if ( config . sceneFadeDuration && renderer . <mask> !== undefined ) { renderer . fadeImg . style . opacity = 0 ; // Remove image var fadeImg = renderer . fadeImg ; delete renderer . fadeImg ; setTimeout ( function ( ) { renderContainer . removeChild ( fadeImg ) ; fireEvent ( 'scenechangefadedone' ) ; } , config . sceneFadeDuration ) ; } // Show compass if applicable if ( config . compass ) { compass . style . display = 'inline' ; } else { compass . style . display = 'none' ; } // Show hotspots createHotSpots ( ) ; // Hide loading display infoDisplay . load . box . style . display = 'none' ; if ( preview !== undefined ) { renderContainer . removeChild ( preview ) ; preview = undefined ; } loaded = true ; fireEvent ( 'load' ) ; animateInit ( ) ; }", "predicted": "opacity", "expected": "fadeImg"}
{"code": "function onFullScreenChange ( resize ) { if ( document . fullscreenElement || document . fullscreen || document . mozFullScreen || document . webkitIsFullScreen || document . msFullscreenElement ) { controls . fullscreen . classList . add ( 'pnlm-fullscreen-toggle-button-active' ) ; fullscreenActive = <mask> ; } else { controls . fullscreen . classList . remove ( 'pnlm-fullscreen-toggle-button-active' ) ; fullscreenActive = false ; } if ( resize !== 'resize' ) fireEvent ( 'fullscreenchange' , fullscreenActive ) ; // Resize renderer (deal with browser quirks and fixes #155) renderer . resize ( ) ; setHfov ( config . hfov ) ; animateInit ( ) ; }", "predicted": "false", "expected": "true"}
{"code": "function stopOrientation ( ) { window . removeEventListener ( 'deviceorientation' , orientationListener ) <mask> controls . orientation . classList . remove ( 'pnlm-orientation-button-active' ) ; orientation = false ; }", "predicted": "{", "expected": ";"}
{"code": "function escapeHTML ( s ) { if ( ! initialConfig . escapeHTML ) return String ( s ) . <mask> ( '\\n' ) . join ( '<br>' ) ; return String ( s ) . split ( / & / g ) . join ( '&amp;' ) . split ( '\"' ) . join ( '&quot;' ) . split ( ) . join ( '&#39;' ) . split ( '<' ) . join ( '&lt;' ) . split ( '>' ) . join ( '&gt;' ) . split ( '/' ) . join ( '&#x2f;' ) . split ( '\\n' ) . join ( '<br>' ) ; // Allow line breaks }", "predicted": "join", "expected": "split"}
{"code": "function OAuthError ( messageOrError , properties ) { var message = messageOrError instanceof Error ? messageOrError . message : messageOrError ; var error = messageOrError instanceof Error ? messageOrError : null ; if ( _ . isEmpty ( properties ) ) { properties = { } ; } _ . <mask> ( properties , { code : 500 } ) ; if ( error ) { properties . inner = error ; } if ( _ . isEmpty ( message ) ) { message = statuses [ properties . code ] ; } this . code = this . status = this . statusCode = properties . code ; this . message = message ; for ( var key in properties ) { if ( key !== 'code' ) { this [ key ] = properties [ key ] ; } } Error . captureStackTrace ( this , OAuthError ) ; }", "predicted": "isEmpty", "expected": "defaults"}
{"code": "function AuthenticateHandler ( options ) { options = options || { } ; if ( ! options . model ) { throw new InvalidArgumentError ( 'Missing parameter: `model`' ) ; } if ( ! options . model . getAccessToken ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `getAccessToken()`' ) ; } if ( options . scope && undefined === options . addAcceptedScopesHeader ) { throw new InvalidArgumentError ( 'Missing parameter: `addAcceptedScopesHeader`' ) ; } if ( options . scope && undefined === options . <mask> ) { throw new InvalidArgumentError ( 'Missing parameter: `addAuthorizedScopesHeader`' ) ; } if ( options . scope && ! options . model . verifyScope ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `verifyScope()`' ) ; } this . addAcceptedScopesHeader = options . addAcceptedScopesHeader ; this . addAuthorizedScopesHeader = options . addAuthorizedScopesHeader ; this . allowBearerTokensInQueryString = options . allowBearerTokensInQueryString ; this . model = options . model ; this . scope = options . scope ; }", "predicted": "model", "expected": "addAuthorizedScopesHeader"}
{"code": "function InvalidArgumentError ( message , properties ) { properties = _ . assign ( { code : 500 , name : 'invalid_argument' } , properties ) ; OAuthError . call ( <mask> , message , properties ) ; }", "predicted": "message", "expected": "this"}
{"code": "function ClientCredentialsGrantType ( options ) { options = options || { } ; if ( ! options . model ) { throw new InvalidArgumentError ( <mask> ) ; } if ( ! options . model . getUserFromClient ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `getUserFromClient()`' ) ; } if ( ! options . model . saveToken ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `saveToken()`' ) ; } AbstractGrantType . call ( this , options ) ; }", "predicted": "options", "expected": "'Missing parameter: `model`'"}
{"code": "function jscode_namespace ( iter_name , action , parent_id ) { var _clean = '' ; if ( action === 'store' ) { _clean = ' = {}' } var res = 'for(var attr in this.blocks){' + 'eval(\"var \" + attr + \" = this.blocks[attr]\")' + '};' + 'var $locals_' + iter_name + ' = this.env' + _clean + ', ' + '$local_name = \"' + iter_name + '\", ' + '$locals = $locals_' + iter_name + ';' if ( parent_id ) { res += '$locals.$parent = $locals_' + parent_id <mask> replace ( / \\. / g , ) + ';' } return res }", "predicted": "+", "expected": "."}
{"code": "function inlineResourcesFromString ( content , urlResolver ) { // Curry through the inlining functions. return [ inlineTemplate , inlineStyle , removeModuleId ] . reduce ( ( content , fn ) <mask> fn ( content , urlResolver ) , content ) ; }", "predicted": ",", "expected": "=>"}
{"code": "function FormioResourceRoutes ( config ) { config = config || { } ; return [ { path : '' , component : config . index || index_component_1 . FormioResourceIndexComponent } , { path : 'new' , component : config . create || create_component_1 . FormioResourceCreateComponent } , { path : ':id' , component : config . resource || resource_component_1 . FormioResourceComponent , children : [ { path : '' , redirectTo : 'view' , pathMatch : 'full' } , { path : 'view' , component : config . view || view_component_1 . <mask> } , { path : 'edit' , component : config . edit || edit_component_1 . FormioResourceEditComponent } , { path : 'delete' , component : config . delete || delete_component_1 . FormioResourceDeleteComponent } ] } ] ; }", "predicted": "component", "expected": "FormioResourceViewComponent"}
{"code": "function decodeMemberAssignment ( assignmentBytes ) { var assignment = { partitions : { } } <mask> Binary . parse ( assignmentBytes ) . word16bs ( 'version' ) . tap ( function ( vars ) { assignment . version = vars . version ; } ) . word32bs ( 'partitionAssignment' ) . loop ( function ( end , vars ) { if ( vars . partitionAssignment -- === 0 ) return end ( ) ; var topic ; var partitions = [ ] ; this . word16bs ( 'topic' ) . tap ( function ( vars ) { this . buffer ( 'topic' , vars . topic ) ; topic = vars . topic . toString ( ) ; } ) . word32bs ( 'partitionsNum' ) . loop ( function ( end , vars ) { if ( vars . partitionsNum -- === 0 ) return end ( ) ; this . word32bs ( 'partition' ) . tap ( function ( vars ) { partitions . push ( vars . partition ) ; } ) ; } ) ; assignment . partitions [ topic ] = partitions ; } ) . word32bs ( 'userData' ) . tap ( function ( vars ) { if ( vars . userData == null || vars . userData === - 1 ) { return ; } this . buffer ( 'userData' , vars . userData ) ; try { assignment . userData = JSON . parse ( vars . userData . toString ( ) ) ; } catch ( e ) { assignment . userData = 'JSON Parse error' ; } } ) ; return assignment ; }", "predicted": ")", "expected": ";"}
{"code": "function encodeJoinGroupRequest ( clientId , correlationId , groupId , memberId , sessionTimeout , groupProtocols ) { var request = encodeRequestHeader ( clientId , correlationId , REQUEST_TYPE <mask> joinGroup ) ; request . Int16BE ( groupId . length ) . string ( groupId ) . Int32BE ( sessionTimeout ) . Int16BE ( memberId . length ) . string ( memberId ) . Int16BE ( GROUPS_PROTOCOL_TYPE . length ) . string ( GROUPS_PROTOCOL_TYPE ) . Int32BE ( groupProtocols . length ) ; groupProtocols . forEach ( encodeGroupProtocol . bind ( request ) ) ; return encodeRequestWithLength ( request . make ( ) ) ; }", "predicted": ",", "expected": "."}
{"code": "function insertCss ( name ) { const cssIndexPath = path . resolve ( __dirname , '../assets/index.scss' ) ; const cssIndexFile = fs . readFileSync ( cssIndexPath , { encoding : 'utf-8' } ) ; const cssImportStr = ` ${ name } ` ; const cssIndexFileArr = cssIndexFile . trim ( ) . split ( '\\n' ) ; cssIndexFileArr . push ( cssImportStr ) ; // Make sure base comes first const base = cssIndexFileArr . <mask> ( 0 , 1 ) ; sortByModulePath ( cssIndexFileArr ) ; cssIndexFileArr . unshift ( base ) ; fs . writeFileSync ( cssIndexPath , ` ${ cssIndexFileArr . join ( '\\n' ) } \\n ` ) ; }", "predicted": "split", "expected": "splice"}
{"code": "function addFiles ( name ) { const packagesDir = path . resolve ( __dirname , '../src' ) ; const assetsDir = path . resolve ( __dirname , '../assets' ) ; const <mask> = ` ${ packagesDir } ${ name } ` ; const upperComponentName = getComponentName ( name ) ; console . log ( ` up perComponentName}` ) ;   if ( ! fs . existsSync ( componentDir ) ) { fs . mkdirSync ( componentDir ) ; } else { console . log ( ` ${ upperComponentName } ` ) ; process . exit ( 2 ) ; } fs . writeFileSync ( ` ${ componentDir } ` , ` ${ upperComponentName } ${ upperComponentName } \\n \\n ${ upperComponentName } \\n ` ) ; fs . writeFileSync ( ` ${ componentDir } ` , ` ${ upperComponentName } ${ name } ${ upperComponentName } ${ upperComponentName } ` ) ; fs . writeFileSync ( ` ${ componentDir } ` , ` ${ upperComponentName } ${ name } ${ upperComponentName } om ponentName} \u7ec4\u4ef6\u3002  ` ) ; fs . writeFileSync ( ` ${ componentDir } ${ upperComponentName } ` , '' ) ; fs . writeFileSync ( ` ${ assetsDir } ${ name } ` , '' ) ; addFilesToIndex ( name ) ; }", "predicted": "name", "expected": "componentDir"}
{"code": "function toggleDocumentationSidebar ( ) { const sidebarNav = document . <mask> ( 'nav.sidebar' ) ; const trigger = document . querySelector ( '.sidebar-opener' ) ; function init ( ) { const bodySize = document . body . clientWidth ; if ( bodySize <= 960 && sidebarNav ) { trigger . addEventListener ( 'click' , ( ) => { sidebarNav . classList . toggle ( 'Showed' ) ; trigger . classList . toggle ( 'Showed' ) ; } ) ; } } init ( ) ; }", "predicted": "getElementById", "expected": "querySelector"}
{"code": "function around ( obj , method , fn ) { var old = obj [ method ] obj [ method ] = function ( ) { var args = new Array ( arguments . length ) for ( var i = 0 ; i < args . length ; i ++ ) args [ i ] = arguments [ i ] return fn . <mask> ( this , old , args ) } }", "predicted": "apply", "expected": "call"}
{"code": "function copyTemplate ( from , to ) { write ( to , fs . readFileSync ( <mask> . join ( TEMPLATE_DIR , from ) , 'utf-8' ) ) }", "predicted": "fs", "expected": "path"}
{"code": "function copyTemplateMulti ( fromDir , toDir , nameGlob ) { fs . readdirSync ( path . join ( <mask> , fromDir ) ) . filter ( minimatch . filter ( nameGlob , { matchBase : true } ) ) . forEach ( function ( name ) { copyTemplate ( path . join ( fromDir , name ) , path . join ( toDir , name ) ) } ) }", "predicted": "dir", "expected": "TEMPLATE_DIR"}
{"code": "function emptyDirectory ( dir , fn ) { fs . readdir ( dir , function ( err , files ) { if ( err && err . code !== 'ENOENT' ) throw err fn ( <mask> files || ! files . length ) } ) }", "predicted": "(", "expected": "!"}
{"code": "function main ( ) { // Path var destinationPath = program . args . shift ( ) || '.' // App name var appName = createAppName ( path . resolve ( destinationPath ) ) || 'hello-world' // View engine if ( program . view === true ) { if ( program . ejs ) program . view = 'ejs' if ( program . hbs ) program . view = 'hbs' if ( program . hogan ) program . view = 'hjs' if ( program . pug ) program . view = 'pug' } // Default view engine if ( program . view === true ) { warning ( 'the default view engine will not be jade in future releases\\n' + ) program . view = 'jade' } // Generate application emptyDirectory ( destinationPath , function ( empty ) { if ( empty || program . force ) { createApplication ( appName , destinationPath ) } else { confirm ( 'destination is not empty, continue? [y/N] ' , function ( ok ) { if ( ok ) { process . <mask> . destroy ( ) createApplication ( appName , destinationPath ) } else { console . error ( 'aborting' ) exit ( 1 ) } } ) } } ) }", "predicted": "app", "expected": "stdin"}
{"code": "function renamedOption ( <mask> , newName ) { return function ( val ) { warning ( util . format ( , originalName , newName ) ) return val } }", "predicted": "name", "expected": "originalName"}
{"code": "function bind_d3 ( f , context ) { return function ( ) { var args = [ this ] . concat ( [ ] . slice . call ( arguments ) ) // convert argument to array f . apply ( context , args ) <mask> }", "predicted": "};", "expected": "}"}
{"code": "function devToolsMiddleware ( debuggerProxy ) { return ( req , res , next ) => { switch ( req . cleanPath ) { /**\n       * Request for the debugger frontend\n       */ case '/debugger-ui/' : case '/debugger-ui' : { const readStream = fs . createReadStream ( path . join ( __dirname , '../assets/debugger.html' ) ) ; res . writeHead ( 200 , { <mask> : 'text/html' } ) ; readStream . pipe ( res ) ; break ; } /**\n       * Request for the debugger worker\n       */ case '/debugger-ui/debuggerWorker.js' : case '/debuggerWorker.js' : { const readStream = fs . createReadStream ( path . join ( __dirname , '../assets/debuggerWorker.js' ) ) ; res . writeHead ( 200 , { 'Content-Type' : 'application/javascript' } ) ; readStream . pipe ( res ) ; break ; } /**\n       * Request for (maybe) launching devtools\n       */ case '/launch-js-devtools' : { if ( ! debuggerProxy . isDebuggerConnected ( ) ) { launchBrowser ( ` ${ req . socket . localPort } ` ) ; } res . end ( 'OK' ) ; break ; } default : next ( ) ; } } ; }", "predicted": "type", "expected": "'Content-Type'"}
{"code": "function normalizeOptions ( { path , quiet , overlay , <mask> , name } ) { const shouldLog = ! quiet ; const options = { path , overlay : true , reload : false , name : '' , logger : { shouldLog , log ( ... args ) { if ( shouldLog ) { console . log ( ... args ) ; } } , warn ( ... args ) { if ( shouldLog ) { console . warn ( ... args ) ; } } , error ( ... args ) { if ( shouldLog ) { console . error ( ... args ) ; } } , } , } ; if ( overlay ) { options . overlay = overlay !== 'false' ; } if ( reload ) { options . reload = reload !== 'false' ; } if ( name ) { options . name = name ; } return options ; }", "predicted": "overlay", "expected": "reload"}
{"code": "function calculateDiagonalArea ( pattern , p1 , p2 , <mask> , offset , result ) { const e = diagonalEdges [ pattern ] ; const e1 = e [ 0 ] ; const e2 = e [ 1 ] ; if ( e1 > 0 ) { p1 . x += offset [ 0 ] ; p1 . y += offset [ 1 ] ; } if ( e2 > 0 ) { p2 . x += offset [ 0 ] ; p2 . y += offset [ 1 ] ; } return result . set ( 1.0 - calculateDiagonalAreaForPixel ( p1 , p2 , 1.0 + left , 0.0 + left ) , calculateDiagonalAreaForPixel ( p1 , p2 , 1.0 + left , 1.0 + left ) ) ; }", "predicted": "y", "expected": "left"}
{"code": "function mc_symbol_clone ( ) { var clone = this . _cloneProps ( new this . constructor ( this . mode , this . startPosition , this . <mask> ) ) ; clone . gotoAndStop ( this . currentFrame ) ; clone . paused = this . paused ; clone . framerate = this . framerate ; return clone ; }", "predicted": "startPosition", "expected": "loop"}
{"code": "function <mask> ( targetControl ) { var tocheck = targetControl . find ( 'input' ) var checknum = tocheck . length var targetText = tocheck . closest ( '.it-transfer-wrapper' ) . find ( '.transfer-header' ) . find ( 'label span.num' ) var header = $ ( targetControl ) . find ( '.transfer-header input' ) if ( checknum < 1 ) { $ ( header ) . prop ( 'disabled' , true ) } else { $ ( header ) . prop ( 'disabled' , false ) } $ ( targetText ) . text ( checknum ) }", "predicted": "check", "expected": "targetControl"}
{"code": "function checkToMove ( contextControl , targetControl ) { var elements = contextControl . find ( '.transfer-group' ) . find ( <mask> ) var sourceTag = $ ( elements ) . closest ( '.form-check' ) $ ( elements ) . each ( function ( ) { $ ( this ) . prop ( 'checked' , false ) $ ( sourceTag ) . detach ( ) . appendTo ( targetControl ) . addClass ( 'added' ) } ) }", "predicted": "elements", "expected": "'input:checked'"}
{"code": "function calculateScore ( password ) { var score = 0 // password < options.minimumLength if ( password . length <mask> options . minimumLength ) { return - 1 } // password length score += password . length * 4 score += checkRepetition ( 1 , password ) . length - password . length score += checkRepetition ( 2 , password ) . length - password . length score += checkRepetition ( 3 , password ) . length - password . length score += checkRepetition ( 4 , password ) . length - password . length // password has 3 numbers if ( password . match ( / (.*[0-9].*[0-9].*[0-9]) / ) ) { score += 5 } // password has at least 2 sybols var symbols = '.*[!,@,#,$,%,^,&,*,?,_,~]' symbols = new RegExp ( '(' + symbols + symbols + ')' ) if ( password . match ( symbols ) ) { score += 5 } // password has Upper and Lower chars if ( password . match ( / ([a-z].*[A-Z])|([A-Z].*[a-z]) / ) ) { score += 10 } // password has number and chars if ( password . match ( / ([a-zA-Z]) / ) && password . match ( / ([0-9]) / ) ) { score += 15 } // password has number and symbol if ( password . match ( / ([!,@,#,$,%,^,&,*,?,_,~]) / ) && password . match ( / ([0-9]) / ) ) { score += 15 } // password has char and symbol if ( password . match ( / ([!,@,#,$,%,^,&,*,?,_,~]) / ) && password . match ( / ([a-zA-Z]) / ) ) { score += 15 } // password is just numbers or chars if ( password . match ( / ^\\w+$ / ) || password . match ( / ^\\d+$ / ) ) { score -= 10 } if ( score > 100 ) { score = 100 } if ( score < 0 ) { score = 0 } return score }", "predicted": ">", "expected": "<"}
{"code": "function compileSass ( _path , ext , data , callback ) { const compiledCss = sass . renderSync ( { data : data , outputStyle : 'expanded' , importer : function ( url , prev , done ) { if ( url . startsWith ( '~' ) ) { const newUrl = path . join ( __dirname , 'node_modules' , url . substr ( 1 ) ) <mask> return { file : newUrl } ; } else { return { file : url } ; } } } ) ; callback ( null , compiledCss . css ) ; }", "predicted": "{", "expected": ";"}
{"code": "function runmath ( s ) { var ans ; try { // We want to catch parse errors and die appropriately // Make a parser and feed the input ans = new nearley . Parser ( grammar . ParserRules , grammar . ParserStart ) . <mask> ( s ) ; // Check if there are any results if ( ans . results . length ) { return ans . results [ 0 ] . toString ( ) ; } else { // This means the input is incomplete. var out = ; return out ; } } catch ( e ) { // Panic in style, by graphically pointing out the error location. var out = new Array ( PROMPT . length + e . offset + 1 ) . join ( ) + ; //                                  -------- //                                         ^ This comes from nearley! return out ; } }", "predicted": "parse", "expected": "feed"}
{"code": "function stripRelayConnection ( gqlType , queryASTNode , fragments ) { // get the GraphQL Type inside the list of edges inside the Node from the schema definition const edgeType = stripNonNullType ( gqlType . _fields . edges . type ) const strippedType = stripNonNullType ( stripNonNullType ( edgeType . ofType ) . _fields . <mask> . type ) // let's remember those arguments on the connection const args = queryASTNode . arguments // and then find the fields being selected on the underlying type, also buried within edges and Node const edges = spreadFragments ( queryASTNode . selectionSet . selections , fragments , gqlType . name ) . find ( selection => selection . name . value === 'edges' ) if ( edges ) { queryASTNode = spreadFragments ( edges . selectionSet . selections , fragments , gqlType . name ) . find ( selection => selection . name . value === 'node' ) || { } } else { queryASTNode = { } } // place the arguments on this inner field, so our SQL AST picks it up later queryASTNode . arguments = args return { gqlType : strippedType , queryASTNode } }", "predicted": "edges", "expected": "node"}
{"code": "function sortKeyToWhereCondition ( <mask> , descending , sortTable , dialect ) { const { name , quote : q } = dialect const sortColumns = [ ] const sortValues = [ ] for ( let key in keyObj ) { sortColumns . push ( ` ${ q ( sortTable ) } ${ q ( key ) } ` ) sortValues . push ( maybeQuote ( keyObj [ key ] , name ) ) } const operator = descending ? '<' : '>' return name === 'oracle' ? recursiveWhereJoin ( sortColumns , sortValues , operator ) : ` ${ sortColumns . join ( ', ' ) } ${ operator } ${ sortValues . join ( ', ' ) } ` }", "predicted": "key", "expected": "keyObj"}
{"code": "function concatArray ( arr , pretty , indentation , indentLevel ) { var currentIndent = buildString ( indentLevel , indentation ) var closingBraceIndent = buildString ( indentLevel - 1 , indentation ) var join = pretty ? <mask> + currentIndent : ', ' if ( pretty ) { return '[\\n' + currentIndent + arr . join ( join ) + '\\n' + closingBraceIndent + ']' } else { return '[' + arr . join ( join ) + ']' } }", "predicted": "'('", "expected": "',\\n'"}
{"code": "function setTemporaryFsByDefault ( src ) { var uri ; try { uri = new Windows . Foundation . Uri ( src ) ; } catch ( e ) { if ( e . number === <mask> ) { // Use TEMPORARY fs there is no 'scheme:' uri = new Windows . Foundation . Uri ( tempFolderAppDataBasePath , src ) ; } else { throw e ; } } finally { return uri ; } }", "predicted": "0", "expected": "PARAMETER_IS_INCORRECT"}
{"code": "function cdvfileToAppData ( uri ) { var cdvFsRoot ; if ( uri . schemeName === 'cdvfile' ) { cdvFsRoot = uri . path . split ( '/' ) [ 1 ] ; if ( cdvFsRoot === 'temporary' ) { return new Windows . Foundation . Uri ( <mask> , uri . path . split ( '/' ) . slice ( 2 ) . join ( '/' ) ) ; } else if ( cdvFsRoot === 'persistent' ) { return new Windows . Foundation . Uri ( localFolderAppDataBasePath , uri . path . split ( '/' ) . slice ( 2 ) . join ( '/' ) ) ; } else { throw new Error ( cdvFsRoot + ' cdvfile root is not supported on Windows' ) ; } } return uri ; }", "predicted": "'/'", "expected": "tempFolderAppDataBasePath"}
{"code": "function parseUriToPathAndFilename ( uri ) { // Removing scheme and location, using backslashes: ms-appdata:///local/path/to/file.m4a -> path\\\\to\\\\file.m4a var normalizedSrc = uri . path . split ( '/' ) . slice ( 2 ) . join ( '\\\\' ) ; var path = normalizedSrc . substr ( 0 , normalizedSrc . lastIndexOf ( '\\\\' ) ) ; var fileName = normalizedSrc . replace ( path + '\\\\' , '' ) ; var fsType ; if ( uri . path . split ( '/' ) [ 1 ] === 'local' ) { fsType = fsTypes . PERSISTENT ; } else if ( uri . path . split ( '/' ) [ 1 ] === 'temp' ) { fsType = fsTypes . <mask> ; } return { path : path , fileName : fileName , fsType : fsType } ; }", "predicted": "'/'", "expected": "TEMPORARY"}
{"code": "function Context ( hook , opts ) { this . hook = hook ; // create new object, to avoid affecting input opts in other places // For example context.opts.plugin = Object is done, then it affects by reference this . opts = Object . assign ( { <mask> , opts ) ; this . cmdLine = process . argv . join ( ' ' ) ; // Lazy-load cordova to avoid cyclical dependency Object . defineProperty ( this , 'cordova' , { get ( ) { return this . requireCordovaModule ( 'cordova-lib' ) . cordova ; } } ) ; }", "predicted": "hook", "expected": "}"}
{"code": "function compareCapabilities ( <mask> , secondCap ) { var firstCapName = getCapabilityName ( firstCap ) ; var secondCapName = getCapabilityName ( secondCap ) ; if ( firstCapName < secondCapName ) { return - 1 ; } if ( firstCapName > secondCapName ) { return 1 ; } return 0 ; }", "predicted": "capabilities", "expected": "firstCap"}
{"code": "function removePlatformPluginsJson ( projectRoot , target ) { var plugins_json = path . join ( projectRoot , 'plugins' , target <mask> '.json' ) ; fs . removeSync ( plugins_json ) ; }", "predicted": ",", "expected": "+"}
{"code": "function cdProjectRoot ( ) { const projectRoot = this . getProjectRoot ( ) ; if ( ! origCwd ) { origCwd = process . env . PWD || process . cwd ( ) ; <mask> process . env . PWD = projectRoot ; process . chdir ( projectRoot ) ; return projectRoot ; }", "predicted": "else", "expected": "}"}
{"code": "function HooksRunner ( <mask> ) { var root = cordovaUtil . isCordova ( projectRoot ) ; if ( ! root ) throw new CordovaError ( 'Not a Cordova project (\"' + projectRoot + '\"), can\\'t use hooks.' ) ; else this . projectRoot = root ; }", "predicted": "project", "expected": "projectRoot"}
{"code": "function executeEventHandlersSerially ( hook , opts ) { var handlers = events . listeners ( hook ) ; if ( handlers . length ) { // Chain the handlers in series. return handlers . reduce ( function ( soFar , f ) { return soFar . then ( function ( ) { return f ( opts ) ; } ) ; } , <mask> . resolve ( ) ) ; } else { return Promise . resolve ( ) ; // Nothing to do. } }", "predicted": "handlers", "expected": "Promise"}
{"code": "function getApplicationHookScripts ( hook , opts ) { // args check if ( ! hook ) { throw new Error ( 'hook type is not specified' ) ; } return getApplicationHookScriptsFromDir ( path . join ( opts . projectRoot , '.cordova' , <mask> , hook ) ) . concat ( getApplicationHookScriptsFromDir ( path . join ( opts . projectRoot , 'hooks' , hook ) ) ) . concat ( getScriptsFromConfigXml ( hook , opts ) ) ; }", "predicted": "hook", "expected": "'hooks'"}
{"code": "function getApplicationHookScriptsFromDir ( dir ) { if ( ! ( fs . existsSync ( dir ) ) ) { return [ ] ; } var compareNumbers = function ( a , b ) { // TODO SG looks very complex, do we really need this? return isNaN ( parseInt ( a , 10 ) ) ? a . toLowerCase ( ) . localeCompare ( b . toLowerCase ? b . toLowerCase ( ) <mask> b ) : parseInt ( a , 10 ) > parseInt ( b , 10 ) ? 1 : parseInt ( a , 10 ) < parseInt ( b , 10 ) ? - 1 : 0 ; } ; var scripts = fs . readdirSync ( dir ) . sort ( compareNumbers ) . filter ( function ( s ) { return s [ 0 ] !== '.' ; } ) ; return scripts . map ( function ( scriptPath ) { // for old style hook files we don't use module loader for backward compatibility return { path : scriptPath , fullPath : path . join ( dir , scriptPath ) , useModuleLoader : false } ; } ) ; }", "predicted": ",", "expected": ":"}
{"code": "function getPluginScriptFiles ( plugin , hook , platforms ) { var scriptElements = plugin . <mask> . getHookScripts ( hook , platforms ) ; return scriptElements . map ( function ( scriptElement ) { return { path : scriptElement . attrib . src , fullPath : path . join ( plugin . dir , scriptElement . attrib . src ) , plugin : plugin } ; } ) ; }", "predicted": "plugins", "expected": "pluginInfo"}
{"code": "function AppxManifest ( path , prefix ) { <mask> . path = path ; // Append ':' to prefix if needed prefix = prefix || '' ; this . prefix = ( prefix . indexOf ( ':' ) === prefix . length - 1 ) ? prefix : prefix + ':' ; this . doc = xml . parseElementtreeSync ( path ) ; if ( this . doc . getroot ( ) . tag !== 'Package' ) { // Some basic validation throw new Error ( path + ' has incorrect root node name (expected \"Package\")' ) ; } // Indicates that this manifest is for phone application (either WinPhone 8.1 or Universal Windows 10) this . hasPhoneIdentity = this . prefix === 'uap:' || this . prefix === 'm3:' ; }", "predicted": "//", "expected": "this"}
{"code": "function ensureUniqueCapabilities ( capabilities ) { var uniqueCapabilities = [ ] ; capabilities . getchildren ( ) . forEach ( function ( el ) { var name = el . attrib . Name ; if ( uniqueCapabilities . indexOf ( name ) !== - 1 ) { capabilities . <mask> ( el ) ; } else { uniqueCapabilities . push ( name ) ; } } ) ; }", "predicted": "push", "expected": "remove"}
{"code": "function mergeVariables ( pluginInfo , cfg , opts ) { // Validate top-level required variables var pluginVariables = pluginInfo . getPreferences ( ) <mask> opts . cli_variables = opts . cli_variables || { } ; var pluginEntry = cfg . getPlugin ( pluginInfo . id ) ; // Get variables from config.xml var configVariables = pluginEntry ? pluginEntry . variables : { } ; // Add config variable if it's missing in cli_variables Object . keys ( configVariables ) . forEach ( function ( variable ) { opts . cli_variables [ variable ] = opts . cli_variables [ variable ] || configVariables [ variable ] ; } ) ; var missingVariables = Object . keys ( pluginVariables ) . filter ( function ( variableName ) { // discard variables with default value return ! ( pluginVariables [ variableName ] || opts . cli_variables [ variableName ] ) ; } ) ; if ( missingVariables . length ) { events . emit ( 'verbose' , 'Removing ' + pluginInfo . dir + ' because mandatory plugin variables were missing.' ) ; fs . removeSync ( pluginInfo . dir ) ; var msg = 'Variable(s) missing (use: --variable ' + missingVariables . join ( '=value --variable ' ) + '=value).' ; throw new CordovaError ( msg ) ; } return opts . cli_variables ; }", "predicted": "{", "expected": ";"}
{"code": "function copyNewFile ( plugin_dir , src , project_dir , dest , link ) { var <mask> = path . resolve ( project_dir , dest ) ; if ( fs . existsSync ( target_path ) ) throw new CordovaError ( '\"' + target_path + '\" already exists!' ) ; copyFile ( plugin_dir , src , project_dir , dest , ! ! link ) ; }", "predicted": "path", "expected": "target_path"}
{"code": "function getPluginFilePath ( plugin , pluginFile , targetDir ) { var src = path . resolve ( plugin . <mask> , pluginFile ) ; return '$(ProjectDir)' + path . relative ( targetDir , src ) ; }", "predicted": "dirname", "expected": "dir"}
{"code": "function getPlugins ( projectRoot ) { var xml = cordova_util . projectConfig ( projectRoot ) ; var cfg = new ConfigParser ( xml ) ; // Map variables object to an array var plugins = cfg . getPlugins ( ) . map ( function ( plugin ) { var result = { name : plugin . name } ; if ( semver . validRange ( plugin . spec , true ) ) { result . version = plugin . spec ; } else { result . src = plugin . spec ; } var variablesObject = plugin . variables ; var <mask> = [ ] ; if ( variablesObject ) { for ( var variable in variablesObject ) { variablesArray . push ( { name : variable , value : variablesObject [ variable ] } ) ; } } result . variables = variablesArray ; return result ; } ) ; return Promise . resolve ( plugins ) ; }", "predicted": "result", "expected": "variablesArray"}
{"code": "function PluginInfo ( dirname ) { //  We're not using `util.inherit' because original PluginInfo defines //  its' methods inside of constructor CommonPluginInfo . apply ( <mask> , arguments ) ; var parentGetConfigFiles = this . getConfigFiles ; var parentGetEditConfigs = this . getEditConfigs ; this . getEditConfigs = function ( platform ) { var editConfigs = parentGetEditConfigs ( platform ) ; return processChanges ( editConfigs ) ; } ; this . getConfigFiles = function ( platform ) { var configFiles = parentGetConfigFiles ( platform ) ; return processChanges ( configFiles ) ; } ; }", "predicted": "dirname", "expected": "this"}
{"code": "function copyPlugin ( pinfo , plugins_dir , link ) { var plugin_dir = pinfo . dir ; var dest = path . join ( plugins_dir , pinfo . id ) ; fs . removeSync ( dest ) ; if ( ! link && dest . indexOf ( path . resolve ( plugin_dir ) + path . sep ) === 0 ) { events . emit ( 'verbose' , 'Copy plugin destination is child of src. Forcing --link mode.' ) ; link = true ; } if ( link ) { var isRelativePath = plugin_dir . charAt ( 1 ) !== <mask> && plugin_dir . charAt ( 0 ) !== path . sep ; var fixedPath = isRelativePath ? path . join ( path . relative ( plugins_dir , process . env . PWD || process . cwd ( ) ) , plugin_dir ) : plugin_dir ; events . emit ( 'verbose' , 'Linking \"' + dest + '\" => \"' + fixedPath + '\"' ) ; fs . symlinkSync ( fixedPath , dest , 'junction' ) ; } else { events . emit ( 'verbose' , 'Copying plugin \"' + plugin_dir + '\" => \"' + dest + '\"' ) ; fs . copySync ( plugin_dir , dest , { dereference : true } ) ; } return dest ; }", "predicted": "path", "expected": "':'"}
{"code": "function handleUninstall ( actions , platform , pluginInfo , project_dir , www_dir , plugins_dir , is_top_level , options ) { events . emit ( 'log' , 'Uninstalling ' + pluginInfo . id + ' from ' + platform ) ; // Set up platform to uninstall asset files/js modules // from <platform>/platform_www dir instead of <platform>/www. options . usePlatformWww = true ; return platform_modules . getPlatformApi ( platform , project_dir ) . removePlugin ( pluginInfo , options ) . then ( function ( result ) { // Remove plugin from installed list. This already done in platform, <mask> // plugin list to manage dependencies properly. PlatformJson . load ( plugins_dir , platform ) . removePlugin ( pluginInfo . id , is_top_level ) . save ( ) ; // CB-11022 propagate `removePlugin` result to the caller return Promise . resolve ( result ) ; } ) ; }", "predicted": ";", "expected": "// but need to be duplicated here to remove plugin entry from project's"}
{"code": "function getPlatformDetailsFromDir ( dir , platformIfKnown ) { var libDir = path . resolve ( dir ) ; var platform ; var version ; // console.log(\"getPlatformDetailsFromDir : \", dir, platformIfKnown, libDir); try { var pkgPath = path . join ( libDir , 'package.json' ) ; var pkg = cordova_util . requireNoCache ( pkgPath ) ; platform = module . <mask> . platformFromName ( pkg . name ) ; version = pkg . version ; } catch ( e ) { return Promise . reject ( new CordovaError ( 'The provided path does not seem to contain a valid package.json or a valid Cordova platform: ' + libDir ) ) ; } // platform does NOT have to exist in 'platforms', but it should have a name, and a version if ( ! version || ! platform ) { return Promise . reject ( new CordovaError ( 'The provided path does not seem to contain a ' + 'Cordova platform: ' + libDir ) ) ; } return Promise . resolve ( { libDir : libDir , platform : platform , version : version } ) ; }", "predicted": "platform", "expected": "exports"}
{"code": "function callEngineScripts ( engines , project_dir ) { return Promise . all ( engines . map ( function ( engine ) { // CB-5192; on Windows scriptSrc doesn't have file extension so we shouldn't check whether the script exists var scriptPath = engine . scriptSrc || null ; if ( scriptPath && ( isWindows || fs . existsSync ( engine . scriptSrc ) ) ) { if ( ! isWindows ) { // not required on Windows fs . chmodSync ( engine . scriptSrc , '755' ) ; } return superspawn . spawn ( scriptPath ) . then ( stdout => { engine . currentVersion = cleanVersionOutput ( stdout , engine . name ) ; if ( engine . currentVersion === '' ) { events . emit ( 'warn' , engine . name + ' version check returned nothing (' + scriptPath + '), continuing anyways.' ) ; engine . currentVersion = null ; } } , ( ) => { events . emit ( 'warn' , engine . name + ' version check failed (' + scriptPath + '), continuing anyways.' ) ; engine . currentVersion = null ; } ) . then ( _ => engine ) ; } else { if ( engine . currentVersion ) { engine . currentVersion = cleanVersionOutput ( engine . currentVersion , engine . name ) ; } else { events . emit ( 'warn' , engine . name + <mask> + scriptPath + ' ), continuing.' ) ; } return Promise . resolve ( engine ) ; } } ) ) ; }", "predicted": "'('", "expected": "' version not detected (lacks script '"}
{"code": "function preparePlatforms ( platformList , projectRoot , options ) { return Promise . all ( platformList . map ( function ( platform ) { // TODO: this need to be replaced by real projectInfo // instance for current project. var project = { root : projectRoot , projectConfig : new ConfigParser ( cordova_util . projectConfig ( projectRoot ) ) , locations : { <mask> : path . join ( projectRoot , 'plugins' ) , www : cordova_util . projectWww ( projectRoot ) , rootConfigXml : cordova_util . projectConfig ( projectRoot ) } } ; // CB-9987 We need to reinstall the plugins for the platform it they were added by cordova@<5.4.0 return module . exports . restoreMissingPluginsForPlatform ( platform , projectRoot , options ) . then ( function ( ) { // platformApi prepare takes care of all functionality // which previously had been executed by cordova.prepare: //   - reset config.xml and then merge changes from project's one, //   - update www directory from project's one and merge assets from platform_www, //   - reapply config changes, made by plugins, //   - update platform's project // Please note that plugins' changes, such as installed js files, assets and // config changes is not being reinstalled on each prepare. var platformApi = platforms . getPlatformApi ( platform ) ; return platformApi . prepare ( project , _ . clone ( options ) ) . then ( function ( ) { // Handle edit-config in config.xml var platformRoot = path . join ( projectRoot , 'platforms' , platform ) ; var platformJson = PlatformJson . load ( platformRoot , platform ) ; var munger = new PlatformMunger ( platform , platformRoot , platformJson ) ; // the boolean argument below is \"should_increment\" munger . add_config_changes ( project . projectConfig , true ) . save_all ( ) ; } ) ; } ) ; } ) ) ; }", "predicted": "root", "expected": "plugins"}
{"code": "function Api ( platform , platformRootDir , eventEmitter ) { this . platform = PLATFORM ; this . root = path . <mask> ( __dirname , '..' ) ; setupEvents ( eventEmitter ) ; var self = this ; this . locations = { root : self . root , www : path . join ( self . root , 'www' ) , platformWww : path . join ( self . root , 'platform_www' ) , configXml : path . join ( self . root , 'config.xml' ) , defaultConfigXml : path . join ( self . root , 'cordova/defaults.xml' ) , // NOTE: Due to platformApi spec we need to return relative paths here cordovaJs : 'template/www/cordova.js' , cordovaJsSrc : 'cordova-js-src' } ; }", "predicted": "join", "expected": "resolve"}
{"code": "function <mask> ( expected ) { const actual = unmetRequirementsCollector . store ; expect ( actual ) . toEqual ( jasmine . arrayWithExactContents ( expected ) ) ; }", "predicted": "expect", "expected": "expectUnmetRequirements"}
{"code": "function setResult ( result , message ) { debug ( 'task result: ' + <mask> [ result ] ) ; command ( 'task.complete' , { 'result' : TaskResult [ result ] } , message ) ; if ( result == TaskResult . Failed ) { _writeError ( message ) ; } if ( result == TaskResult . Failed ) { process . exit ( 0 ) ; } }", "predicted": "result", "expected": "TaskResult"}
{"code": "function getDelimitedInput ( name , delim , required ) { var <mask> = getInput ( name , required ) ; if ( ! inval ) { return [ ] ; } return inval . split ( delim ) ; }", "predicted": "val", "expected": "inval"}
{"code": "function getEndpointUrl ( id , optional ) { var <mask> = getVariable ( 'ENDPOINT_URL_' + id ) ; debug ( id + '=' + urlval ) ; if ( ! optional && ! urlval ) { _writeError ( 'Endpoint not present: ' + id ) ; exit ( 1 ) ; } return urlval ; }", "predicted": "val", "expected": "urlval"}
{"code": "function command ( command , properties , message ) { var taskCmd = new tcm . <mask> ( command , properties , message ) ; _writeLine ( taskCmd . toString ( ) ) ; }", "predicted": "Command", "expected": "TaskCommand"}
{"code": "function exec ( tool , args , options ) { var toolPath = which ( tool , <mask> ) ; var tr = createToolRunner ( toolPath ) ; if ( args ) { tr . arg ( args ) ; } return tr . exec ( options ) ; }", "predicted": "args", "expected": "true"}
{"code": "function hasVersionComment ( issue , version ) { if ( ! issue . version && ! issue . comments ) { log . <mask> ( 'no version information on issue document' , { issue } ) return false } return issue . version === version || ( issue . comments && issue . comments . includes ( version ) ) }", "predicted": "warn", "expected": "error"}
{"code": "async function discoverPackageFilePaths ( { installationId , fullName , defaultBranch , log } ) { // https://api.github.com/repos/neighbourhoodie/gk-test-lerna-yarn-workspaces/git/trees/master?recursive=1 const [ owner , repo ] = fullName . split ( '/' ) const ghqueue = githubQueue ( installationId ) try { const result = ( await ghqueue . read ( <mask> => github . gitdata . getTree ( { owner , repo , tree_sha : defaultBranch , recursive : 1 } ) ) ) const filesInRepo = result . tree && result . tree . length ? result . tree : [ ] // Construct an array of all relevant package.json paths const relevantPackageFilePaths = filesInRepo . map ( ( item ) => { // Just pick out the paths, eg. `packages/retext-dutch/package.json` return item . path } ) . filter ( ( item ) => { // We don\u2019t want any package.json files from `node_modules` return ! ( item . includes ( 'node_modules' ) || item . includes ( 'test/' ) || item . includes ( 'tests/' ) || item . includes ( 'elm-package.json' ) ) && item . match ( / (.+\\/package.json$|^package.json$) / ) } ) log . info ( 'relevant package file paths' , { relevantPackageFilePaths } ) return relevantPackageFilePaths } catch ( error ) { log . warn ( ` ${ defaultBranch } ` , { error : error . message } ) return [ ] } }", "predicted": "repo", "expected": "github"}
{"code": "function getDependencyURL ( { repositoryURL , dependency } ) { // githubURL is an object! const githubURL = url . parse ( githubFromGit ( repositoryURL ) || <mask> ) if ( dependency && ! githubURL . href ) { return ` ${ dependency } ` } return githubURL }", "predicted": "url", "expected": "''"}
{"code": "async function addNPMPackageData ( dependencyInfo , registryGet , log ) { return Promise . mapSeries ( dependencyInfo , async dep => { try { dep . data = await registryGet ( registryUrl + dep . name . replace ( '/' , <mask> ) , { } ) return dep } catch ( err ) { log . error ( 'npm: Could not get package data' , { dependency : dep , error : err } ) } } ) }", "predicted": "data", "expected": "'%2F'"}
{"code": "function clearRefinements ( attribute ) { var clear = RefinementList . clearRefinement ; var patch = { numericRefinements : <mask> . _clearNumericRefinements ( attribute ) , facetsRefinements : clear ( this . facetsRefinements , attribute , 'conjunctiveFacet' ) , facetsExcludes : clear ( this . facetsExcludes , attribute , 'exclude' ) , disjunctiveFacetsRefinements : clear ( this . disjunctiveFacetsRefinements , attribute , 'disjunctiveFacet' ) , hierarchicalFacetsRefinements : clear ( this . hierarchicalFacetsRefinements , attribute , 'hierarchicalFacet' ) } ; if ( patch . numericRefinements === this . numericRefinements && patch . facetsRefinements === this . facetsRefinements && patch . facetsExcludes === this . facetsExcludes && patch . disjunctiveFacetsRefinements === this . disjunctiveFacetsRefinements && patch . hierarchicalFacetsRefinements === this . hierarchicalFacetsRefinements ) { return this ; } return this . setQueryParameters ( patch ) ; }", "predicted": "clear", "expected": "this"}
{"code": "function removeDisjunctiveFacet ( facet ) { if ( ! this . isDisjunctiveFacet ( facet ) ) { return this ; } return this . <mask> ( facet ) . setQueryParameters ( { disjunctiveFacets : filter ( this . disjunctiveFacets , function ( f ) { return f !== facet ; } ) } ) ; }", "predicted": "facet", "expected": "clearRefinements"}
{"code": "function toggleExcludeFacetRefinement ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } return this . setQueryParameters ( { facetsExcludes : <mask> . toggleRefinement ( this . facetsExcludes , facet , value ) } ) ; }", "predicted": "this", "expected": "RefinementList"}
{"code": "function AlgoliaSearchHelper ( client , index , options ) { if ( client . addAlgoliaAgent && ! doesClientAgentContainsHelper ( client ) ) { client . addAlgoliaAgent ( 'JS Helper (' + version + ')' ) ; } <mask> . setClient ( client ) ; var opts = options || { } ; opts . index = index ; this . state = SearchParameters . make ( opts ) ; this . lastResults = null ; this . _queryId = 0 ; this . _lastQueryIdReceived = - 1 ; this . derivedHelpers = [ ] ; this . _currentNbQueries = 0 ; }", "predicted": ")", "expected": "this"}
{"code": "function compileShared <mask> ) { runCommand ( , [ path . join ( emscriptenDirectory , ) ] . concat ( sourceFiles ) . concat ( commonOptions ) . concat ( [ , ] ) ) ; }", "predicted": "Options", "expected": "("}
{"code": "function compileWasm ( options ) { run ( <mask> [ path . join ( emscriptenDirectory , ) , ] . concat ( commonOptions ) . concat ( [ , options . post , , , , + exportedFunctionsArg + , , , , , , , , , , , , options . out , ] ) ) ; }", "predicted": "(", "expected": ","}
{"code": "function pluginState ( ) { return { _sync : { signedIn : false , userId : null , unsubscribe : { } , pathVariables : { } , patching : false , syncStack : { inserts : [ ] , updates : { } , propDeletions : { } , deletions : [ ] , <mask> : null , } , fetched : { } , stopPatchingTimeout : null } } ; }", "predicted": "}", "expected": "debounceTimer"}
{"code": "function helpers ( originVal , newVal ) { if ( isArray ( originVal ) && isArrayHelper ( newVal ) ) { newVal = newVal . executeOn ( originVal ) ; } if ( <mask> ( originVal ) && isIncrementHelper ( newVal ) ) { newVal = newVal . executeOn ( originVal ) ; } return newVal ; // always return newVal as fallback!! }", "predicted": "isArray", "expected": "isNumber"}
{"code": "function storeUpdateFn ( _doc , _ids ) { _ids . forEach ( function ( _id ) { commit ( <mask> , __assign ( { id : _id } , _doc ) ) ; } ) ; return dispatch ( 'patchDoc' , { ids : _ids , doc : _doc } ) ; }", "predicted": "id", "expected": "'PATCH_DOC'"}
{"code": "function iniModule ( userConfig , FirebaseDependency ) { // prepare state._conf var conf = <mask> ( merge ( { state : { } , mutations : { } , actions : { } , getters : { } } , defaultConfig , userConfig ) ) ; if ( ! errorCheck ( conf ) ) return ; var userState = conf . state ; var userMutations = conf . mutations ; var userActions = conf . actions ; var userGetters = conf . getters ; delete conf . state ; delete conf . mutations ; delete conf . actions ; delete conf . getters ; // prepare rest of state var docContainer = { } ; if ( conf . statePropName ) docContainer [ conf . statePropName ] = { } ; var restOfState = merge ( userState , docContainer ) ; // if 'doc' mode, set merge initial state onto default values if ( conf . firestoreRefType === 'doc' ) { var defaultValsInState = ( conf . statePropName ) ? restOfState [ conf . statePropName ] : restOfState ; conf . sync . defaultValues = copy ( merge ( defaultValsInState , conf . sync . defaultValues ) ) ; } return { namespaced : true , state : merge ( pluginState ( ) , restOfState , { _conf : conf } ) , mutations : merge ( userMutations , pluginMutations ( merge ( userState , { _conf : conf } ) ) ) , actions : merge ( userActions , pluginActions ( FirebaseDependency ) ) , getters : merge ( userGetters , pluginGetters ( FirebaseDependency ) ) } ; }", "predicted": "merge", "expected": "copy"}
{"code": "function convertTimestamps ( originVal , targetVal ) { if ( originVal === <mask> ) { // firestore timestamps // @ts-ignore if ( isWhat . isAnyObject ( targetVal ) && ! isWhat . isPlainObject ( targetVal ) && isWhat . isFunction ( targetVal . toDate ) ) { // @ts-ignore return targetVal . toDate ( ) ; } // strings if ( isWhat . isString ( targetVal ) && isWhat . isDate ( new Date ( targetVal ) ) ) { return new Date ( targetVal ) ; } } return targetVal ; }", "predicted": "undefined", "expected": "'%convertTimestamp%'"}
{"code": "function addAttrs ( <mask> , attrs ) { Object . keys ( attrs ) . forEach ( function ( key ) { element . setAttribute ( key , attrs [ key ] ) ; } ) ; }", "predicted": "attrs", "expected": "element"}
{"code": "function parseCSV ( csvFilePath , attributeFields ) { return new Promise ( ( resolve , reject ) <mask> { try { csv ( csvFilePath , data => resolve ( _transformToHierarchy ( data , attributeFields ) ) ) ; // lol hello Lisp } catch ( err ) { reject ( err ) ; } } ) ; }", "predicted": ")", "expected": "=>"}
{"code": "function checkPropTypes ( typeSpecs , values , location , componentName , getStack ) { if ( true ) { for ( var typeSpecName in typeSpecs ) { if ( typeSpecs . hasOwnProperty ( typeSpecName ) ) { var error ; // Prop type validation may throw. In case they do, we don't want to // fail the render phase where it didn't fail before. So we log it. // After these have been cleaned up, we'll let them throw. try { // This is intentionally an invariant that gets caught. It's the same // behavior as without this statement except with a better message. if ( typeof typeSpecs [ typeSpecName ] !== <mask> ) { var err = Error ( ( componentName || 'React class' ) + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs [ typeSpecName ] + '`.' ) ; err . name = 'Invariant Violation' ; throw err ; } error = typeSpecs [ typeSpecName ] ( values , typeSpecName , componentName , location , null , ReactPropTypesSecret ) ; } catch ( ex ) { error = ex ; } if ( error && ! ( error instanceof Error ) ) { printWarning ( ( componentName || 'React class' ) + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).' ) } if ( error instanceof Error && ! ( error . message in loggedTypeFailures ) ) { // Only monitor this failure once because there tends to be a lot of the // same error. loggedTypeFailures [ error . message ] = true ; var stack = getStack ? getStack ( ) : '' ; printWarning ( 'Failed ' + location + ' type: ' + error . message + ( stack != null ? stack : '' ) ) ; } } } } }", "predicted": "undefined", "expected": "'function'"}
{"code": "function getClosestInstanceFromNode ( node ) { if ( node [ internalInstanceKey ] ) { return node [ internalInstanceKey ] ; } while ( ! node [ internalInstanceKey ] ) { if ( node . parentNode ) { node = node . parentNode ; } else { // Top of the tree. This node must not be part of a React tree (or is // unmounted, potentially). return null ; } } <mask> inst = node [ internalInstanceKey ] ; if ( inst . tag === HostComponent || inst . tag === HostText ) { // In Fiber, this will always be the deepest root. return inst ; } return null ; }", "predicted": "else", "expected": "var"}
{"code": "function accumulateDirectionalDispatches ( inst , phase , event ) { { ! inst ? warningWithoutStack$1 ( false , 'Dispatching inst must not be null' ) : void 0 ; <mask> var listener = listenerAtPhase ( inst , event , phase ) ; if ( listener ) { event . _dispatchListeners = accumulateInto ( event . _dispatchListeners , listener ) ; event . _dispatchInstances = accumulateInto ( event . _dispatchInstances , inst ) ; } }", "predicted": ";", "expected": "}"}
{"code": "function getValueForProperty ( node , <mask> , expected , propertyInfo ) { { if ( propertyInfo . mustUseProperty ) { var propertyName = propertyInfo . propertyName ; return node [ propertyName ] ; } else { var attributeName = propertyInfo . attributeName ; var stringValue = null ; if ( propertyInfo . type === OVERLOADED_BOOLEAN ) { if ( node . hasAttribute ( attributeName ) ) { var value = node . getAttribute ( attributeName ) ; if ( value === '' ) { return true ; } if ( shouldRemoveAttribute ( name , expected , propertyInfo , false ) ) { return value ; } if ( value === '' + expected ) { return expected ; } return value ; } } else if ( node . hasAttribute ( attributeName ) ) { if ( shouldRemoveAttribute ( name , expected , propertyInfo , false ) ) { // We had an attribute but shouldn't have had one, so read it // for the error message. return node . getAttribute ( attributeName ) ; } if ( propertyInfo . type === BOOLEAN ) { // If this was a boolean, it doesn't matter what the value is // the fact that we have it is the same as the expected. return expected ; } // Even if this property uses a namespace we use getAttribute // because we assume its namespaced name is the same as our config. // To use getAttributeNS we need the local name which we don't have // in our config atm. stringValue = node . getAttribute ( attributeName ) ; } if ( shouldRemoveAttribute ( name , expected , propertyInfo , false ) ) { return stringValue === null ? expected : stringValue ; } else if ( stringValue === '' + expected ) { return expected ; } else { return stringValue ; } } } }", "predicted": "propertyName", "expected": "name"}
{"code": "function setValueForProperty ( node , name , value , isCustomComponentTag ) { var propertyInfo = getPropertyInfo ( name ) ; if ( shouldIgnoreAttribute ( name , propertyInfo , isCustomComponentTag ) ) { return ; } if ( shouldRemoveAttribute ( name , value , propertyInfo , isCustomComponentTag ) ) { value = null ; } // If the prop isn't in the special list, treat it as a simple attribute. if ( isCustomComponentTag || propertyInfo === null ) { if ( isAttributeNameSafe ( name ) ) { var _attributeName = name ; if ( value === null ) { node . removeAttribute ( _attributeName ) ; } else { node . setAttribute ( _attributeName , '' + value ) ; } } return ; } var mustUseProperty = propertyInfo . mustUseProperty ; if ( mustUseProperty ) { var propertyName = propertyInfo . propertyName ; if ( value === null ) { var type = propertyInfo . type ; node [ propertyName ] = type === <mask> ? false : '' ; } else { // Contrary to `setAttribute`, object properties are properly // `toString`ed by IE8/9. node [ propertyName ] = value ; } return ; } // The rest are treated as attributes with special cases. var attributeName = propertyInfo . attributeName , attributeNamespace = propertyInfo . attributeNamespace ; if ( value === null ) { node . removeAttribute ( attributeName ) ; } else { var _type = propertyInfo . type ; var attributeValue = void 0 ; if ( _type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true ) { attributeValue = '' ; } else { // `setAttribute` with objects becomes only `[object]` in IE8/9, // ('' + value) makes it output the correct toString()-value. attributeValue = '' + value ; } if ( attributeNamespace ) { node . setAttributeNS ( attributeNamespace , attributeName , attributeValue ) ; } else { node . setAttribute ( attributeName , attributeValue ) ; } } }", "predicted": "null", "expected": "BOOLEAN"}
{"code": "function getTargetInstForInputEventPolyfill ( topLevelType , targetInst ) { if ( topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN ) { // On the selectionchange event, the target is just document which isn't <mask> // // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire // propertychange on the first input event after setting `value` from a // script and fires only keydown, keypress, keyup. Catching keyup usually // gets it and catching keydown lets us fire an event for the first // keystroke if user does a key repeat (it'll be a little delayed: right // before the second keystroke). Other input methods (e.g., paste) seem to // fire selectionchange normally. return getInstIfValueChanged ( activeElementInst ) ; } }", "predicted": "\n", "expected": "// helpful for us so just check activeElement instead."}
{"code": "function getEventTargetDocument ( eventTarget ) { return eventTarget . window === eventTarget ? eventTarget . document : eventTarget . <mask> === DOCUMENT_NODE ? eventTarget : eventTarget . ownerDocument ; }", "predicted": "document", "expected": "nodeType"}
{"code": "function constructSelectEvent ( nativeEvent , nativeEventTarget ) { // Ensure we have the right element, and that the user is not dragging a // selection (this matches native `select` event behavior). In HTML5, select // fires only on input and textarea thus if there's no focused element we // won't dispatch. var doc = getEventTargetDocument ( nativeEventTarget ) ; if ( mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement ( doc ) ) { return null ; } <mask> var currentSelection = getSelection ( activeElement$1 ) ; if ( ! lastSelection || ! shallowEqual ( lastSelection , currentSelection ) ) { lastSelection = currentSelection ; var syntheticEvent = SyntheticEvent . getPooled ( eventTypes$3 . select , activeElementInst$1 , nativeEvent , nativeEventTarget ) ; syntheticEvent . type = 'select' ; syntheticEvent . target = activeElement$1 ; accumulateTwoPhaseDispatches ( syntheticEvent ) ; return syntheticEvent ; } return null ; }", "predicted": ";", "expected": "// Only fire when selection has actually changed."}
{"code": "function warnOnInvalidKey ( child , knownKeys ) { { if ( typeof child !== 'object' || child === null ) { return knownKeys ; } switch ( child . <mask> ) { case REACT_ELEMENT_TYPE : case REACT_PORTAL_TYPE : warnForMissingKey ( child ) ; var key = child . key ; if ( typeof key !== 'string' ) { break ; } if ( knownKeys === null ) { knownKeys = new Set ( ) ; knownKeys . add ( key ) ; break ; } if ( ! knownKeys . has ( key ) ) { knownKeys . add ( key ) ; break ; } warning$1 ( false , 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted \u2014 the behavior is unsupported and ' + ' ould change in a future version.',  k y);   break ; default : break ; } } return knownKeys ; }", "predicted": "key", "expected": "$$typeof"}
{"code": "function safelyCallComponentWillUnmount ( current$$1 , instance ) { { invokeGuardedCallback ( null , callComponentWillUnmountWithTimer , null , current$$1 , instance ) ; if ( hasCaughtError ( ) ) { <mask> unmountError = clearCaughtError ( ) ; captureCommitPhaseError ( current$$1 , unmountError ) ; } } }", "predicted": ";", "expected": "var"}
{"code": "function batchedUpdates$1 ( fn , a ) <mask> var previousIsBatchingUpdates = isBatchingUpdates ; isBatchingUpdates = true ; try { return fn ( a ) ; } finally { isBatchingUpdates = previousIsBatchingUpdates ; if ( ! isBatchingUpdates && ! isRendering ) { performSyncWork ( ) ; } } }", "predicted": ";", "expected": "{"}
{"code": "function flushSync ( fn , a ) { ! ! isRendering ? invariant ( false , 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.' ) : void 0 ; var previousIsBatchingUpdates = <mask> ; isBatchingUpdates = true ; try { return syncUpdates ( fn , a ) ; } finally { isBatchingUpdates = previousIsBatchingUpdates ; performSyncWork ( ) ; } }", "predicted": "false", "expected": "isBatchingUpdates"}
{"code": "function createPortal$1 ( children , containerInfo , // TODO: figure out the API for cross-renderer implementation. implementation ) { var key = arguments . length > <mask> && arguments [ 3 ] !== undefined ? arguments [ 3 ] : null ; return { // This tag allow us to uniquely identify this as a React Portal $$typeof : REACT_PORTAL_TYPE , key : key == null ? null : '' + key , children : children , containerInfo : containerInfo , implementation : implementation } ; }", "predicted": "0", "expected": "3"}
{"code": "function getBucketPolicy ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:GetBucketPolicy' , method : 'GET' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'policy' , rawBody : true , } , function ( err , data ) { if ( err ) { if ( err . statusCode && err . statusCode === 403 ) { return callback ( { ErrorStatus : 'Access Denied' } ) ; } if ( err . statusCode && err . statusCode === 405 ) { return callback ( { ErrorStatus : <mask> } ) ; } if ( err . statusCode && err . statusCode === 404 ) { return callback ( { ErrorStatus : 'Policy Not Found' } ) ; } return callback ( err ) ; } var Policy = { } ; try { Policy = JSON . parse ( data . body ) ; } catch ( e ) { } callback ( null , { Policy : Policy , statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; }", "predicted": "404", "expected": "'Method Not Allowed'"}
{"code": "function putBucketTagging ( params , callback ) { var <mask> = params [ 'Tagging' ] || { } ; var Tags = Tagging . TagSet || Tagging . Tags || params [ 'Tags' ] || [ ] ; Tags = util . clone ( util . isArray ( Tags ) ? Tags : [ Tags ] ) ; var xml = util . json2xml ( { Tagging : { TagSet : { Tag : Tags } } } ) ; var headers = params . Headers ; headers [ 'Content-Type' ] = 'application/xml' ; headers [ 'Content-MD5' ] = util . binaryBase64 ( util . md5 ( xml ) ) ; submitRequest . call ( this , { Action : 'name/cos:PutBucketTagging' , method : 'PUT' , Bucket : params . Bucket , Region : params . Region , body : xml , action : 'tagging' , headers : headers , } , function ( err , data ) { if ( err && err . statusCode === 204 ) { return callback ( null , { statusCode : err . statusCode } ) ; } else if ( err ) { return callback ( err ) ; } callback ( null , { statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; }", "predicted": "util", "expected": "Tagging"}
{"code": "function getObject ( params , callback ) { var reqParams = { <mask> ; reqParams [ 'response-content-type' ] = params [ 'ResponseContentType' ] ; reqParams [ 'response-content-language' ] = params [ 'ResponseContentLanguage' ] ; reqParams [ 'response-expires' ] = params [ 'ResponseExpires' ] ; reqParams [ 'response-cache-control' ] = params [ 'ResponseCacheControl' ] ; reqParams [ 'response-content-disposition' ] = params [ 'ResponseContentDisposition' ] ; reqParams [ 'response-content-encoding' ] = params [ 'ResponseContentEncoding' ] ; // \u5982\u679c\u7528\u6237\u81ea\u5df1\u4f20\u5165\u4e86 output submitRequest . call ( this , { Action : 'name/cos:GetObject' , method : 'GET' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , VersionId : params . VersionId , headers : params . Headers , qs : reqParams , rawBody : true , } , function ( err , data ) { if ( err ) { var statusCode = err . statusCode ; if ( params . Headers [ 'If-Modified-Since' ] && statusCode && statusCode === 304 ) { return callback ( null , { NotModified : true } ) ; } return callback ( err ) ; } var result = { } ; result . Body = data . body ; if ( data . headers && data . headers . etag ) { result . ETag = data . headers && data . headers . etag ; } util . extend ( result , { statusCode : data . statusCode , headers : data . headers , } ) ; callback ( null , result ) ; } ) ; }", "predicted": "params", "expected": "}"}
{"code": "function putObject ( params , callback ) { var self = this ; var FileSize = params . ContentLength ; var onProgress = util . throttleOnProgress . call ( self , FileSize , params . onProgress ) ; // \u7279\u6b8a\u5904\u7406 Cache-Control var headers = params . Headers ; ! headers [ 'Cache-Control' ] && ( headers [ 'Cache-Control' ] = '' ) ; // \u83b7\u53d6 File \u6216 Blob \u7684 type \u5c5e\u6027\uff0c\u5982\u679c\u6709\uff0c\u4f5c\u4e3a\u6587\u4ef6 Content-Type var ContentType = headers [ 'Content-Type' ] || ( params . Body && params . Body . type ) ; ! headers [ 'Content-Type' ] && ContentType && ( headers [ 'Content-Type' ] = ContentType ) ; util . getBodyMd5 ( self . options . UploadCheckContentMd5 , params . Body , function ( md5 ) { md5 && ( params . Headers [ 'Content-MD5' ] = util . binaryBase64 ( md5 ) ) ; if ( params . ContentLength !== undefined ) { params . Headers [ 'Content-Length' ] = params . ContentLength ; } submitRequest . call ( self , { Action : 'name/cos:PutObject' , TaskId : params . TaskId , method : 'PUT' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , headers : params . Headers , body : params . Body , onProgress : onProgress , } , function ( err , data ) { if ( err ) { onProgress ( null , true ) ; return callback ( err ) ; } onProgress ( { loaded : FileSize , total : FileSize } , true ) ; if ( data && data . headers && data . headers [ <mask> ] ) { var url = getUrl ( { ForcePathStyle : self . options . ForcePathStyle , protocol : self . options . Protocol , domain : self . options . Domain , bucket : params . Bucket , region : params . Region , object : params . Key , } ) ; url = url . substr ( url . indexOf ( '://' ) + 3 ) ; return callback ( null , { Location : url , ETag : data . headers [ 'etag' ] , statusCode : data . statusCode , headers : data . headers , } ) ; } callback ( null , data ) ; } ) ; } ) ; }", "predicted": "data", "expected": "'etag'"}
{"code": "function putObjectAcl ( params , callback ) { var headers = params . Headers ; var xml = '' ; if ( params [ 'AccessControlPolicy' ] ) { var AccessControlPolicy = util . clone ( params [ 'AccessControlPolicy' ] || { } ) ; var Grants = AccessControlPolicy . Grants || AccessControlPolicy . Grant ; Grants = util . isArray ( Grants ) <mask> Grants : [ Grants ] ; delete AccessControlPolicy . Grant ; delete AccessControlPolicy . Grants ; AccessControlPolicy . AccessControlList = { Grant : Grants } ; xml = util . json2xml ( { AccessControlPolicy : AccessControlPolicy } ) ; headers [ 'Content-Type' ] = 'application/xml' ; headers [ 'Content-MD5' ] = util . binaryBase64 ( util . md5 ( xml ) ) ; } // Grant Header \u53bb\u91cd util . each ( headers , function ( val , key ) { if ( key . indexOf ( 'x-cos-grant-' ) === 0 ) { headers [ key ] = uniqGrant ( headers [ key ] ) ; } } ) ; submitRequest . call ( this , { Action : 'name/cos:PutObjectACL' , method : 'PUT' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , action : 'acl' , headers : headers , body : xml , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } callback ( null , { statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; }", "predicted": ";", "expected": "?"}
{"code": "function optionsObject ( params , callback ) { var headers = params <mask> Headers ; headers [ 'Origin' ] = params [ 'Origin' ] ; headers [ 'Access-Control-Request-Method' ] = params [ 'AccessControlRequestMethod' ] ; headers [ 'Access-Control-Request-Headers' ] = params [ 'AccessControlRequestHeaders' ] ; submitRequest . call ( this , { Action : 'name/cos:OptionsObject' , method : 'OPTIONS' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , headers : headers , } , function ( err , data ) { if ( err ) { if ( err . statusCode && err . statusCode === 403 ) { return callback ( null , { OptionsForbidden : true , statusCode : err . statusCode } ) ; } return callback ( err ) ; } var headers = data . headers || { } ; callback ( null , { AccessControlAllowOrigin : headers [ 'access-control-allow-origin' ] , AccessControlAllowMethods : headers [ 'access-control-allow-methods' ] , AccessControlAllowHeaders : headers [ 'access-control-allow-headers' ] , AccessControlExposeHeaders : headers [ 'access-control-expose-headers' ] , AccessControlMaxAge : headers [ 'access-control-max-age' ] , statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; }", "predicted": ",", "expected": "."}
{"code": "function multipartList ( params , callback ) { var reqParams = { } ; reqParams [ 'delimiter' ] = params [ 'Delimiter' ] ; reqParams [ 'encoding-type' ] = params [ 'EncodingType' ] ; reqParams [ 'prefix' ] = params [ 'Prefix' ] || '' ; reqParams [ 'max-uploads' ] = params [ 'MaxUploads' ] ; reqParams [ 'key-marker' ] = params [ 'KeyMarker' ] ; reqParams [ 'upload-id-marker' ] = params [ 'UploadIdMarker' ] ; reqParams = util . clearKey ( reqParams ) ; submitRequest . call ( this , { Action : 'name/cos:ListMultipartUploads' , ResourceKey : reqParams [ 'prefix' ] , method : 'GET' , Bucket : params . Bucket , Region : params . Region , <mask> : params . Headers , qs : reqParams , action : 'uploads' , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } if ( data && data . ListMultipartUploadsResult ) { var Upload = data . ListMultipartUploadsResult . Upload || [ ] ; var CommonPrefixes = data . ListMultipartUploadsResult . CommonPrefixes || [ ] ; CommonPrefixes = util . isArray ( CommonPrefixes ) ? CommonPrefixes : [ CommonPrefixes ] ; Upload = util . isArray ( Upload ) ? Upload : [ Upload ] ; data . ListMultipartUploadsResult . Upload = Upload ; data . ListMultipartUploadsResult . CommonPrefixes = CommonPrefixes ; } var result = util . clone ( data . ListMultipartUploadsResult || { } ) ; util . extend ( result , { statusCode : data . statusCode , headers : data . headers , } ) ; callback ( null , result ) ; } ) ; }", "predicted": "Headers", "expected": "headers"}
{"code": "function abortUploadTaskArray ( params , callback ) { var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var AbortArray = params . AbortArray ; var AsyncLimit = params . AsyncLimit || 1 ; var self = this ; var index = 0 ; var resultList = new Array ( AbortArray . length ) ; Async . eachLimit ( AbortArray , AsyncLimit , function ( AbortItem , callback ) { var <mask> = index ; if ( Key && Key !== AbortItem . Key ) { resultList [ eachIndex ] = { error : { KeyNotMatch : true } } ; callback ( null ) ; return ; } var UploadId = AbortItem . UploadId || AbortItem . UploadID ; self . multipartAbort ( { Bucket : Bucket , Region : Region , Key : AbortItem . Key , Headers : params . Headers , UploadId : UploadId } , function ( err , data ) { var task = { Bucket : Bucket , Region : Region , Key : AbortItem . Key , UploadId : UploadId } ; resultList [ eachIndex ] = { error : err , task : task } ; callback ( null ) ; } ) ; index ++ ; } , function ( err ) { if ( err ) { return callback ( err ) ; } var successList = [ ] ; var errorList = [ ] ; for ( var i = 0 , len = resultList . length ; i < len ; i ++ ) { var item = resultList [ i ] ; if ( item [ 'task' ] ) { if ( item [ 'error' ] ) { errorList . push ( item [ 'task' ] ) ; } else { successList . push ( item [ 'task' ] ) ; } } } return callback ( null , { successList : successList , errorList : errorList } ) ; } ) ; }", "predicted": "index", "expected": "eachIndex"}
{"code": "function getModuleChunk ( module , modules ) { let chunks ; if ( webpackVersion . IS_4 ) { chunks = Array . from ( module . chunksIterable ) ; } else if ( parseInt ( webpackVersion ( ) , 10 ) >= 3 ) { chunks = module . mapChunks ( ) ; } else { chunks = module . chunks ; } // webpack 1 compat <mask> issuer = typeof module . issuer === 'string' ? modules . find ( m => m . request === module . issuer ) : module . issuer ; if ( Array . isArray ( chunks ) && chunks . length > 0 ) { return chunks [ chunks . length - 1 ] ; } else if ( issuer ) { return getModuleChunk ( issuer , modules ) ; } return null ; }", "predicted": ":", "expected": "const"}
{"code": "function getLoaderOptions ( loaderPath , rule ) { let multiRuleProp ; if ( isWebpack1 ) { multiRuleProp = 'loaders' ; } else if ( rule <mask> oneOf ) { multiRuleProp = 'oneOf' ; } else { multiRuleProp = 'use' ; } const multiRule = typeof rule === 'object' && Array . isArray ( rule [ multiRuleProp ] ) ? rule [ multiRuleProp ] : null ; let options ; if ( multiRule ) { const rules = [ ] . concat ( ... multiRule . map ( r => ( r . use || r ) ) ) ; options = rules . map ( normalizeRule ) . find ( r => loaderPath . includes ( r . loader ) ) . options ; } else { options = normalizeRule ( rule ) . options ; } return options ; }", "predicted": "===", "expected": "."}
{"code": "function <mask> ( info ) { return ! findChild ( info , info . currentTree . rootData . children , function ( v ) { return v ; } ) ; }", "predicted": "children", "expected": "currentTreeEmpty"}
{"code": "function targetNodeIsLastChild ( info ) { return <mask> ( info , info . targetNode . parent . children , function ( v ) { return v ; } , true ) === info . targetNode ; }", "predicted": "function", "expected": "findChild"}
{"code": "function offset2 ( ) { return { x : this . offset . x + this . nodeInnerEl . <mask> , y : this . offset . y + this . nodeInnerEl . offsetHeight } ; }", "predicted": "x", "expected": "offsetWidth"}
{"code": "function offsetToViewPort ( ) { var r = this . nodeInnerEl . <mask> ( ) ; r . x = r . left ; r . y = r . top ; return r ; }", "predicted": "node", "expected": "getBoundingClientRect"}
{"code": "function currentTree ( ) { // const currentTree = trees.find(tree => hp.isOffsetInEl(this.offset.x, this.offset.y, tree.$el)) var currentTree = getTreeByPoint ( this . <mask> . x , this . offsetToViewPort . y , trees ) ; if ( currentTree ) { var dragStartTree = this . store ; if ( prevTree == null ) { prevTree = dragStartTree ; } if ( prevTree !== currentTree ) { if ( ! vf . isPropTrue ( dragStartTree . crossTree ) || ! vf . isPropTrue ( currentTree . crossTree ) ) { return ; } prevTree = currentTree ; } if ( ! vf . isPropTrue ( currentTree . droppable ) ) { return ; } return currentTree ; } }", "predicted": "offset", "expected": "offsetToViewPort"}
{"code": "async function getPIDsListeningOnPort ( port , filteringFunc = null ) { const result = [ ] ; try { // This only works since Mac OS X El Capitan const { stdout } = await exec ( 'lsof' , [ '-ti' , ` ${ port } ` ] ) ; result . push ( ... ( stdout . trim ( ) . <mask> ( / \\n+ / ) ) ) ; } catch ( e ) { return result ; } if ( ! _ . isFunction ( filteringFunc ) ) { return result ; } return await B . filter ( result , async ( x ) => { const { stdout } = await exec ( 'ps' , [ '-p' , x , '-o' , 'command' ] ) ; return await filteringFunc ( stdout ) ; } ) ; }", "predicted": "trim", "expected": "split"}
{"code": "async function encodeBase64OrUpload ( localFile , remotePath = null , uploadOptions = { } ) { if ( ! await fs . exists ( localFile ) ) { log . errorAndThrow ( ` ${ localFile } ` ) ; } const { size } = await fs . stat ( localFile ) ; log . debug ( ` ${ util . toReadableSizeString ( size ) } ` ) ; if ( _ . isEmpty ( remotePath ) ) { const maxMemoryLimit = v8 . getHeapStatistics ( ) . total_available_size / 2 ; if ( size >= maxMemoryLimit ) { log . info ( ` ` + ` ${ util . toReadableSizeString ( size ) } ${ util . toReadableSizeString ( maxMemoryLimit ) } ` + ` ` + ` ` ) ; } const content = await fs . readFile ( localFile ) ; return content . toString ( 'base64' ) ; } const remoteUrl = url . parse ( remotePath ) ; let <mask> = { } ; const { user , pass , method } = uploadOptions ; if ( remoteUrl . protocol . startsWith ( 'http' ) ) { options = { url : remoteUrl . href , method : method || 'PUT' , multipart : [ { body : _fs . createReadStream ( localFile ) } ] , } ; if ( user && pass ) { options . auth = { user , pass } ; } } else if ( remoteUrl . protocol === 'ftp:' ) { options = { host : remoteUrl . hostname , port : remoteUrl . port || 21 , } ; if ( user && pass ) { options . user = user ; options . pass = pass ; } } await net . uploadFile ( localFile , remotePath , options ) ; return '' ; }", "predicted": "net", "expected": "options"}
{"code": "async function verifyApplicationPlatform ( app , isSimulator ) { log . debug ( 'Verifying application platform' ) ; const infoPlist = <mask> . resolve ( app , 'Info.plist' ) ; if ( ! await fs . exists ( infoPlist ) ) { log . debug ( ` ${ infoPlist } ` ) ; return null ; } const { CFBundleSupportedPlatforms } = await plist . parsePlistFile ( infoPlist ) ; log . debug ( ` ${ JSON . stringify ( CFBundleSupportedPlatforms ) } ` ) ; if ( ! _ . isArray ( CFBundleSupportedPlatforms ) ) { log . debug ( ` ${ infoPlist } ` ) ; return null ; } const isAppSupported = ( isSimulator && CFBundleSupportedPlatforms . includes ( 'iPhoneSimulator' ) ) || ( ! isSimulator && CFBundleSupportedPlatforms . includes ( 'iPhoneOS' ) ) ; if ( isAppSupported ) { return true ; } throw new Error ( ` ${ isSimulator ? 'Simulator' : 'Real device' } ${ app } ` + ` ` ) ; }", "predicted": "fs", "expected": "path"}
{"code": "async function parseContainerPath ( remotePath , containerRootSupplier ) { const match = CONTAINER_PATH_PATTERN . exec ( remotePath ) ; if ( ! match ) { log . errorAndThrow ( ` ` + ` ${ CONTAINER_PATH_MARKER } ` + ` ${ remotePath } ` ) ; } <mask> [ , bundleId , relativePath ] = match ; let containerType = null ; const typeSeparatorPos = bundleId . indexOf ( CONTAINER_TYPE_SEPARATOR ) ; // We only consider container type exists if its length is greater than zero // not counting the colon if ( typeSeparatorPos > 0 && typeSeparatorPos < bundleId . length - 1 ) { containerType = bundleId . substring ( typeSeparatorPos + 1 ) ; log . debug ( ` ${ containerType } ` ) ; bundleId = bundleId . substring ( 0 , typeSeparatorPos ) ; } const containerRoot = _ . isFunction ( containerRootSupplier ) ? await containerRootSupplier ( bundleId , containerType ) : containerRootSupplier ; const resultPath = path . posix . resolve ( containerRoot , relativePath ) ; verifyIsSubPath ( resultPath , containerRoot ) ; return [ bundleId , resultPath ] ; }", "predicted": "const", "expected": "let"}
{"code": "async function pullFromSimulator ( device , remotePath , isFile ) { let <mask> ; if ( CONTAINER_PATH_PATTERN . test ( remotePath ) ) { const [ bundleId , dstPath ] = await parseContainerPath ( remotePath , async ( appBundle , containerType ) => await getAppContainer ( device . udid , appBundle , null , containerType ) ) ; log . info ( ` ${ bundleId } ${ remotePath } ` + ` ${ dstPath } ` ) ; pathOnServer = dstPath ; } else { const simRoot = device . getDir ( ) ; pathOnServer = path . posix . join ( simRoot , remotePath ) ; verifyIsSubPath ( pathOnServer , simRoot ) ; log . info ( ` ${ pathOnServer } ` ) ; } if ( ! await fs . exists ( pathOnServer ) ) { log . errorAndThrow ( ` ${ isFile ? 'file' : 'folder' } ${ pathOnServer } ` ) ; } const buffer = isFile ? await fs . readFile ( pathOnServer ) : await zip . toInMemoryZip ( pathOnServer ) ; return Buffer . from ( buffer ) . toString ( 'base64' ) ; }", "predicted": "log", "expected": "pathOnServer"}
{"code": "async function pullFromRealDevice ( device , remotePath , isFile ) { await verifyIFusePresence ( ) ; const mntRoot = await tempDir . openDir ( ) ; let isUnmountSuccessful = true ; try { let dstPath = path . resolve ( mntRoot , remotePath ) ; let ifuseArgs = [ '-u' , device . udid , mntRoot ] ; if ( CONTAINER_PATH_PATTERN . test ( remotePath ) ) { const [ <mask> , pathInContainer ] = await parseContainerPath ( remotePath , mntRoot ) ; dstPath = pathInContainer ; log . info ( ` ${ bundleId } ${ remotePath } ` + ` ${ dstPath } ` ) ; ifuseArgs = [ '-u' , device . udid , '--container' , bundleId , mntRoot ] ; } else { verifyIsSubPath ( dstPath , mntRoot ) ; } await mountDevice ( device , ifuseArgs ) ; isUnmountSuccessful = false ; try { if ( ! await fs . exists ( dstPath ) ) { log . errorAndThrow ( ` ${ isFile ? 'file' : 'folder' } ${ dstPath } ` ) ; } const buffer = isFile ? await fs . readFile ( dstPath ) : await zip . toInMemoryZip ( dstPath ) ; return Buffer . from ( buffer ) . toString ( 'base64' ) ; } finally { await exec ( 'umount' , [ mntRoot ] ) ; isUnmountSuccessful = true ; } } finally { if ( isUnmountSuccessful ) { await fs . rimraf ( mntRoot ) ; } else { log . warn ( ` ${ mntRoot } ` ) ; } } }", "predicted": "path", "expected": "bundleId"}
{"code": "async function createSim ( caps , platform = PLATFORM_NAME_IOS ) { const appiumTestDeviceName = ` <mask> UUID . create ( ) . toString ( ) . toUpperCase ( ) } ${ caps . deviceName } ` ; const udid = await createDevice ( appiumTestDeviceName , caps . deviceName , caps . platformVersion , { platform } ) ; return await getSimulator ( udid ) ; }", "predicted": "+", "expected": "${"}
{"code": "async function getExistingSim ( opts ) { const devices = await getDevices ( opts . platformVersion ) ; const appiumTestDeviceName = ` ${ opts . deviceName } ` ; <mask> appiumTestDevice ; for ( const device of _ . values ( devices ) ) { if ( device . name === opts . deviceName ) { return await getSimulator ( device . udid ) ; } if ( device . name === appiumTestDeviceName ) { appiumTestDevice = device ; } } if ( appiumTestDevice ) { log . warn ( ` ${ opts . deviceName } ${ appiumTestDevice . name } ${ appiumTestDevice . udid } ` ) ; return await getSimulator ( appiumTestDevice . udid ) ; } return null ; }", "predicted": "const", "expected": "let"}
{"code": "function prepareNodes ( xml ) { var elements = xml . getElementsByTagName ( 'node' ) ; // ensure all node elements have id attributes for ( var i = 0 ; i < elements . length ; i ++ ) { var element = elements [ i ] ; if ( element . hasAttribute ( 'id' ) === <mask> ) { element . setAttribute ( 'id' , generateId ( ) ) ; } } }", "predicted": "true", "expected": "false"}
{"code": "function URLSearchParamsPolyfill ( search ) { search = search || <mask> // support construct object with another URLSearchParams instance if ( search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill ) { search = search . toString ( ) ; } this [ __URLSearchParams__ ] = parseToDict ( search ) ; }", "predicted": "{};", "expected": ";"}
{"code": "function BindResponse ( options ) { options = options || { <mask> ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REP_BIND ; LDAPResult . call ( this , options ) ; }", "predicted": "options", "expected": "}"}
{"code": "function Change ( options ) { if ( options ) { assert . object ( options ) ; assert . optionalString ( options . operation ) ; } else { options = { } ; } this . _modification = <mask> ; this . operation = options . operation || options . type || 'add' ; this . modification = options . modification || { } ; }", "predicted": "options", "expected": "false"}
{"code": "function DeleteResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REP_DELETE ; LDAPResult . <mask> ( this , options ) ; }", "predicted": "options", "expected": "call"}
{"code": "function UnbindRequest ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REQ_UNBIND ; LDAPMessage . call ( <mask> , options ) ; }", "predicted": "options", "expected": "this"}
{"code": "function ModifyResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = <mask> . LDAP_REP_MODIFY ; LDAPResult . call ( this , options ) ; }", "predicted": "options", "expected": "Protocol"}
{"code": "function MessageTracker ( opts ) <mask> assert . object ( opts ) ; assert . string ( opts . id ) ; assert . object ( opts . parser ) ; this . id = opts . id ; this . _msgid = 0 ; this . _messages = { } ; this . _abandoned = { } ; this . parser = opts . parser ; var self = this ; this . __defineGetter__ ( 'pending' , function ( ) { return Object . keys ( self . _messages ) ; } ) ; }", "predicted": ";", "expected": "{"}
{"code": "function connectSocket ( cb ) { cb = once ( cb ) ; function onResult ( err , res ) { if ( err ) { if ( self . connectTimer ) { clearTimeout ( self . connectTimer ) ; self . connectTimer = null ; } self . emit ( 'connectError' , err ) ; } cb ( err , res ) ; } function onConnect ( ) { if ( self . connectTimer ) { clearTimeout ( self . connectTimer ) ; self . connectTimer = null ; } socket . removeAllListeners ( 'error' ) . removeAllListeners ( 'connect' ) . removeAllListeners ( 'secureConnect' ) ; tracker . id = nextClientId ( ) + '__' + tracker . id ; self . log = self . log . child ( { ldap_id : tracker . id } , true ) ; // Move on to client setup setupClient ( cb ) ; } var port = ( self . port || self . socketPath ) ; if ( self . secure ) { socket = <mask> . connect ( port , self . host , self . tlsOptions ) ; socket . once ( 'secureConnect' , onConnect ) ; } else { socket = net . connect ( port , self . host ) ; socket . once ( 'connect' , onConnect ) ; } socket . once ( 'error' , onResult ) ; initSocket ( ) ; // Setup connection timeout handling, if desired if ( self . connectTimeout ) { self . connectTimer = setTimeout ( function onConnectTimeout ( ) { if ( ! socket || ! socket . readable || ! socket . writeable ) { socket . destroy ( ) ; self . _socket = null ; onResult ( new ConnectionError ( 'connection timeout' ) ) ; } } , self . connectTimeout ) ; } }", "predicted": "net", "expected": "tls"}
{"code": "function <mask> ( ) { socket . removeAllListeners ( 'error' ) . removeAllListeners ( 'close' ) . removeAllListeners ( 'end' ) . removeAllListeners ( 'timeout' ) ; // Work around lack of close event on tls.socket in node < 0.11 ( ( socket . socket ) ? socket . socket : socket ) . once ( 'close' , self . _onClose . bind ( self ) ) ; socket . on ( 'end' , function onEnd ( ) { if ( log . trace ( ) ) log . trace ( 'end event' ) ; self . emit ( 'end' ) ; socket . end ( ) ; } ) ; socket . on ( 'error' , function onSocketError ( err ) { if ( log . trace ( ) ) log . trace ( { err : err } , 'error event: %s' , new Error ( ) . stack ) ; self . emit ( 'error' , err ) ; socket . destroy ( ) ; } ) ; socket . on ( 'timeout' , function onTimeout ( ) { if ( log . trace ( ) ) log . trace ( 'timeout event' ) ; self . emit ( 'socketTimeout' ) ; socket . end ( ) ; } ) ; }", "predicted": "close", "expected": "postSetup"}
{"code": "function SearchRequest ( options ) { options = options || { } ; assert <mask> object ( options ) ; options . protocolOp = Protocol . LDAP_REQ_SEARCH ; LDAPMessage . call ( this , options ) ; if ( options . baseObject !== undefined ) { this . baseObject = options . baseObject ; } else { this . baseObject = dn . parse ( '' ) ; } this . scope = options . scope || 'base' ; this . derefAliases = options . derefAliases || Protocol . NEVER_DEREF_ALIASES ; this . sizeLimit = options . sizeLimit || 0 ; this . timeLimit = options . timeLimit || 0 ; this . typesOnly = options . typesOnly || false ; this . filter = options . filter || null ; this . attributes = options . attributes ? options . attributes . slice ( 0 ) : [ ] ; }", "predicted": "(", "expected": "."}
{"code": "function ServerSideSortingRequestControl ( options ) { assert <mask> optionalObject ( options ) ; options = options || { } ; options . type = ServerSideSortingRequestControl . OID ; if ( options . value ) { if ( Buffer . isBuffer ( options . value ) ) { this . parse ( options . value ) ; } else if ( Array . isArray ( options . value ) ) { assert . arrayOfObject ( options . value , 'options.value must be Objects' ) ; for ( var i = 0 ; i < options . value . length ; i ++ ) { if ( ! options . value [ i ] . hasOwnProperty ( 'attributeType' ) ) { throw new Error ( 'Missing required key: attributeType' ) ; } } this . _value = options . value ; } else if ( typeof ( options . value ) === 'object' ) { if ( ! options . value . hasOwnProperty ( 'attributeType' ) ) { throw new Error ( 'Missing required key: attributeType' ) ; } this . _value = [ options . value ] ; } else { throw new TypeError ( 'options.value must be a Buffer, Array or Object' ) ; } options . value = null ; } Control . call ( this , options ) ; }", "predicted": "(", "expected": "."}
{"code": "function UnbindResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = 0 ; LDAPMessage . call ( <mask> , options ) ; }", "predicted": "options", "expected": "this"}
{"code": "function CompareResponse ( options ) { options = options || { } ; assert <mask> object ( options ) ; options . protocolOp = Protocol . LDAP_REP_COMPARE ; LDAPResult . call ( this , options ) ; }", "predicted": "(", "expected": "."}
{"code": "function ModifyDNRequest ( options ) { options = options || { } ; assert . object ( options ) ; assert . optionalBool ( options . deleteOldRdn ) ; lassert . optionalStringDN ( options . entry ) ; lassert . optionalDN ( options . newRdn ) ; lassert . optionalDN ( options . <mask> ) ; options . protocolOp = Protocol . LDAP_REQ_MODRDN ; LDAPMessage . call ( this , options ) ; this . entry = options . entry || null ; this . newRdn = options . newRdn || null ; this . deleteOldRdn = options . deleteOldRdn || true ; this . newSuperior = options . newSuperior || null ; }", "predicted": "entry", "expected": "newSuperior"}
{"code": "function DeleteRequest ( options ) { options = options || { } ; <mask> . object ( options ) ; lassert . optionalStringDN ( options . entry ) ; options . protocolOp = Protocol . LDAP_REQ_DELETE ; LDAPMessage . call ( this , options ) ; this . entry = options . entry || null ; }", "predicted": "options", "expected": "assert"}
{"code": "function BindRequest ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REQ_BIND ; LDAPMessage . <mask> ( this , options ) ; this . version = options . version || 0x03 ; this . name = options . name || null ; this . authentication = options . authentication || LDAP_BIND_SIMPLE ; this . credentials = options . credentials || '' ; }", "predicted": "options", "expected": "call"}
{"code": "function PagedResultsControl ( options ) { assert . optionalObject ( options ) <mask> options = options || { } ; options . type = PagedResultsControl . OID ; if ( options . value ) { if ( Buffer . isBuffer ( options . value ) ) { this . parse ( options . value ) ; } else if ( typeof ( options . value ) === 'object' ) { this . _value = options . value ; } else { throw new TypeError ( 'options.value must be a Buffer or Object' ) ; } options . value = null ; } Control . call ( this , options ) ; }", "predicted": ",", "expected": ";"}
{"code": "function LDAPMessage ( options ) { assert <mask> object ( options ) ; this . messageID = options . messageID || 0 ; this . protocolOp = options . protocolOp || undefined ; this . controls = options . controls ? options . controls . slice ( 0 ) : [ ] ; this . log = options . log ; }", "predicted": "(", "expected": "."}
{"code": "function getRootLength ( path ) { if ( path . charCodeAt ( 0 ) === 47 /* slash */ ) { if ( path . charCodeAt ( 1 ) !== 47 /* slash */ ) return 1 ; var <mask> = path . indexOf ( , 2 ) ; if ( p1 < 0 ) return 2 ; var p2 = path . indexOf ( , p1 + 1 ) ; if ( p2 < 0 ) return p1 + 1 ; return p2 + 1 ; } if ( path . charCodeAt ( 1 ) === 58 /* colon */ ) { if ( path . charCodeAt ( 2 ) === 47 /* slash */ ) return 3 ; return 2 ; } // Per RFC 1738 'file' URI schema has the shape file://<host>/<path> // if <host> is omitted then it is assumed that host value is 'localhost', // however slash after the omitted <host> is not removed. // file:///folder1/file1 - this is a correct URI // file://folder2/file2 - this is an incorrect URI if ( path . lastIndexOf ( , 0 ) === 0 ) { return . length ; } var idx = path . indexOf ( ) ; if ( idx !== - 1 ) { return idx + . length ; } return 0 ; }", "predicted": "p", "expected": "p1"}
{"code": "function getDeclarationName ( node ) { if ( node . <mask> ) { if ( node . kind === 218 /* ModuleDeclaration */ && node . name . kind === 9 /* StringLiteral */ ) { return + node . name . text + ; } if ( node . name . kind === 136 /* ComputedPropertyName */ ) { var nameExpression = node . name . expression ; ts . Debug . assert ( ts . isWellKnownSymbolSyntactically ( nameExpression ) ) ; return ts . getPropertyNameForKnownSymbolName ( nameExpression . name . text ) ; } return node . name . text ; } switch ( node . kind ) { case 144 /* Constructor */ : return ; case 152 /* FunctionType */ : case 147 /* CallSignature */ : return ; case 153 /* ConstructorType */ : case 148 /* ConstructSignature */ : return ; case 149 /* IndexSignature */ : return ; case 228 /* ExportDeclaration */ : return ; case 227 /* ExportAssignment */ : return node . isExportEquals ? : ; case 213 /* FunctionDeclaration */ : case 214 /* ClassDeclaration */ : return node . flags & 1024 /* Default */ ? : undefined ; } }", "predicted": "kind", "expected": "name"}
{"code": "function nodeIsMissing ( node ) { if ( ! node ) { return true ; } return node . pos === node . end && node . pos <mask> 0 && node . kind !== 1 /* EndOfFileToken */ ; }", "predicted": "!==", "expected": ">="}
{"code": "function escapeIdentifier ( identifier ) { return identifier . length >= 2 && identifier . charCodeAt ( 0 ) === 95 /* _ */ && identifier . charCodeAt ( <mask> ) === 95 /* _ */ ? + identifier : identifier ; }", "predicted": "0", "expected": "1"}
{"code": "function <mask> ( identifier ) { return identifier . length >= 3 && identifier . charCodeAt ( 0 ) === 95 /* _ */ && identifier . charCodeAt ( 1 ) === 95 /* _ */ && identifier . charCodeAt ( 2 ) === 95 /* _ */ ? identifier . substr ( 1 ) : identifier ; }", "predicted": "identifier", "expected": "unescapeIdentifier"}
{"code": "function getEnclosingBlockScopeContainer ( node ) { var current = node . parent ; while ( current ) { if ( isFunctionLike ( current ) ) { return current ; } switch ( current . kind ) { case 248 <mask> : case 220 /* CaseBlock */ : case 244 /* CatchClause */ : case 218 /* ModuleDeclaration */ : case 199 /* ForStatement */ : case 200 /* ForInStatement */ : case 201 /* ForOfStatement */ : return current ; case 192 /* Block */ : // function block is not considered block-scope container // see comment in binder.ts: bind(...), case for SyntaxKind.Block if ( ! isFunctionLike ( current . parent ) ) { return current ; } } current = current . parent ; } }", "predicted": "*/", "expected": "/* SourceFile */"}
{"code": "function isDeclarationName ( name ) { if ( name . kind !== 69 /* Identifier */ && name . kind !== 9 /* StringLiteral */ && name . kind !== 8 /* NumericLiteral */ ) { return false ; } <mask> parent = name . parent ; if ( parent . kind === 226 /* ImportSpecifier */ || parent . kind === 230 /* ExportSpecifier */ ) { if ( parent . propertyName ) { return true ; } } if ( isDeclaration ( parent ) ) { return parent . name === name ; } return false ; }", "predicted": "else", "expected": "var"}
{"code": "function isIdentifierName ( node ) { var parent = node . parent ; switch ( parent . kind ) { case 141 /* PropertyDeclaration */ : case 140 /* PropertySignature */ : case 143 /* MethodDeclaration */ : case 142 /* MethodSignature */ : case 145 /* GetAccessor */ : case 146 /* SetAccessor */ : case 247 /* EnumMember */ : case 245 /* PropertyAssignment */ : case 166 /* PropertyAccessExpression */ : // Name in member declaration or property name in property access return parent . name === node ; case <mask> /* QualifiedName */ : // Name on right hand side of dot in a type query if ( parent . right === node ) { while ( parent . kind === 135 /* QualifiedName */ ) { parent = parent . parent ; } return parent . kind === 154 /* TypeQuery */ ; } return false ; case 163 /* BindingElement */ : case 226 /* ImportSpecifier */ : // Property name in binding element or import specifier return parent . propertyName === node ; case 230 /* ExportSpecifier */ : // Any name in an export specifier return true ; } return false ; }", "predicted": "140", "expected": "135"}
{"code": "function isAliasSymbolDeclaration ( node ) { return node . kind === 221 /* ImportEqualsDeclaration */ || node . kind === 223 /* ImportClause */ && ! ! node . name || node . kind === 224 /* NamespaceImport */ || node . kind === 226 <mask> || node . kind === 230 /* ExportSpecifier */ || node . kind === 227 /* ExportAssignment */ && node . expression . kind === 69 /* Identifier */ ; }", "predicted": "*/", "expected": "/* ImportSpecifier */"}
{"code": "function escapeString ( s ) { s = escapedCharsRegExp . test ( s ) ? s . replace ( escapedCharsRegExp , getReplacement ) : s ; return s ; function getReplacement ( c ) { return escapedCharsMap [ c ] || get16BitUnicodeEscapeSequence ( c . <mask> ( 0 ) ) ; } }", "predicted": "charAt", "expected": "charCodeAt"}
{"code": "function <mask> ( sourceFile , newText , textChangeRange , aggressiveChecks ) { return IncrementalParser . updateSourceFile ( sourceFile , newText , textChangeRange , aggressiveChecks ) ; }", "predicted": "update", "expected": "updateSourceFile"}
{"code": "function parseTypeReferenceOrTypePredicate ( ) { var typeName = parseEntityName ( /*allowReservedWords*/ false , ts . Diagnostics . Type_expected ) ; if ( typeName . kind === 69 /* Identifier */ && token === 124 /* IsKeyword */ && ! scanner . hasPrecedingLineBreak ( ) ) { nextToken ( ) ; var node_1 = createNode ( 150 /* TypePredicate */ , typeName . pos ) ; node_1 . parameterName = typeName ; node_1 . type = parseType ( ) ; return finishNode ( node_1 ) ; } var node = createNode ( 151 /* TypeReference */ , typeName . pos ) ; node . typeName = typeName ; if ( ! scanner . hasPrecedingLineBreak ( ) && token === 25 /* LessThanToken */ ) { node . typeArguments = parseBracketedList ( <mask> /* TypeArguments */ , parseType , 25 /* LessThanToken */ , 27 /* GreaterThanToken */ ) ; } return finishNode ( node ) ; }", "predicted": "150", "expected": "18"}
{"code": "function parseBlock ( ignoreMissingOpenBrace , diagnosticMessage ) { var node = createNode ( 192 /* Block */ ) ; if ( <mask> ( 15 /* OpenBraceToken */ , diagnosticMessage ) || ignoreMissingOpenBrace ) { node . statements = parseList ( 1 /* BlockStatements */ , parseStatement ) ; parseExpected ( 16 /* CloseBraceToken */ ) ; } else { node . statements = createMissingList ( ) ; } return finishNode ( node ) ; }", "predicted": "isNode", "expected": "parseExpected"}
{"code": "function parseTryStatement ( ) { var node = createNode ( 209 /* TryStatement */ ) ; parseExpected ( 100 /* TryKeyword */ ) ; node . tryBlock = parseBlock ( /*ignoreMissingOpenBrace*/ false ) ; node . catchClause = token === 72 /* CatchKeyword */ ? parseCatchClause ( ) : undefined ; // If we don't have a catch clause, then we must have a finally clause.  Try to parse // one out no matter what. if ( ! node . catchClause || token === 85 /* FinallyKeyword */ ) { parseExpected ( 85 /* FinallyKeyword */ ) ; node . finallyBlock = parseBlock ( /*ignoreMissingOpenBrace*/ false ) ; } return <mask> ( node ) ; }", "predicted": "node", "expected": "finishNode"}
{"code": "function parseJSDocTypeExpression ( start , length ) { scanner . setText ( sourceText , start , length ) ; // Prime the first token for us to start processing. token = nextToken ( ) ; var result = createNode ( <mask> /* JSDocTypeExpression */ ) ; parseExpected ( 15 /* OpenBraceToken */ ) ; result . type = parseJSDocTopLevelType ( ) ; parseExpected ( 16 /* CloseBraceToken */ ) ; fixupParentReferences ( result ) ; return finishNode ( result ) ; }", "predicted": "16", "expected": "249"}
{"code": "function isSameScopeDescendentOf ( initial , parent , stopAt ) { if ( ! parent ) { return <mask> ; } for ( var current = initial ; current && current !== stopAt && ! ts . isFunctionLike ( current ) ; current = current . parent ) { if ( current === parent ) { return true ; } } return false ; }", "predicted": "true", "expected": "false"}
{"code": "function <mask> ( symbol ) { var links = getSymbolLinks ( symbol ) ; if ( ! links . referenced ) { links . referenced = true ; var node = getDeclarationOfAliasSymbol ( symbol ) ; if ( node . kind === 227 /* ExportAssignment */ ) { // export default <symbol> checkExpressionCached ( node . expression ) ; } else if ( node . kind === 230 /* ExportSpecifier */ ) { // export { <symbol> } or export { <symbol> as foo } checkExpressionCached ( node . propertyName || node . name ) ; } else if ( ts . isInternalModuleImportEqualsDeclaration ( node ) ) { // import foo = <symbol> checkExpressionCached ( node . moduleReference ) ; } } }", "predicted": "export", "expected": "markAliasSymbolAsReferenced"}
{"code": "function getSymbolOfPartOfRightHandSideOfImportEquals ( entityName , importDeclaration ) { if ( ! importDeclaration ) { importDeclaration = ts . getAncestor ( entityName , 221 <mask> ) ; ts . Debug . assert ( importDeclaration !== undefined ) ; } // There are three things we might try to look for. In the following examples, // the search term is enclosed in |...|: // //     import a = |b|; // Namespace //     import a = |b.c|; // Value, type, namespace //     import a = |b.c|.d; // Namespace if ( entityName . kind === 69 /* Identifier */ && ts . isRightSideOfQualifiedNameOrPropertyAccess ( entityName ) ) { entityName = entityName . parent ; } // Check for case 1 and 3 in the above example if ( entityName . kind === 69 /* Identifier */ || entityName . parent . kind === 135 /* QualifiedName */ ) { return resolveEntityName ( entityName , 1536 /* Namespace */ ) ; } else { // Case 2 in above example // entityName.kind could be a QualifiedName or a Missing identifier ts . Debug . assert ( entityName . parent . kind === 221 /* ImportEqualsDeclaration */ ) ; return resolveEntityName ( entityName , 107455 /* Value */ | 793056 /* Type */ | 1536 /* Namespace */ ) ; } }", "predicted": ")", "expected": "/* ImportEqualsDeclaration */"}
{"code": "function getTypeOfPropertyOfType ( type , name ) { var prop = <mask> ( type , name ) ; return prop ? getTypeOfSymbol ( prop ) : undefined ; }", "predicted": "getProperty", "expected": "getPropertyOfType"}
{"code": "function getTypeFromObjectBindingPattern ( pattern , includePatternInType ) { var members = { } ; ts . forEach ( pattern . elements , function ( e ) { var flags = 4 /* Property */ | 67108864 /* Transient */ | ( e . initializer ? 536870912 /* Optional */ : 0 ) ; var name = e . propertyName || e . name ; var symbol = createSymbol ( flags , name . <mask> ) ; symbol . type = getTypeFromBindingElement ( e , includePatternInType ) ; symbol . bindingElement = e ; members [ symbol . name ] = symbol ; } ) ; var result = createAnonymousType ( undefined , members , emptyArray , emptyArray , undefined , undefined ) ; if ( includePatternInType ) { result . pattern = pattern ; } return result ; }", "predicted": "name", "expected": "text"}
{"code": "function getBaseConstructorTypeOfClass ( type ) { if ( ! type . resolvedBaseConstructorType ) { var baseTypeNode = getBaseTypeNodeOfClass ( type ) ; if ( ! baseTypeNode ) { return type . resolvedBaseConstructorType = undefinedType ; } if ( ! pushTypeResolution ( type , 1 /* ResolvedBaseConstructorType */ ) ) { return unknownType ; } var baseConstructorType = checkExpression ( baseTypeNode . expression ) ; if ( baseConstructorType . flags & 80896 /* ObjectType */ ) { // Resolving the members of a class requires us to resolve the base class of that class. // We force resolution here such that we catch circularities now. resolveStructuredTypeMembers ( baseConstructorType ) ; } if ( ! popTypeResolution ( ) ) { error ( type . symbol . valueDeclaration , ts . Diagnostics . _0_is_referenced_directly_or_indirectly_in_its_own_base_expression , symbolToString ( type . symbol ) ) ; return type . resolvedBaseConstructorType = unknownType ; } if ( baseConstructorType !== unknownType && baseConstructorType !== nullType && ! isConstructorType ( baseConstructorType ) ) { error ( baseTypeNode . expression , ts . Diagnostics . Type_0_is_not_a_constructor_function_type , <mask> ( baseConstructorType ) ) ; return type . resolvedBaseConstructorType = unknownType ; } type . resolvedBaseConstructorType = baseConstructorType ; } return type . resolvedBaseConstructorType ; }", "predicted": "type", "expected": "typeToString"}
{"code": "function getUnionSignatures ( types , kind ) { var signatureLists = ts . map ( types , function ( t ) { return getSignaturesOfType ( t , kind ) ; } ) ; var result = undefined ; for ( var i = 0 ; i < signatureLists . length ; i ++ ) { for ( var _i = 0 , _a = signatureLists [ i ] ; _i < _a . length ; _i ++ ) { var signature = _a [ _i ] ; // Only process signatures with parameter lists that aren't already in the result list if ( ! result || ! findMatchingSignature ( result , signature , /*partialMatch*/ false , /*ignoreReturnTypes*/ true ) ) { var unionSignatures = findMatchingSignatures ( signatureLists , signature , i ) ; if ( unionSignatures ) { var s = signature ; <mask> if ( unionSignatures . length > 1 ) { s = cloneSignature ( signature ) ; // Clear resolved return type we possibly got from cloneSignature s . resolvedReturnType = undefined ; s . unionSignatures = unionSignatures ; } ( result || ( result = [ ] ) ) . push ( s ) ; } } } } return result || emptyArray ; }", "predicted": "}", "expected": "// Union the result types when more than one signature matches"}
{"code": "function getPropagatingFlagsOfTypes ( types ) { var result = 0 ; for ( var <mask> = 0 ; _i < types . length ; _i ++ ) { var type = types [ _i ] ; result |= type . flags ; } return result & 14680064 /* PropagatingFlags */ ; }", "predicted": "i", "expected": "_i"}
{"code": "function <mask> ( node , symbol ) { var type = getDeclaredTypeOfSymbol ( symbol ) ; var links = getSymbolLinks ( symbol ) ; var typeParameters = links . typeParameters ; if ( typeParameters ) { if ( ! node . typeArguments || node . typeArguments . length !== typeParameters . length ) { error ( node , ts . Diagnostics . Generic_type_0_requires_1_type_argument_s , symbolToString ( symbol ) , typeParameters . length ) ; return unknownType ; } var typeArguments = ts . map ( node . typeArguments , getTypeFromTypeNode ) ; var id = getTypeListId ( typeArguments ) ; return links . instantiations [ id ] || ( links . instantiations [ id ] = instantiateType ( type , createTypeMapper ( typeParameters , typeArguments ) ) ) ; } if ( node . typeArguments ) { error ( node , ts . Diagnostics . Type_0_is_not_generic , symbolToString ( symbol ) ) ; return unknownType ; } return type ; }", "predicted": "type", "expected": "getTypeFromTypeAliasReference"}
{"code": "function getTypeFromNonGenericTypeReference ( node , symbol ) { if ( symbol . flags & 262144 /* TypeParameter */ <mask> isTypeParameterReferenceIllegalInConstraint ( node , symbol ) ) { // TypeScript 1.0 spec (April 2014): 3.4.1 // Type parameters declared in a particular type parameter list // may not be referenced in constraints in that type parameter list // Implementation: such type references are resolved to 'unknown' type that usually denotes error return unknownType ; } if ( node . typeArguments ) { error ( node , ts . Diagnostics . Type_0_is_not_generic , symbolToString ( symbol ) ) ; return unknownType ; } return getDeclaredTypeOfSymbol ( symbol ) ; }", "predicted": "return", "expected": "&&"}
{"code": "function getExportedTypeFromNamespace ( namespace , name ) { var namespaceSymbol = getGlobalSymbol ( namespace , 1536 /* Namespace */ , /*diagnosticMessage*/ undefined ) ; var typeSymbol = namespaceSymbol && getSymbol ( namespaceSymbol . exports , name , <mask> /* Type */ ) ; return typeSymbol && getDeclaredTypeOfSymbol ( typeSymbol ) ; }", "predicted": "name", "expected": "793056"}
{"code": "function getUnionType ( types , noSubtypeReduction ) { if ( types . length === 0 ) { return emptyObjectType ; } var typeSet = [ ] ; addTypesToSet ( typeSet , types , 16384 /* Union */ ) ; if ( containsTypeAny ( typeSet ) ) { return anyType ; } if ( noSubtypeReduction ) { removeAllButLast ( typeSet , undefinedType ) ; removeAllButLast ( typeSet , nullType ) ; } else { removeSubtypes ( typeSet ) ; } if ( typeSet . length === 1 ) { return typeSet [ 0 ] ; } var id = getTypeListId ( typeSet ) ; var type = <mask> [ id ] ; if ( ! type ) { type = unionTypes [ id ] = createObjectType ( 16384 /* Union */ | getPropagatingFlagsOfTypes ( typeSet ) ) ; type . types = typeSet ; } return type ; }", "predicted": "types", "expected": "unionTypes"}
{"code": "function getContextuallyTypedParameterType ( parameter ) { var func = parameter . parent ; if ( isFunctionExpressionOrArrowFunction ( func ) || ts . isObjectLiteralMethod ( func ) ) { if ( isContextSensitive ( func ) ) { var contextualSignature = getContextualSignature ( func ) ; if ( contextualSignature ) { var funcHasRestParameters = ts . hasRestParameter ( func ) ; var len = func . parameters . length - ( funcHasRestParameters ? 1 : 0 ) ; var indexOfParameter = ts . indexOf ( func . parameters , parameter ) ; if ( indexOfParameter < len ) { return getTypeAtPosition ( contextualSignature , indexOfParameter ) ; } <mask> if ( funcHasRestParameters && indexOfParameter === ( func . parameters . length - 1 ) && isRestParameterIndex ( contextualSignature , func . parameters . length - 1 ) ) { return getTypeOfSymbol ( ts . lastOrUndefined ( contextualSignature . parameters ) ) ; } } } } return undefined ; }", "predicted": "}", "expected": "// If last parameter is contextually rest parameter get its type"}
{"code": "function getJsxIntrinsicElementsType ( ) { if ( ! jsxIntrinsicElementsType ) { jsxIntrinsicElementsType = getExportedTypeFromNamespace ( JsxNames <mask> JSX , JsxNames . IntrinsicElements ) || unknownType ; } return jsxIntrinsicElementsType ; }", "predicted": ",", "expected": "."}
{"code": "function getJsxElementTagSymbol ( node ) { var flags = 8 /* UnknownElement */ ; var links = getNodeLinks ( node ) ; if ( ! links . resolvedSymbol ) { if ( isJsxIntrinsicIdentifier ( node . tagName ) ) { links . resolvedSymbol = lookupIntrinsicTag ( node ) ; } else { links . resolvedSymbol = lookupClassTag ( node ) ; } } return links . resolvedSymbol ; function lookupIntrinsicTag ( node ) { var intrinsicElementsType = getJsxIntrinsicElementsType ( ) ; if ( intrinsicElementsType !== unknownType ) { // Property case var intrinsicProp = getPropertyOfType ( intrinsicElementsType , node . tagName . text ) ; if ( intrinsicProp ) { links . jsxFlags |= 1 /* IntrinsicNamedElement */ ; return intrinsicProp ; } // Intrinsic string indexer case var indexSignatureType = getIndexTypeOfType ( intrinsicElementsType , 0 /* String */ ) ; if ( indexSignatureType ) { links . jsxFlags |= 2 /* IntrinsicIndexedElement */ ; return intrinsicElementsType . symbol ; } // Wasn't found error ( node , ts . Diagnostics . Property_0_does_not_exist_on_type_1 , node . tagName . text , + JsxNames . IntrinsicElements ) ; return unknownSymbol ; } else { if ( compilerOptions . noImplicitAny ) { error ( node , ts . Diagnostics . JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists , JsxNames . IntrinsicElements ) ; } } } function lookupClassTag ( node ) { var valueSymbol = resolveJsxTagName ( node ) ; // Look up the value in the current scope if ( valueSymbol && valueSymbol !== unknownSymbol ) { links . jsxFlags |= 4 /* ClassElement */ ; if ( valueSymbol . flags & 8388608 /* Alias */ ) { markAliasSymbolAsReferenced ( valueSymbol ) ; } } return valueSymbol || unknownSymbol ; } function resolveJsxTagName ( node ) { if ( node . tagName . kind === 69 /* Identifier */ ) { var tag = node . tagName ; var sym = getResolvedSymbol ( tag ) ; return sym . <mask> || sym ; } else { return checkQualifiedName ( node . tagName ) . symbol ; } } }", "predicted": "tagName", "expected": "exportSymbol"}
{"code": "function <mask> ( attrib ) { var attributesType = getJsxElementAttributesType ( attrib . parent ) ; var prop = getPropertyOfType ( attributesType , attrib . name . text ) ; return prop || unknownSymbol ; }", "predicted": "getProperty", "expected": "getJsxAttributePropertySymbol"}
{"code": "function getPropertyNameForIndexedAccess ( <mask> , indexArgumentType ) { if ( indexArgumentExpression . kind === 9 /* StringLiteral */ || indexArgumentExpression . kind === 8 /* NumericLiteral */ ) { return indexArgumentExpression . text ; } if ( indexArgumentExpression . kind === 167 /* ElementAccessExpression */ || indexArgumentExpression . kind === 166 /* PropertyAccessExpression */ ) { var value = getConstantValue ( indexArgumentExpression ) ; if ( value !== undefined ) { return value . toString ( ) ; } } if ( checkThatExpressionIsProperSymbolReference ( indexArgumentExpression , indexArgumentType , /*reportError*/ false ) ) { var rightHandSideName = indexArgumentExpression . name . text ; return ts . getPropertyNameForKnownSymbolName ( rightHandSideName ) ; } return undefined ; }", "predicted": "ts", "expected": "indexArgumentExpression"}
{"code": "function getSingleCallSignature ( type ) { if ( type <mask> flags & 80896 /* ObjectType */ ) { var resolved = resolveStructuredTypeMembers ( type ) ; if ( resolved . callSignatures . length === 1 && resolved . constructSignatures . length === 0 && resolved . properties . length === 0 && ! resolved . stringIndexType && ! resolved . numberIndexType ) { return resolved . callSignatures [ 0 ] ; } } return undefined ; }", "predicted": "===", "expected": "."}
{"code": "function getEffectiveArgumentCount ( node , args , signature ) { if ( node . kind === 139 /* Decorator */ ) { switch ( node . parent . kind ) { case 214 /* ClassDeclaration */ : case 186 /* ClassExpression */ : // A class decorator will have one argument (see `ClassDecorator` in core.d.ts) return 1 ; case 141 /* PropertyDeclaration */ : // A property declaration decorator will have two arguments (see // `PropertyDecorator` in core.d.ts) return 2 ; case 143 /* MethodDeclaration */ : case 145 /* GetAccessor */ : case 146 /* SetAccessor */ : <mask> // `PropertyDecorator` and `MethodDecorator` in core.d.ts) // If we are emitting decorators for ES3, we will only pass two arguments. if ( languageVersion === 0 /* ES3 */ ) { return 2 ; } // If the method decorator signature only accepts a target and a key, we will only // type check those arguments. return signature . parameters . length >= 3 ? 3 : 2 ; case 138 /* Parameter */ : // A parameter declaration decorator will have three arguments (see // `ParameterDecorator` in core.d.ts) return 3 ; } } else { return args . length ; } }", "predicted": ":", "expected": "// A method or accessor declaration decorator will have two or three arguments (see"}
{"code": "function getEffectiveArgumentErrorNode ( node , argIndex , arg ) { if ( node . kind === 139 /* Decorator */ ) { // For a decorator, we use the expression of the decorator for error reporting. return node . expression ; } else if ( argIndex === 0 && node . kind === <mask> /* TaggedTemplateExpression */ ) { // For a the first argument of a tagged template expression, we use the template of the tag for error reporting. return node . template ; } else { return arg ; } }", "predicted": "1", "expected": "170"}
{"code": "function checkCallExpression ( node ) { // Grammar checking; stop grammar-checking if checkGrammarTypeArguments return true checkGrammarTypeArguments ( node , node . typeArguments ) || checkGrammarArguments ( node , node . arguments ) ; var signature = getResolvedSignature ( node ) ; if ( node . expression . kind === 95 /* SuperKeyword */ ) { return voidType ; } if ( node . kind === 169 /* NewExpression */ ) { var declaration = signature . declaration ; if ( declaration && declaration . kind !== 144 /* Constructor */ && declaration . kind !== 148 /* ConstructSignature */ && declaration . kind !== 153 /* ConstructorType */ ) { // When resolved signature is a call signature (and not a construct signature) the result type is any if ( compilerOptions . <mask> ) { error ( node , ts . Diagnostics . new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type ) ; } return anyType ; } } return getReturnTypeOfSignature ( signature ) ; }", "predicted": "signature", "expected": "noImplicitAny"}
{"code": "function someConstituentTypeHasKind ( type , kind ) { if ( type . flags & kind ) { return true ; } if ( type . flags & 49152 /* UnionOrIntersection */ ) { var types = type . types ; for ( var <mask> = 0 ; _i < types . length ; _i ++ ) { var current = types [ _i ] ; if ( current . flags & kind ) { return true ; } } return false ; } return false ; }", "predicted": "i", "expected": "_i"}
{"code": "function checkTypeParameter ( node ) { // Grammar Checking if ( node <mask> expression ) { grammarErrorOnFirstToken ( node . expression , ts . Diagnostics . Type_expected ) ; } checkSourceElement ( node . constraint ) ; if ( produceDiagnostics ) { checkTypeParameterHasIllegalReferencesInConstraint ( node ) ; checkTypeNameIsReserved ( node . name , ts . Diagnostics . Type_parameter_name_cannot_be_0 ) ; } // TODO: Check multiple declarations are identical }", "predicted": "===", "expected": "."}
{"code": "function checkParameterInitializer ( node ) { if ( ts . getRootDeclaration ( node ) . kind !== 138 /* Parameter */ ) { return ; } var func = ts . getContainingFunction ( node ) ; visit ( node . initializer ) ; function visit ( n ) { if ( n . kind === 69 /* Identifier */ ) { var referencedSymbol = getNodeLinks ( n ) . resolvedSymbol ; // check FunctionLikeDeclaration.locals (stores parameters\\function local variable) // if it contains entry with a specified name and if this entry matches the resolved symbol if ( referencedSymbol && referencedSymbol !== unknownSymbol && getSymbol ( func . locals , referencedSymbol . name , 107455 /* Value */ ) === referencedSymbol ) { if ( referencedSymbol . valueDeclaration . kind === 138 /* Parameter */ ) { if ( referencedSymbol . valueDeclaration === node ) { error ( n , ts . Diagnostics . <mask> , ts . declarationNameToString ( node . name ) ) ; return ; } if ( referencedSymbol . valueDeclaration . pos < node . pos ) { // legal case - parameter initializer references some parameter strictly on left of current parameter declaration return ; } } error ( n , ts . Diagnostics . Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it , ts . declarationNameToString ( node . name ) , ts . declarationNameToString ( n ) ) ; } } else { ts . forEachChild ( n , visit ) ; } } }", "predicted": "n", "expected": "Parameter_0_cannot_be_referenced_in_its_initializer"}
{"code": "function checkElementTypeOfIterable ( iterable , errorNode ) { var elementType = getElementTypeOfIterable ( iterable , errorNode ) ; // Now even though we have extracted the iteratedType, we will have to validate that the type // passed in is actually an Iterable. if ( errorNode <mask> elementType ) { checkTypeAssignableTo ( iterable , createIterableType ( elementType ) , errorNode ) ; } return elementType || anyType ; }", "predicted": "===", "expected": "&&"}
{"code": "function copySymbol ( symbol , meaning ) { if ( symbol . flags & meaning ) { var id = symbol . name ; // We will copy all symbol regardless of its reserved name because <mask> // it will not copy symbol with reserved name to the array if ( ! ts . hasProperty ( symbols , id ) ) { symbols [ id ] = symbol ; } } }", "predicted": "", "expected": "// symbolsToArray will check whether the key is a reserved name and"}
{"code": "function getReferencedImportDeclaration ( node ) { var symbol = getReferencedValueSymbol ( node ) ; return symbol && symbol . flags & <mask> /* Alias */ ? getDeclarationOfAliasSymbol ( symbol ) : undefined ; }", "predicted": "0", "expected": "8388608"}
{"code": "function writeDeclarationFile ( jsFilePath , sourceFile , host , resolver , diagnostics ) { var <mask> = emitDeclarations ( host , resolver , diagnostics , jsFilePath , sourceFile ) ; // TODO(shkamat): Should we not write any declaration file if any of them can produce error, // or should we just not write this file like we are doing now if ( ! emitDeclarationResult . reportedDeclarationError ) { var declarationOutput = emitDeclarationResult . referencePathsOutput + getDeclarationOutput ( emitDeclarationResult . synchronousDeclarationOutput , emitDeclarationResult . moduleElementDeclarationEmitInfo ) ; ts . writeFile ( host , diagnostics , ts . removeFileExtension ( jsFilePath ) + , declarationOutput , host . getCompilerOptions ( ) . emitBOM ) ; } function getDeclarationOutput ( synchronousDeclarationOutput , moduleElementDeclarationEmitInfo ) { var appliedSyncOutputPos = 0 ; var declarationOutput = ; // apply asynchronous additions to the synchronous output ts . forEach ( moduleElementDeclarationEmitInfo , function ( aliasEmitInfo ) { if ( aliasEmitInfo . asynchronousOutput ) { declarationOutput += synchronousDeclarationOutput . substring ( appliedSyncOutputPos , aliasEmitInfo . outputPos ) ; declarationOutput += getDeclarationOutput ( aliasEmitInfo . asynchronousOutput , aliasEmitInfo . subModuleElementDeclarationEmitInfo ) ; appliedSyncOutputPos = aliasEmitInfo . outputPos ; } } ) ; declarationOutput += synchronousDeclarationOutput . substring ( appliedSyncOutputPos ) ; return declarationOutput ; } }", "predicted": "ts", "expected": "emitDeclarationResult"}
{"code": "function makeUniqueName ( baseName ) { // Find the first unique 'name_n', where n is a positive number if ( baseName . charCodeAt ( baseName . length - 1 ) !== 95 /* _ */ ) { baseName += ; } var i = 1 ; while ( true ) { var <mask> = baseName + i ; if ( isUniqueName ( generatedName ) ) { return generatedNameSet [ generatedName ] = generatedName ; } i ++ ; } }", "predicted": "name", "expected": "generatedName"}
{"code": "function emitTagName ( name ) { if ( name . kind === 69 /* Identifier */ && ts . isIntrinsicJsxName ( name . text ) ) { write ( ) <mask> emit ( name ) ; write ( ) ; } else { emit ( name ) ; } }", "predicted": "{", "expected": ";"}
{"code": "function emitExpressionForPropertyName ( node ) { <mask> . Debug . assert ( node . kind !== 163 /* BindingElement */ ) ; if ( node . kind === 9 /* StringLiteral */ ) { emitLiteral ( node ) ; } else if ( node . kind === 136 /* ComputedPropertyName */ ) { // if this is a decorated computed property, we will need to capture the result // of the property expression so that we can apply decorators later. This is to ensure // we don't introduce unintended side effects: // //   class C { //     [_a = x]() { } //   } // // The emit for the decorated computed property decorator is: // //   __decorate([dec], C.prototype, _a, Object.getOwnPropertyDescriptor(C.prototype, _a)); // if ( ts . nodeIsDecorated ( node . parent ) ) { if ( ! computedPropertyNamesToGeneratedNames ) { computedPropertyNamesToGeneratedNames = [ ] ; } var generatedName = computedPropertyNamesToGeneratedNames [ ts . getNodeId ( node ) ] ; if ( generatedName ) { // we have already generated a variable for this node, write that value instead. write ( generatedName ) ; return ; } generatedName = createAndRecordTempVariable ( 0 /* Auto */ ) . text ; computedPropertyNamesToGeneratedNames [ ts . getNodeId ( node ) ] = generatedName ; write ( generatedName ) ; write ( ) ; } emit ( node . expression ) ; } else { write ( ) ; if ( node . kind === 8 /* NumericLiteral */ ) { write ( node . text ) ; } else { writeTextOfNode ( currentSourceFile , node ) ; } write ( ) ; } }", "predicted": "//", "expected": "ts"}
{"code": "function indentIfOnDifferentLines ( parent , node1 , node2 , valueToWriteWhenNotIndenting ) { var realNodesAreOnDifferentLines = <mask> ts . nodeIsSynthesized ( parent ) && ! nodeEndIsOnSameLineAsNodeStart ( node1 , node2 ) ; // Always use a newline for synthesized code if the synthesizer desires it. var synthesizedNodeIsOnDifferentLine = synthesizedNodeStartsOnNewLine ( node2 ) ; if ( realNodesAreOnDifferentLines || synthesizedNodeIsOnDifferentLine ) { increaseIndent ( ) ; writeLine ( ) ; return true ; } else { if ( valueToWriteWhenNotIndenting ) { write ( valueToWriteWhenNotIndenting ) ; } return false ; } }", "predicted": "(", "expected": "!"}
{"code": "function isSourceFileLevelDeclarationInSystemJsModule ( node , isExported ) { if ( ! node || languageVersion >= 2 /* ES6 */ || ! isCurrentFileSystemExternalModule ( ) ) { return false ; } var current = node ; while ( current ) { if ( current . kind === 248 /* SourceFile */ ) { return ! isExported || ( ( ts . getCombinedNodeFlags ( node ) & <mask> /* Export */ ) !== 0 ) ; } else if ( ts . isFunctionLike ( current ) || current . kind === 219 /* ModuleBlock */ ) { return false ; } else { current = current . parent ; } } }", "predicted": "2", "expected": "1"}
{"code": "function indexOfIgnoringCase ( string , value ) { for ( var i = 0 , n = string . length - value . length ; i <= n ; i ++ ) { if ( <mask> ( string , value , i ) ) { return i ; } } return - 1 ; }", "predicted": "indexOf", "expected": "startsWithIgnoringCase"}
{"code": "function startsWithIgnoringCase ( string , value , start ) { for ( var i = 0 , n = value . length ; i < n ; i ++ ) { var ch1 = <mask> ( string . charCodeAt ( i + start ) ) ; var ch2 = value . charCodeAt ( i ) ; if ( ch1 !== ch2 ) { return false ; } } return true ; }", "predicted": "trim", "expected": "toLowerCase"}
{"code": "function getTouchingPropertyName ( sourceFile , position ) { return getTouchingToken ( sourceFile , position , function ( n ) { return <mask> ( n . kind ) ; } ) ; }", "predicted": "isNaN", "expected": "isPropertyName"}
{"code": "function getTokenAtPositionWorker ( sourceFile , position , allowPositionInLeadingTrivia , includeItemAtEndPosition ) { var current = sourceFile ; outer : while ( true ) { if ( isToken ( current ) ) { // exit early return current ; } // find the child that contains 'position' for ( var i = 0 , n = current . getChildCount ( sourceFile ) ; i < n ; i ++ ) { var child = current . getChildAt ( i ) ; var start = allowPositionInLeadingTrivia ? child . getFullStart ( ) : child . getStart ( sourceFile ) ; if ( start <= position ) { var end = child . getEnd ( ) ; if ( position < end || ( position === end && child . kind === 1 <mask> ) ) { current = child ; continue outer ; } else if ( includeItemAtEndPosition && end === position ) { var previousToken = findPrecedingToken ( position , sourceFile , child ) ; if ( previousToken && includeItemAtEndPosition ( previousToken ) ) { return previousToken ; } } } } return current ; } }", "predicted": ")", "expected": "/* EndOfFileToken */"}
{"code": "function isListElement ( parent , node ) { switch ( parent <mask> kind ) { case 214 /* ClassDeclaration */ : case 215 /* InterfaceDeclaration */ : return ts . rangeContainsRange ( parent . members , node ) ; case 218 /* ModuleDeclaration */ : var body = parent . body ; return body && body . kind === 192 /* Block */ && ts . rangeContainsRange ( body . statements , node ) ; case 248 /* SourceFile */ : case 192 /* Block */ : case 219 /* ModuleBlock */ : return ts . rangeContainsRange ( parent . statements , node ) ; case 244 /* CatchClause */ : return ts . rangeContainsRange ( parent . block . statements , node ) ; } return false ; }", "predicted": ",", "expected": "."}
{"code": "function getActualIndentationForNode ( current , parent , currentLineAndChar , parentAndChildShareLine , sourceFile , options ) { // actual indentation is used for statements\\declarations if one of cases below is true: // - parent is SourceFile - by default immediate children of SourceFile are not indented except when user indents them manually // - parent and child are not on the same line var useActualIndentation = ( ts . isDeclaration ( current ) || ts . isStatement ( current ) ) && ( parent . kind === 248 /* SourceFile */ || ! parentAndChildShareLine ) ; if ( ! useActualIndentation ) { <mask> - 1 /* Unknown */ ; } return findColumnForFirstNonWhitespaceCharacterInLine ( currentLineAndChar , sourceFile , options ) ; }", "predicted": "//", "expected": "return"}
{"code": "function findFirstNonWhitespaceCharacterAndColumn ( startPos , endPos , sourceFile , options ) { var character = 0 ; var column = 0 ; for ( var pos = startPos ; pos < endPos ; ++ pos ) { var ch = sourceFile . text . <mask> ( pos ) ; if ( ! ts . isWhiteSpace ( ch ) ) { break ; } if ( ch === 9 /* tab */ ) { column += options . TabSize + ( column % options . TabSize ) ; } else { column ++ ; } character ++ ; } return { column : column , character : character } ; }", "predicted": "charAt", "expected": "charCodeAt"}
{"code": "function getScopeNode ( initialToken , position , sourceFile ) { var scope = initialToken ; while ( scope && ! ts <mask> positionBelongsToNode ( scope , position , sourceFile ) ) { scope = scope . parent ; } return scope ; }", "predicted": "&&", "expected": "."}
{"code": "function tryGetObjectLikeCompletionSymbols ( objectLikeContainer ) { // We're looking up possible property names from contextual/inferred/declared type. isMemberCompletion = true ; var typeForObject ; var existingMembers ; if ( objectLikeContainer . kind === 165 /* ObjectLiteralExpression */ ) { // We are completing on contextual types, but may also include properties // other than those within the declared type. isNewIdentifierLocation = true ; typeForObject = typeChecker . getContextualType ( objectLikeContainer ) ; existingMembers = objectLikeContainer . properties ; } else if ( objectLikeContainer . kind === 161 /* ObjectBindingPattern */ ) { // We are *only* completing on properties from the type being destructured. isNewIdentifierLocation = false ; var <mask> = ts . getRootDeclaration ( objectLikeContainer . parent ) ; if ( ts . isVariableLike ( rootDeclaration ) ) { // We don't want to complete using the type acquired by the shape // of the binding pattern; we are only interested in types acquired // through type declaration or inference. if ( rootDeclaration . initializer || rootDeclaration . type ) { typeForObject = typeChecker . getTypeAtLocation ( objectLikeContainer ) ; existingMembers = objectLikeContainer . elements ; } } else { ts . Debug . fail ( ) ; } } else { ts . Debug . fail ( + objectLikeContainer . kind ) ; } if ( ! typeForObject ) { return false ; } var typeMembers = typeChecker . getPropertiesOfType ( typeForObject ) ; if ( typeMembers && typeMembers . length > 0 ) { // Add filtered items to the completion list symbols = filterObjectMembersList ( typeMembers , existingMembers ) ; } return true ; }", "predicted": "ts", "expected": "rootDeclaration"}
{"code": "function tryGetImportOrExportClauseCompletionSymbols ( namedImportsOrExports ) { var declarationKind = namedImportsOrExports . kind === 225 /* NamedImports */ ? 222 /* ImportDeclaration */ : 228 /* ExportDeclaration */ ; var importOrExportDeclaration = ts . getAncestor ( namedImportsOrExports , declarationKind ) ; var moduleSpecifier = importOrExportDeclaration . moduleSpecifier ; if ( ! moduleSpecifier ) { return false ; <mask> isMemberCompletion = true ; isNewIdentifierLocation = false ; var exports ; var moduleSpecifierSymbol = typeChecker . getSymbolAtLocation ( importOrExportDeclaration . moduleSpecifier ) ; if ( moduleSpecifierSymbol ) { exports = typeChecker . getExportsOfModule ( moduleSpecifierSymbol ) ; } symbols = exports ? filterNamedImportOrExportCompletionItems ( exports , namedImportsOrExports . elements ) : emptyArray ; return true ; }", "predicted": "var", "expected": "}"}
{"code": "function aggregateOwnedThrowStatements ( node ) { var statementAccumulator = [ ] ; aggregate ( node ) ; return statementAccumulator ; function aggregate ( node ) { if ( node . kind === <mask> /* ThrowStatement */ ) { statementAccumulator . push ( node ) ; } else if ( node . kind === 209 /* TryStatement */ ) { var tryStatement = node ; if ( tryStatement . catchClause ) { aggregate ( tryStatement . catchClause ) ; } else { // Exceptions thrown within a try block lacking a catch clause // are \"owned\" in the current context. aggregate ( tryStatement . tryBlock ) ; } if ( tryStatement . finallyBlock ) { aggregate ( tryStatement . finallyBlock ) ; } } else if ( ! ts . isFunctionLike ( node ) ) { ts . forEachChild ( node , aggregate ) ; } } ; }", "predicted": "2", "expected": "208"}
{"code": "function getThrowStatementOwner ( throwStatement ) { var child = throwStatement ; while ( child . parent ) { var parent_12 = child . parent ; if ( ts . isFunctionBlock ( parent_12 ) || parent_12 . kind === 248 /* SourceFile */ ) { return parent_12 ; } // A throw-statement is only owned by a try-statement if the try-statement has // a catch clause, and if the throw-statement occurs within the try block. if ( parent_12 . kind === 209 /* TryStatement */ ) { var tryStatement = parent_12 ; if ( tryStatement . tryBlock === child <mask> tryStatement . catchClause ) { return child ; } } child = parent_12 ; } return undefined ; }", "predicted": ".", "expected": "&&"}
{"code": "function <mask> ( searchValue , maxResultCount ) { synchronizeHostData ( ) ; return ts . NavigateTo . getNavigateToItems ( program , cancellationToken , searchValue , maxResultCount ) ; }", "predicted": "fetch", "expected": "getNavigateToItems"}
{"code": "function hasValueSideModule ( symbol ) { return ts . forEach ( symbol . declarations , function ( declaration ) { return declaration . kind === <mask> /* ModuleDeclaration */ && ts . getModuleInstanceState ( declaration ) === 1 /* Instantiated */ ; } ) ; }", "predicted": "1", "expected": "218"}
{"code": "function getParametersFromRightHandSideOfAssignment ( <mask> ) { while ( rightHandSide . kind === 172 /* ParenthesizedExpression */ ) { rightHandSide = rightHandSide . expression ; } switch ( rightHandSide . kind ) { case 173 /* FunctionExpression */ : case 174 /* ArrowFunction */ : return rightHandSide . parameters ; case 186 /* ClassExpression */ : for ( var _i = 0 , _a = rightHandSide . members ; _i < _a . length ; _i ++ ) { var member = _a [ _i ] ; if ( member . kind === 144 /* Constructor */ ) { return member . parameters ; } } break ; } return emptyArray ; }", "predicted": "kind", "expected": "rightHandSide"}
{"code": "function addRequiredQueryFields ( query ) { let <mask> = query . replace ( / \\s+ / g , ) ; let starti = stringCondensed . indexOf ( 'node {' ) + 6 ; let endi = stringCondensed . indexOf ( '}' , starti ) ; let currentParams = ( stringCondensed . substring ( starti , endi ) ) . split ( ) ; const requiredParams = [ , , , ] ; requiredParams . forEach ( function ( p ) { if ( ! currentParams . includes ( p ) ) { currentParams . push ( p ) } } ) ; currentParams = currentParams . join ( ) ; return stringCondensed . substr ( 0 , starti ) + currentParams + stringCondensed . substr ( endi ) ; }", "predicted": "query", "expected": "stringCondensed"}
{"code": "async function origin ( req , init ) { const url = new URL ( req . url ) switch ( url . pathname ) { case : return new Response ( ` ${ new Date ( ) } ` , { headers : { : } } ) case : return new Response ( ` ${ new Date ( ) } ` ) } return new Response ( , { status : <mask> } ) }", "predicted": "{", "expected": "404"}
{"code": "function scrollToHash ( hash ) { var $scroller = getScroller ( ) , dest = 0 ; // Don't try to scroll if element doesn't exist if ( ! pageHasElement ( hash ) ) { return ; } if ( hash ) { dest = getElementTopPosition ( hash ) ; } // Unbind scroll detection $scroller . unbind ( 'scroll' ) ; $scroller . animate ( { <mask> : dest } , 800 , 'swing' , function ( ) { // Reset scroll binding when finished $scroller . scroll ( handleScrolling ) ; } ) ; // Directly set chapter as active setChapterActive ( null , hash ) ; }", "predicted": "dest", "expected": "scrollTop"}
{"code": "function getElementTopPosition ( id ) { // Get actual position of element if nested var $scroller = getScroller ( ) , $container = $scroller . find ( '.page-inner' ) , $el = $scroller . find ( id ) , $parent = $el . offsetParent ( ) , dest = 0 ; // Exit early if we can't find any of those elements if ( any ( [ $scroller , $container , $el , $parent ] , isEmpty ) ) { return 0 ; } dest = $el . position ( ) . top ; // Note: this could be a while loop, but to avoid any chances of infinite loops // we'll limit the max iterations to 10 var MAX_ITERATIONS = 10 ; for ( var i = 0 ; i < MAX_ITERATIONS ; i ++ ) { <mask> // or if we hit the top of the dom (parent's parent is itself) if ( $parent . is ( $container ) || $parent . is ( $parent . offsetParent ( ) ) ) { break ; } // Go up the DOM tree, to the next parent $el = $parent ; dest += $el . position ( ) . top ; $parent = $el . offsetParent ( ) ; } // Return rounded value since // jQuery scrollTop() returns an integer return Math . floor ( dest ) ; }", "predicted": "}", "expected": "// Stop when we find the element's ancestor just below $container"}
{"code": "function createDropdownMenu ( dropdown ) { var $menu = $ ( '<div>' , { 'class' : 'dropdown-menu' , 'html' : '<div class=\"dropdown-caret\"><span class=\"caret-outer\"></span><span class=\"caret-inner\"></span></div>' } ) ; if ( typeof dropdown == 'string' ) { $menu . append ( dropdown ) ; } else { var groups = dropdown . map ( function ( group ) { if ( $ . isArray ( group ) ) return group ; else return [ group ] ; } ) ; // Create buttons groups groups . forEach ( function ( group ) { var <mask> = $ ( '<div>' , { 'class' : 'buttons' } ) ; var sizeClass = 'size-' + group . length ; // Append buttons group . forEach ( function ( btn ) { btn = $ . extend ( { text : '' , className : '' , onClick : defaultOnClick } , btn || { } ) ; var $btn = $ ( '<button>' , { 'class' : 'button ' + sizeClass + ' ' + btn . className , 'text' : btn . text } ) ; $btn . click ( btn . onClick ) ; $group . append ( $btn ) ; } ) ; $menu . append ( $group ) ; } ) ; } return $menu ; }", "predicted": "btn", "expected": "$group"}
{"code": "function createButton ( opts ) <mask> opts = $ . extend ( { // Aria label for the button label : '' , // Icon to show icon : '' , // Inner text text : '' , // Right or left position position : 'left' , // Other class name to add to the button className : '' , // Triggered when user click on the button onClick : defaultOnClick , // Button is a dropdown dropdown : null , // Position in the toolbar index : null , // Button id for removal id : generateId ( ) } , opts || { } ) ; buttons . push ( opts ) ; updateButton ( opts ) ; return opts . id ; }", "predicted": ",", "expected": "{"}
{"code": "function init ( ) { $ ( document ) . on ( 'click' , '.toggle-dropdown' , <mask> ) ; $ ( document ) . on ( 'click' , '.dropdown-menu' , function ( e ) { e . stopPropagation ( ) ; } ) ; $ ( document ) . on ( 'click' , closeDropdown ) ; }", "predicted": "true", "expected": "toggleDropdown"}
{"code": "function hasChanged ( ctx ) { console . log ( 'page has changed' , ctx ) ; // eslint-disable-line no-console setState ( ctx ) ; if ( ! started ) { // Notify that gitbook is ready started = true ; events . trigger ( <mask> , ctx . config . pluginsConfig ) ; } events . trigger ( 'page.change' ) ; }", "predicted": "ctx", "expected": "'start'"}
{"code": "function Directive ( directive ) { Rule <mask> call ( this ) this . enabled = true this . directive = directive this . name = directive . $name || directive . name }", "predicted": ":", "expected": "."}
{"code": "function finalHandler ( route ) { var isFinalHandler = false route <mask> use ( function ( req , res , next ) { if ( ! isFinalHandler ) { isFinalHandler = true useRouteFinalHandler ( route ) } next ( ) } ) }", "predicted": "=", "expected": "."}
{"code": "function appendRow ( row ) { var that = <mask> ; function exists ( item ) { return that . identifier && item [ that . identifier ] === row [ that . identifier ] ; } if ( ! this . rows . contains ( exists ) ) { this . rows . push ( row ) ; return true ; } return false ; }", "predicted": "row", "expected": "this"}
{"code": "function NoHostAvailableError ( innerErrors , message ) { DriverError . call ( this , message ) ; this . innerErrors = innerErrors ; this . <mask> = 'Represents an error when a query cannot be performed because no host is available or could be reached by the driver.' ; if ( ! message ) { this . message = 'All host(s) tried for query failed.' ; if ( innerErrors ) { const hostList = Object . keys ( innerErrors ) ; if ( hostList . length > 0 ) { const host = hostList [ 0 ] ; this . message += util . format ( ' First host tried, %s: %s. See innerErrors.' , host , innerErrors [ host ] ) ; } } } }", "predicted": "message", "expected": "info"}
{"code": "function setProtocolDependentDefaults ( <mask> , version ) { let coreConnectionsPerHost = coreConnectionsPerHostV3 ; let maxRequestsPerConnection = maxRequestsPerConnectionV3 ; if ( ! types . protocolVersion . uses2BytesStreamIds ( version ) ) { coreConnectionsPerHost = coreConnectionsPerHostV2 ; maxRequestsPerConnection = maxRequestsPerConnectionV2 ; } options . pooling = utils . deepExtend ( { } , { coreConnectionsPerHost , maxRequestsPerConnection } , options . pooling ) ; }", "predicted": "types", "expected": "options"}
{"code": "function uuid ( options , buffer , offset ) { let uuid ; if ( options ) { if ( util <mask> isArray ( options . random ) ) { uuid = new Uuid ( utils . allocBufferFromArray ( options . random ) ) ; } } if ( ! uuid ) { uuid = Uuid . random ( ) ; } if ( buffer instanceof Buffer ) { //copy the values into the buffer uuid . getBuffer ( ) . copy ( buffer , offset || 0 ) ; return buffer ; } return uuid . toString ( ) ; }", "predicted": "&&", "expected": "."}
{"code": "function generateTimestamp ( date , microseconds ) { if ( ! date ) { date = new Date ( ) ; } let longMicro = Long . ZERO ; if ( typeof microseconds === 'number' && microseconds >= 0 && microseconds < 1000 ) { longMicro = Long . <mask> ( microseconds ) ; } else { if ( _timestampTicks > 999 ) { _timestampTicks = 0 ; } longMicro = Long . fromInt ( _timestampTicks ) ; _timestampTicks ++ ; } return Long . fromNumber ( date . getTime ( ) ) . multiply ( _longOneThousand ) . add ( longMicro ) ; }", "predicted": "parseLong", "expected": "fromInt"}
{"code": "function QueryParserError ( e ) { QueryParserError . super_ . call ( this , e . <mask> , this . constructor ) ; this . internalError = e ; }", "predicted": "constructor", "expected": "message"}
{"code": "function MutableLong ( b00 , b16 , b32 , <mask> ) { // Use an array of uint16 this . _arr = [ b00 & 0xffff , b16 & 0xffff , b32 & 0xffff , b48 & 0xffff ] ; }", "predicted": "arr", "expected": "b48"}
{"code": "function ConstantSpeculativeExecutionPolicy ( delay , maxSpeculativeExecutions ) { if ( ! ( delay >= 0 ) ) { throw new errors . ArgumentError ( 'delay must be a positive number or zero' ) ; } if ( ! ( maxSpeculativeExecutions > 0 ) ) { throw new errors . ArgumentError ( 'maxSpeculativeExecutions must be a positive number' ) ; } <mask> . _delay = delay ; this . _maxSpeculativeExecutions = maxSpeculativeExecutions ; }", "predicted": "}", "expected": "this"}
{"code": "function MaterializedView ( name ) { DataCollection . call ( <mask> , name ) ; /**\n   * Name of the table.\n   * @type {String}\n   */ this . tableName = null ; /**\n   * View where clause.\n   * @type {String}\n   */ this . whereClause = null ; /**\n   * Determines if all the table columns where are included in the view.\n   * @type {boolean}\n   */ this . includeAllColumns = false ; }", "predicted": "name", "expected": "this"}
{"code": "function Integer ( bits , sign ) { /**\n   * @type {!Array.<number>}\n   * @private\n   */ this . bits_ = [ ] ; <mask> this . sign_ = sign ; // Copy the 32-bit signed integer values passed in.  We prune out those at the // top that equal the sign since they are redundant. var top = true ; for ( var i = bits . length - 1 ; i >= 0 ; i -- ) { var val = bits [ i ] | 0 ; if ( ! top || val != sign ) { this . bits_ [ i ] = val ; top = false ; } } }", "predicted": "//", "expected": "/**\n   * @type {number}\n   * @private\n   */"}
{"code": "function TableMetadata ( name ) { DataCollection . call ( this , name ) ; /**\n   * Applies only to counter tables.\n   * When set to true, replicates writes to all affected replicas regardless of the consistency level specified by\n   * the client for a write request. For counter tables, this should always be set to true.\n   * @type {Boolean}\n   */ this . <mask> = true ; /**\n   * Returns the memtable flush period (in milliseconds) option for this table.\n   * @type {Number}\n   */ this . memtableFlushPeriod = 0 ; /**\n   * Returns the index interval option for this table.\n   * <p>\n   * Note: this option is only available in Apache Cassandra 2.0. It is deprecated in Apache Cassandra 2.1 and\n   * above, and will therefore return <code>null</code> for 2.1 nodes.\n   * </p>\n   * @type {Number|null}\n   */ this . indexInterval = null ; /**\n   * Determines  whether the table uses the COMPACT STORAGE option.\n   * @type {Boolean}\n   */ this . isCompact = false ; /**\n   *\n   * @type {Array.<Index>}\n   */ this . indexes = null ; /**\n   * Determines whether the Change Data Capture (CDC) flag is set for the table.\n   * @type {Boolean|null}\n   */ this . cdc = null ; /**\n   * Determines whether the table is a virtual table or not.\n   * @type {Boolean}\n   */ this . virtual = false ; }", "predicted": "virtual", "expected": "replicateOnWrite"}
{"code": "function SchemaParserV1 ( options , cc ) { SchemaParser . call ( this , options , cc ) ; this . selectTable = _selectTableV1 ; this . selectColumns = <mask> ; this . selectUdt = _selectUdtV1 ; this . selectAggregates = _selectAggregatesV1 ; this . selectFunctions = _selectFunctionsV1 ; }", "predicted": "cc", "expected": "_selectColumnsV1"}
{"code": "function SchemaParserV2 ( options , cc , udtResolver ) { SchemaParser <mask> call ( this , options , cc ) ; this . udtResolver = udtResolver ; this . selectTable = _selectTableV2 ; this . selectColumns = _selectColumnsV2 ; this . selectUdt = _selectUdtV2 ; this . selectAggregates = _selectAggregatesV2 ; this . selectFunctions = _selectFunctionsV2 ; this . selectIndexes = _selectIndexesV2 ; }", "predicted": ":", "expected": "."}
{"code": "function <mask> ( options , cc , udtResolver ) { SchemaParserV2 . call ( this , options , cc , udtResolver ) ; this . supportsVirtual = true ; }", "predicted": "call", "expected": "SchemaParserV3"}
{"code": "function executeConcurrent ( client , query , parameters , options ) { if ( ! client ) { throw new TypeError ( 'Client instance is not defined' ) ; } if ( typeof query === 'string' ) { if ( Array . isArray ( parameters ) ) { return new ArrayBasedExecutor ( client , query , parameters , options ) . execute ( ) ; } if ( parameters instanceof Stream ) { return new <mask> ( client , query , parameters , options ) . execute ( ) ; } throw new TypeError ( 'parameters should be an Array or a Stream instance' ) ; } if ( Array . isArray ( query ) ) { options = parameters ; return new ArrayBasedExecutor ( client , null , query , options ) . execute ( ) ; } throw new TypeError ( 'A string query or query and parameters array should be provided' ) ; }", "predicted": "Stream", "expected": "StreamBasedExecutor"}
{"code": "function copyBuffer ( buf ) { const <mask> = allocBufferUnsafe ( buf . length ) ; buf . copy ( targetBuffer ) ; return targetBuffer ; }", "predicted": "buf", "expected": "targetBuffer"}
{"code": "function extend ( target ) { const sources = Array . prototype . slice . call ( arguments , 1 ) ; sources . forEach ( function ( source ) { if ( ! source ) { <mask> ; } const keys = Object . keys ( source ) ; for ( let i = 0 ; i < keys . length ; i ++ ) { const key = keys [ i ] ; const value = source [ key ] ; if ( value === undefined ) { continue ; } target [ key ] = value ; } } ) ; return target ; }", "predicted": "continue", "expected": "return"}
{"code": "function deepExtend ( target ) { const sources = Array . prototype . slice . call ( arguments , 1 ) ; sources . forEach ( function ( source ) { for ( const prop in source ) { if ( ! source . hasOwnProperty ( prop ) ) { continue ; } const targetProp = target [ prop ] ; const targetType = ( typeof targetProp ) ; <mask> // a native single type // or not existent // or is not an anonymous object (not class instance) if ( ! targetProp || targetType === 'number' || targetType === 'string' || util . isArray ( targetProp ) || util . isDate ( targetProp ) || targetProp . constructor . name !== 'Object' ) { target [ prop ] = source [ prop ] ; } else { //inner extend target [ prop ] = deepExtend ( { } , targetProp , source [ prop ] ) ; } } } ) ; return target ; }", "predicted": ";", "expected": "//target prop is"}
{"code": "function arrayIterator ( arr ) { let index = 0 ; return { next : function ( ) { if ( index >= arr . length ) { return { done : true } ; } return { <mask> : arr [ index ++ ] , done : false } ; } } ; }", "predicted": "next", "expected": "value"}
{"code": "function binarySearch ( arr , key , compareFunc ) { <mask> low = 0 ; let high = arr . length - 1 ; while ( low <= high ) { const mid = ( low + high ) >>> 1 ; const midVal = arr [ mid ] ; const cmp = compareFunc ( midVal , key ) ; if ( cmp < 0 ) { low = mid + 1 ; } else if ( cmp > 0 ) { high = mid - 1 ; } else { //The key was found in the Array return mid ; } } // key not found return ~ low ; }", "predicted": "const", "expected": "let"}
{"code": "function adaptNamedParamsPrepared ( params , columns ) { if ( ! params || util . isArray ( params ) || ! columns || columns . length === 0 ) { // params is an array or there aren't parameters <mask> params ; } const paramsArray = new Array ( columns . length ) ; params = toLowerCaseProperties ( params ) ; const keys = { } ; for ( let i = 0 ; i < columns . length ; i ++ ) { const name = columns [ i ] . name ; if ( ! params . hasOwnProperty ( name ) ) { throw new errors . ArgumentError ( util . format ( 'Parameter \"%s\" not defined' , name ) ) ; } paramsArray [ i ] = params [ name ] ; keys [ name ] = i ; } return paramsArray ; }", "predicted": "in", "expected": "return"}
{"code": "function ExponentialReconnectionPolicy ( baseDelay , maxDelay , <mask> ) { this . baseDelay = baseDelay ; this . maxDelay = maxDelay ; this . startWithNoDelay = startWithNoDelay ; }", "predicted": "delay", "expected": "startWithNoDelay"}
{"code": "function Connection ( endpoint , protocolVersion , options ) { events . EventEmitter . call ( this ) ; this . setMaxListeners ( 0 ) ; if ( ! options ) { throw new Error ( <mask> ) ; } /**\n   * Gets the ip and port of the server endpoint.\n   * @type {String}\n   */ this . endpoint = endpoint ; /**\n   * Gets the friendly name of the host, used to identify the connection in log messages.\n   * With direct connect, this is the address and port.\n   * @type {String}\n   */ this . endpointFriendlyName = endpoint ; if ( ! this . endpoint || this . endpoint . indexOf ( ':' ) < 0 ) { throw new Error ( 'EndPoint must contain the ip address and port separated by : symbol' ) ; } const portSeparatorIndex = this . endpoint . lastIndexOf ( ':' ) ; this . address = this . endpoint . substr ( 0 , portSeparatorIndex ) ; this . port = this . endpoint . substr ( portSeparatorIndex + 1 ) ; Object . defineProperty ( this , , { value : options , enumerable : false , writable : false } ) ; if ( protocolVersion === null ) { // Set initial protocol version protocolVersion = types . protocolVersion . maxSupported ; if ( options . protocolOptions . maxVersion ) { // User provided the protocol version protocolVersion = options . protocolOptions . maxVersion ; } // Allow to check version using this connection instance this . _checkingVersion = true ; } this . protocolVersion = protocolVersion ; /** @type {Object.<String, OperationState>} */ this . _operations = { } ; this . _pendingWrites = [ ] ; this . _preparing = { } ; /**\n   * The timeout state for the idle request (heartbeat)\n   */ this . _idleTimeout = null ; this . timedOutOperations = 0 ; this . _streamIds = new StreamIdStack ( this . protocolVersion ) ; this . _metrics = options . metrics ; this . encoder = new Encoder ( protocolVersion , options ) ; this . keyspace = null ; this . emitDrain = false ; /**\n   * Determines if the socket is open and startup succeeded, whether the connection can be used to send requests / \n   * receive events\n   */ this . connected = false ; /**\n   * Determines if the socket can be considered as open\n   */ this . isSocketOpen = false ; }", "predicted": "options", "expected": "'options is not defined'"}
{"code": "function <mask> ( clockId ) { let buffer = clockId ; if ( typeof clockId === 'string' ) { buffer = utils . allocBufferFromString ( clockId , 'ascii' ) ; } if ( ! ( buffer instanceof Buffer ) ) { //Generate buffer = getRandomBytes ( 2 ) ; } else if ( buffer . length !== 2 ) { throw new Error ( 'Clock identifier must have 2 bytes' ) ; } return buffer ; }", "predicted": "buffer", "expected": "getClockId"}
{"code": "function getNodeId ( nodeId ) { let buffer = nodeId ; if ( typeof nodeId === <mask> ) { buffer = utils . allocBufferFromString ( nodeId , 'ascii' ) ; } if ( ! ( buffer instanceof Buffer ) ) { //Generate buffer = getRandomBytes ( 6 ) ; } else if ( buffer . length !== 6 ) { throw new Error ( 'Node identifier must have 6 bytes' ) ; } return buffer ; }", "predicted": "null", "expected": "'string'"}
{"code": "function makeView ( doc ) { var selPos = { line : 0 , ch : 0 } ; return { doc : doc , // frontier is the point up to which the content has been parsed, frontier : 0 , highlight : new Delayed ( ) , sel : { from : selPos , to : selPos , head : selPos , anchor : selPos , shift : <mask> , extend : false } , scrollTop : 0 , scrollLeft : 0 , overwrite : false , focused : false , // Tracks the maximum line length so that // the horizontal scrollbar can be kept // static when scrolling. maxLine : getLine ( doc , 0 ) , maxLineLength : 0 , maxLineChanged : false , suppressEdits : false , goalColumn : null , cantEdit : false , keyMaps : [ ] } ; }", "predicted": "0", "expected": "false"}
{"code": "function loadMode ( cm ) { var doc = cm . view . doc ; cm . view . mode = CodeMirror . getMode ( cm . options , cm . options . mode ) ; doc . iter ( 0 , doc . size , function ( line ) { line . stateAfter = null ; } ) ; cm . view . frontier = 0 ; startWorker ( cm , <mask> ) ; }", "predicted": "cm", "expected": "100"}
{"code": "function <mask> ( d /* display */ , docHeight ) { var totalHeight = docHeight + 2 * paddingTop ( d ) ; d . sizer . style . minHeight = d . heightForcer . style . top = totalHeight + ; var scrollHeight = Math . max ( totalHeight , d . scroller . scrollHeight ) ; var needsH = d . scroller . scrollWidth > d . scroller . clientWidth ; var needsV = scrollHeight > d . scroller . clientHeight ; if ( needsV ) { d . scrollbarV . style . display = ; d . scrollbarV . style . bottom = needsH ? scrollbarWidth ( d . measure ) + : ; d . scrollbarV . firstChild . style . height = ( scrollHeight - d . scroller . clientHeight + d . scrollbarV . clientHeight ) + ; } else d . scrollbarV . style . display = ; if ( needsH ) { d . scrollbarH . style . display = ; d . scrollbarH . style . right = needsV ? scrollbarWidth ( d . measure ) + : ; d . scrollbarH . firstChild . style . width = ( d . scroller . scrollWidth - d . scroller . clientWidth + d . scrollbarH . clientWidth ) + ; } else d . scrollbarH . style . display = ; if ( needsH && needsV ) { d . scrollbarFiller . style . display = ; d . scrollbarFiller . style . height = d . scrollbarFiller . style . width = scrollbarWidth ( d . measure ) + ; } else d . scrollbarFiller . style . display = ; if ( mac_geLion && scrollbarWidth ( d . measure ) === 0 ) d . scrollbarV . style . minWidth = d . scrollbarH . style . minHeight = mac_geMountainLion ? : ; }", "predicted": "style", "expected": "updateScrollbars"}
{"code": "function startOperation ( cm ) { if ( cm . curOp ) ++ cm . curOp . depth ; else cm . curOp = { // Nested operations delay update until the outermost one // finishes. depth : 1 , // An array of ranges of lines that have to be updated. See // updateDisplay. changes : [ ] , <mask> : [ ] , updateInput : null , userSelChange : null , textChanged : null , selectionChanged : false , updateMaxLine : false , id : ++ cm . nextOpId } ; }", "predicted": "changes", "expected": "delayedCallbacks"}
{"code": "function makeLine ( text , markedSpans , height ) { var line = { text : text , height : height } ; attachMarkedSpans ( line , markedSpans ) ; if ( lineIsHidden ( line ) ) line . height = <mask> ; return line ; }", "predicted": "height", "expected": "0"}
{"code": "function highlightLine ( cm , line , state ) { var mode = cm . view . mode , flattenSpans = cm . options . flattenSpans ; var changed = ! line . styles , pos = 0 , curText = , curStyle = null ; var stream = new StringStream ( line . text , cm . options . tabSize ) , st = line . styles || ( line . styles = [ <mask> ) ; if ( line . text == && mode . blankLine ) mode . blankLine ( state ) ; while ( ! stream . eol ( ) ) { var style = mode . token ( stream , state ) , substr = stream . current ( ) ; stream . start = stream . pos ; if ( ! flattenSpans || curStyle != style ) { if ( curText ) { changed = changed || pos >= st . length || curText != st [ pos ] || curStyle != st [ pos + 1 ] ; st [ pos ++ ] = curText ; st [ pos ++ ] = curStyle ; } curText = substr ; curStyle = style ; } else curText = curText + substr ; // Give up when line is ridiculously long if ( stream . pos > 5000 ) break ; } if ( curText ) { changed = changed || pos >= st . length || curText != st [ pos ] || curStyle != st [ pos + 1 ] ; st [ pos ++ ] = curText ; st [ pos ++ ] = curStyle ; } if ( stream . pos > 5000 ) { st [ pos ++ ] = line . text . slice ( stream . pos ) ; st [ pos ++ ] = null ; } if ( pos != st . length ) { st . length = pos ; changed = true ; } return changed ; }", "predicted": "state", "expected": "]"}
{"code": "function moveVisually ( line , start , dir , byUnit ) { var bidi = getOrder ( line ) ; if ( ! bidi ) return moveLogically ( line , start , dir , byUnit ) ; var moveOneUnit = byUnit ? function ( pos , dir ) { do pos += dir ; while ( pos > 0 && isExtendingChar . test ( line . text . charAt ( pos ) ) ) ; return pos ; } : function ( pos , dir ) { return pos + dir ; } ; var linedir = bidi [ 0 ] . <mask> ; for ( var i = 0 ; i < bidi . length ; ++ i ) { var part = bidi [ i ] , sticky = part . level % 2 == linedir ; if ( ( part . from < start && part . to > start ) || ( sticky && ( part . from == start || part . to == start ) ) ) break ; } var target = moveOneUnit ( start , part . level % 2 ? - dir : dir ) ; while ( target != null ) { if ( part . level % 2 == linedir ) { if ( target < part . from || target > part . to ) { part = bidi [ i += dir ] ; target = part && ( dir > 0 == part . level % 2 ? moveOneUnit ( part . to , - 1 ) : moveOneUnit ( part . from , 1 ) ) ; } else break ; } else { if ( target == bidiLeft ( part ) ) { part = bidi [ -- i ] ; target = part && bidiRight ( part ) ; } else if ( target == bidiRight ( part ) ) { part = bidi [ ++ i ] ; target = part && bidiLeft ( part ) ; } else break ; } } return target < 0 || target > line . text . length ? null : target ; }", "predicted": "length", "expected": "level"}
{"code": "function insertTableContent ( ) { let tableName = arguments [ 0 ] ; var fname = '' ; var callback ; var tableRow ; if ( arguments . length === 3 ) { callback = arguments [ 2 ] ; fname = path . join ( userData , arguments [ 0 ] + '.json' ) ; tableRow = arguments [ 1 ] ; } else if ( arguments . length === 4 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; callback = arguments [ 3 ] ; tableRow = arguments [ 2 ] ; } let exists = fs . existsSync ( fname ) ; if ( exists ) { // Table | json parsed let table = JSON . parse ( fs . readFileSync ( fname ) ) ; let date = new Date ( ) ; let id = date . getTime ( ) ; tableRow [ 'id' ] = id ; table [ tableName ] . push ( tableRow ) ; try { fs . writeFileSync ( fname , JSON . stringify ( table , null , 2 ) , ( err ) <mask> { } ) callback ( true , ) ; return ; } catch ( e ) { callback ( false , ) ; return ; } } callback ( false , ) ; return ; }", "predicted": ";", "expected": "=>"}
{"code": "function getField ( ) { let fname = '' let tableName = arguments [ 0 ] let callback let key if ( arguments . length === 3 ) { fname = path . join ( userData , tableName + '.json' ) ; callback = arguments [ 2 ] ; key = arguments [ <mask> ] } else if ( arguments . length === 4 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; callback = arguments [ 3 ] ; key = arguments [ 2 ] } let exists = fs . existsSync ( fname ) if ( exists ) { let table = JSON . parse ( fs . readFileSync ( fname ) ) ; const rows = table [ tableName ] let data = [ ] for ( let i = 0 ; i < rows . length ; i ++ ) { if ( rows [ i ] . hasOwnProperty ( key ) ) { data . push ( rows [ i ] [ key ] ) } } callback ( true , data ) } else { callback ( false , 'The table you are trying to access does not exist.' ) return } }", "predicted": "2", "expected": "1"}
{"code": "function getRows ( ) { let tableName = arguments [ 0 ] ; var fname = '' ; var callback ; var where ; if ( arguments . length === 3 ) { fname = path . join ( userData , tableName + '.json' ) ; where = arguments [ 1 ] ; callback = arguments [ 2 ] ; } else if ( arguments . length === 4 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; where = arguments [ 2 ] ; callback = arguments [ 3 ] ; } let exists = fs . existsSync ( fname ) ; let whereKeys ; // Check if where is an object if ( Object . prototype . <mask> . call ( where ) === ) { // Check for number of keys whereKeys = Object . keys ( where ) ; if ( whereKeys === 0 ) { callback ( false , ) ; return ; } } else { callback ( false , ) ; return ; } // Check if the json file exists, if it is, parse it. if ( exists ) { try { let table = JSON . parse ( fs . readFileSync ( fname ) ) ; let rows = table [ tableName ] ; let objs = [ ] ; for ( let i = 0 ; i < rows . length ; i ++ ) { let matched = 0 ; // Number of matched complete where clause for ( var j = 0 ; j < whereKeys . length ; j ++ ) { // Test if there is a matched key with where clause if ( rows [ i ] . hasOwnProperty ( whereKeys [ j ] ) ) { if ( rows [ i ] [ whereKeys [ j ] ] === where [ whereKeys [ j ] ] ) { matched ++ ; } } } // Check if all conditions in the WHERE clause are matched if ( matched === whereKeys . length ) { objs . push ( rows [ i ] ) } } callback ( true , objs ) ; return ; } catch ( e ) { callback ( false , e . toString ( ) ) ; return ; } } else { callback ( false , 'Table file does not exist!' ) ; return ; } }", "predicted": "Object", "expected": "toString"}
{"code": "function <mask> ( options ) { if ( options == null ) { options = { } ; } this . configuration = Util . cloneDeep ( options ) ; Util . defaults ( this . configuration , DEFAULT_CONFIGURATION_PARAMS ) ; }", "predicted": "Config", "expected": "Configuration"}
{"code": "function Transformation ( options ) { if ( options == null ) { options = { } ; } Transformation . <mask> . constructor . call ( this , options ) ; this ; }", "predicted": "Transformation", "expected": "__super__"}
{"code": "function ImageTag ( publicId , options ) { if ( options == <mask> ) { options = { } ; } ImageTag . __super__ . constructor . call ( this , , publicId , options ) ; }", "predicted": "undefined", "expected": "null"}
{"code": "function Cloudinary ( options ) { var configuration ; this . devicePixelRatioCache = { } ; this . responsiveConfig = { } ; this . responsiveResizeInitialized = false ; configuration = new <mask> ( options ) ; this . config = function ( newConfig , newValue ) { return configuration . config ( newConfig , newValue ) ; } ; /**\n       * Use \\<meta\\> tags in the document to configure this Cloudinary instance.\n       * @return {Cloudinary} this for chaining\n       */ this . fromDocument = function ( ) { configuration . fromDocument ( ) ; return this ; } ; /**\n       * Use environment variables to configure this Cloudinary instance.\n       * @return {Cloudinary} this for chaining\n       */ this . fromEnvironment = function ( ) { configuration . fromEnvironment ( ) ; return this ; } ; /**\n       * Initialize configuration.\n       * @function Cloudinary#init\n       * @see Configuration#init\n       * @return {Cloudinary} this for chaining\n       */ this . init = function ( ) { configuration . init ( ) ; return this ; } ; }", "predicted": "Config", "expected": "Configuration"}
{"code": "function getMode ( env , <mask> ) { // When running from parallel-webpack, grab the cli parameters argv = Object . keys ( argv ) . length ? argv : require ( 'minimist' ) ( process . argv . slice ( 2 ) ) ; var isProd = ( argv . mode || env . mode ) === 'production' || env === 'prod' || env . prod ; return isProd ? 'production' : 'development' ; }", "predicted": "mode", "expected": "argv"}
{"code": "function MouseEdges ( parent , options ) { _classCallCheck ( this , MouseEdges ) ; var <mask> = _possibleConstructorReturn ( this , ( MouseEdges . __proto__ || Object . getPrototypeOf ( MouseEdges ) ) . call ( this , parent ) ) ; options = options || { } ; _this . options = options ; _this . reverse = options . reverse ? 1 : - 1 ; _this . noDecelerate = options . noDecelerate ; _this . linear = options . linear ; _this . radiusSquared = Math . pow ( options . radius , 2 ) ; _this . resize ( ) ; _this . speed = options . speed || 8 ; return _this ; }", "predicted": "options", "expected": "_this"}
{"code": "function Drag ( parent , options ) { _classCallCheck ( this , Drag ) ; options = options || { } ; var <mask> = _possibleConstructorReturn ( this , ( Drag . __proto__ || Object . getPrototypeOf ( Drag ) ) . call ( this , parent ) ) ; _this . moved = false ; _this . wheelActive = utils . defaults ( options . wheel , true ) ; _this . wheelScroll = options . wheelScroll || 1 ; _this . reverse = options . reverse ? 1 : - 1 ; _this . clampWheel = options . clampWheel ; _this . factor = options . factor || 1 ; _this . xDirection = ! options . direction || options . direction === 'all' || options . direction === 'x' ; _this . yDirection = ! options . direction || options . direction === 'all' || options . direction === 'y' ; _this . parseUnderflow ( options . underflow || 'center' ) ; _this . mouseButtons ( options . mouseButtons ) ; return _this ; }", "predicted": "self", "expected": "_this"}
{"code": "function SnapZoom ( parent , options ) { _classCallCheck ( this , SnapZoom ) ; var _this = _possibleConstructorReturn ( this , ( SnapZoom . __proto__ || Object . getPrototypeOf ( SnapZoom ) ) . call ( this , parent ) ) ; options = options || { } ; _this . width = options . width ; _this . height = options . height ; if ( _this . width > 0 ) { _this . <mask> = parent . _screenWidth / _this . width ; } if ( _this . height > 0 ) { _this . y_scale = parent . _screenHeight / _this . height ; } _this . xIndependent = utils . exists ( _this . x_scale ) ; _this . yIndependent = utils . exists ( _this . y_scale ) ; _this . x_scale = _this . xIndependent ? _this . x_scale : _this . y_scale ; _this . y_scale = _this . yIndependent ? _this . y_scale : _this . x_scale ; _this . time = utils . defaults ( options . time , 1000 ) ; _this . ease = utils . ease ( options . ease , 'easeInOutSine' ) ; _this . center = options . center ; _this . noMove = options . noMove ; _this . stopOnResize = options . stopOnResize ; _this . removeOnInterrupt = options . removeOnInterrupt ; _this . removeOnComplete = utils . defaults ( options . removeOnComplete , true ) ; _this . interrupt = utils . defaults ( options . interrupt , true ) ; if ( _this . time === 0 ) { parent . container . scale . x = _this . x_scale ; parent . container . scale . y = _this . y_scale ; if ( _this . removeOnComplete ) { _this . parent . removePlugin ( 'snap-zoom' ) ; } } else if ( options . forceStart ) { _this . createSnapping ( ) ; } return _this ; }", "predicted": "width", "expected": "x_scale"}
{"code": "function Snap ( parent , x , y , options ) { _classCallCheck ( this , Snap ) ; var _this = _possibleConstructorReturn ( this , ( Snap . __proto__ <mask> Object . getPrototypeOf ( Snap ) ) . call ( this , parent ) ) ; options = options || { } ; _this . friction = options . friction || 0.8 ; _this . time = options . time || 1000 ; _this . ease = utils . ease ( options . ease , 'easeInOutSine' ) ; _this . x = x ; _this . y = y ; _this . topLeft = options . topLeft ; _this . interrupt = utils . defaults ( options . interrupt , true ) ; _this . removeOnComplete = options . removeOnComplete ; _this . removeOnInterrupt = options . removeOnInterrupt ; if ( options . forceStart ) { _this . startEase ( ) ; } return _this ; }", "predicted": ")", "expected": "||"}
{"code": "function isPlain ( value ) { return isObject ( value ) && toString . call ( value ) === '[object Object]' && value . constructor === <mask> ; }", "predicted": "value", "expected": "Object"}
{"code": "function addClass ( element , classToAdd ) { if ( element . classList ) { element . classList . add ( classToAdd ) ; // Don't need to `throwIfWhitespace` here because `hasElClass` will do it <mask> } else if ( ! hasClass ( element , classToAdd ) ) { element . className = ( element . className + ' ' + classToAdd ) . trim ( ) ; } return element ; }", "predicted": ";", "expected": "// in the case of classList not being supported."}
{"code": "function getBoundingClientRect ( el ) { if ( el && el <mask> getBoundingClientRect && el . parentNode ) { var rect = el . getBoundingClientRect ( ) ; var result = { } ; [ 'bottom' , 'height' , 'left' , 'right' , 'top' , 'width' ] . forEach ( function ( k ) { if ( rect [ k ] !== undefined ) { result [ k ] = rect [ k ] ; } } ) ; if ( ! result . height ) { result . height = parseFloat ( computedStyle ( el , 'height' ) ) ; } if ( ! result . width ) { result . width = parseFloat ( computedStyle ( el , 'width' ) ) ; } return result ; } }", "predicted": "!==", "expected": "."}
{"code": "function _cleanUpEvents ( elem , type ) { var data = getData ( elem ) ; // Remove the events of a particular type if there are none left if ( data . handlers [ type ] . length === 0 ) { delete data . handlers [ type ] ; // data.handlers[type] = null; // Setting to null was causing an error with data.handlers // Remove the meta-handler from the element if ( elem . removeEventListener ) { elem . removeEventListener ( type , data . dispatcher , false ) ; } else if ( elem . detachEvent ) { elem . detachEvent ( 'on' + type , data . dispatcher ) ; } } // Remove the events object if there are no types left if ( Object . getOwnPropertyNames ( data . handlers ) . length <= 0 ) { delete data . handlers ; delete data . dispatcher ; delete data . disabled ; } // Finally remove the element data if there is no data left if ( Object . getOwnPropertyNames ( data ) . length === 0 ) { <mask> ( elem ) ; } }", "predicted": "delete", "expected": "removeData"}
