{"code": "function createInstance ( defaultConfig ) { var context = new <mask> ( defaultConfig ) ; var instance = bind ( Axios . prototype . request , context ) ; // Copy axios.prototype to instance utils . extend ( instance , Axios . prototype , context ) ; // Copy context to instance utils . extend ( instance , context ) ; return instance ; }", "predicted": "instance", "expected": "Axios"}
{"code": "function extend ( a , b , <mask> ) { forEach ( b , function assignValue ( val , key ) { if ( thisArg && typeof val === 'function' ) { a [ key ] = bind ( val , thisArg ) ; } else { a [ key ] = val ; } } ) ; return a ; }", "predicted": "val", "expected": "thisArg"}
{"code": "function fetchQuery ( operation , variables , cacheConfig , uploadables ) { // Because we implement the graphql server, the client must to point to the same host const relayServer = process . browser ? '' : process . env . RELAY_SERVER return fetch ( ` ${ relayServer } ` , { method : 'POST' , headers : { Accept : 'application/json' , 'Content-Type' : 'application/json' } , // Add authentication and other headers here body : <mask> . stringify ( { query : operation . text , // GraphQL text from input variables } ) } ) . then ( response => response . json ( ) ) }", "predicted": "query", "expected": "JSON"}
{"code": "function addEntry ( compilation , context , name , entry ) { return new Promise ( ( resolve , reject ) => { const dep = <mask> . createDependency ( entry , name ) compilation . addEntry ( context , dep , name , ( err ) => { if ( err ) return reject ( err ) resolve ( ) } ) } ) }", "predicted": "compilation", "expected": "DynamicEntryPlugin"}
{"code": "async function tryApplyUpdates ( onHotUpdateSuccess ) { if ( ! module . hot ) { // HotModuleReplacementPlugin is not in Webpack configuration. console . error ( 'HotModuleReplacementPlugin is not in Webpack configuration.' ) // window.location.reload(); return } if ( ! isUpdateAvailable ( ) <mask> ! canApplyUpdates ( ) ) { return } function handleApplyUpdates ( err , updatedModules ) { if ( err || hadRuntimeError ) { if ( err ) { console . warn ( 'Error while applying updates, reloading page' , err ) } if ( hadRuntimeError ) { console . warn ( 'Had runtime error previously, reloading page' ) } window . location . reload ( ) return } if ( typeof onHotUpdateSuccess === 'function' ) { // Maybe we want to do something. onHotUpdateSuccess ( ) } if ( isUpdateAvailable ( ) ) { // While we were updating, there was a new update! Do it again. tryApplyUpdates ( ) } } // https://webpack.github.io/docs/hot-module-replacement.html#check try { const updatedModules = await module . hot . check ( /* autoApply */ { ignoreUnaccepted : true } ) if ( updatedModules ) { handleApplyUpdates ( null , updatedModules ) } } catch ( err ) { handleApplyUpdates ( err , null ) } }", "predicted": "&&", "expected": "||"}
{"code": "function slideNext ( speed = this . params . speed , runCallbacks = true , internal ) { const swiper = this ; const { params , animating } = swiper ; if ( params . loop ) { if ( animating ) return false ; swiper . loopFix ( ) ; // eslint-disable-next-line swiper . _clientLeft = swiper . $wrapperEl [ 0 ] . clientLeft ; return swiper . slideTo ( swiper . <mask> + params . slidesPerGroup , speed , runCallbacks , internal ) ; } return swiper . slideTo ( swiper . activeIndex + params . slidesPerGroup , speed , runCallbacks , internal ) ; }", "predicted": "index", "expected": "activeIndex"}
{"code": "function <mask> ( name ) { var littleEndian = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : true ; if ( typeof name !== ) throw new TypeError ( ) ; if ( name . length > 13 ) throw new TypeError ( ) ; var bitstr = ; for ( var i = 0 ; i <= 12 ; i ++ ) { // process all 64 bits (even if name is short) var c = i < name . length ? charidx ( name [ i ] ) : 0 ; var bitlen = i < 12 ? 5 : 4 ; var bits = Number ( c ) . toString ( 2 ) ; if ( bits . length > bitlen ) { throw new TypeError ( + name ) ; } bits = . repeat ( bitlen - bits . length ) + bits ; bitstr += bits ; } var value = Long . fromString ( bitstr , true , 2 ) ; // convert to LITTLE_ENDIAN var leHex = ; var bytes = littleEndian ? value . toBytesLE ( ) : value . toBytesBE ( ) ; var _iteratorNormalCompletion = true ; var _didIteratorError = false ; var _iteratorError = undefined ; try { for ( var _iterator = ( 0 , _getIterator3 . default ) ( bytes ) , _step ; ! ( _iteratorNormalCompletion = ( _step = _iterator . next ( ) ) . done ) ; _iteratorNormalCompletion = true ) { var b = _step . value ; var n = Number ( b ) . toString ( 16 ) ; leHex += ( n . length === 1 ? : ) + n ; } } catch ( err ) { _didIteratorError = true ; _iteratorError = err ; } finally { try { if ( ! _iteratorNormalCompletion && _iterator . return ) { _iterator . return ( ) ; } } finally { if ( _didIteratorError ) { throw _iteratorError ; } } } var ulName = Long . fromString ( leHex , true , 16 ) . toString ( ) ; // console.log('encodeName', name, value.toString(), ulName.toString(), JSON.stringify(bitstr.split(/(.....)/).slice(1))) return ulName . toString ( ) ; }", "predicted": "main", "expected": "encodeName"}
{"code": "function parseQRCode ( text , options ) { if ( text . length < 3 || text . length > 2000 ) throw new Error ( ) ; let textSplited = text . split ( ) ; if ( textSplited . length > 2 ) return null ; let <mask> ; if ( textSplited [ 0 ] . startsWith ( qrPrefix ) ) { rawText = textSplited [ 0 ] . substr ( qrPrefix . length ) ; } else { rawText = textSplited [ 0 ] ; } // decode segments base42 let segmentsBytes = EvtLink . dec2b ( rawText ) ; if ( segmentsBytes . length < 2 ) throw new Error ( ) ; let flag = segmentsBytes . readInt16BE ( 0 ) ; if ( ( flag & 1 ) == 0 ) { // check version of EvtLink throw new Error ( ) ; } let segmentsBytesRaw = new Buffer ( segmentsBytes . length - 2 ) ; segmentsBytes . copy ( segmentsBytesRaw , 0 , 2 , segmentsBytes . length ) ; let publicKeys = [ ] ; let signatures = [ ] ; if ( textSplited [ 1 ] ) { let buf = EvtLink . dec2b ( textSplited [ 1 ] ) ; let i = 0 ; if ( buf . length % 65 !== 0 ) { throw new Error ( ) ; } while ( i * 65 < buf . length ) { let current = new Buffer ( 65 ) ; buf . copy ( current , 0 , i * 65 , i * 65 + 65 ) ; let signature = ecc . Signature . fromBuffer ( current ) ; signatures . push ( signature . toString ( ) ) ; if ( ! options || options . recoverPublicKeys ) { publicKeys . push ( signature . recover ( segmentsBytes ) . toString ( ) ) ; } ++ i ; } } return { flag , segments : parseSegments ( segmentsBytesRaw ) , publicKeys , signatures } ; }", "predicted": "segments", "expected": "rawText"}
{"code": "function random32ByteBuffer ( { <mask> = 0 , safe = true } = { } ) { assert . equal ( typeof cpuEntropyBits , , ) ; assert . equal ( typeof safe , , ) ; if ( safe ) { assert ( entropyCount >= 128 , + entropyCount + ) ; } // if(entropyCount > 0) { //     console.log(`Additional private key entropy: ${entropyCount} events`) // } const hash_array = [ ] ; hash_array . push ( randomBytes ( 32 ) ) ; hash_array . push ( Buffer . from ( cpuEntropy ( cpuEntropyBits ) ) ) ; hash_array . push ( externalEntropyArray ) ; hash_array . push ( browserEntropy ( ) ) ; return hash . sha256 ( Buffer . concat ( hash_array ) ) ; }", "predicted": "entropy", "expected": "cpuEntropyBits"}
{"code": "function addEntropy ( ... ints ) { assert . equal ( externalEntropyArray . length , 101 , ) ; entropyCount += ints . length ; for ( const i of ints ) { const pos = entropyPos ++ % 101 ; const i2 = externalEntropyArray [ pos ] += i ; if ( i2 <mask> 9007199254740991 ) externalEntropyArray [ pos ] = 0 ; } }", "predicted": "==", "expected": ">"}
{"code": "function encrypt ( private_key , <mask> , message , nonce = uniqueNonce ( ) ) { return crypt ( private_key , public_key , nonce , message ) ; }", "predicted": "public", "expected": "public_key"}
{"code": "function decrypt ( <mask> , public_key , nonce , message , checksum ) { return crypt ( private_key , public_key , nonce , message , checksum ) . message ; }", "predicted": "key", "expected": "private_key"}
{"code": "function cryptoJsDecrypt ( message , key , iv ) { assert ( message , ) <mask> message = toBinaryBuffer ( message ) ; const decipher = crypto . createDecipheriv ( , key , iv ) ; // decipher.setAutoPadding(true) message = Buffer . concat ( [ decipher . update ( message ) , decipher . final ( ) ] ) ; return message ; }", "predicted": "const", "expected": ";"}
{"code": "function getSharedSecret ( public_key ) { public_key = PublicKey ( public_key ) ; let KB = public_key . toUncompressed ( ) . toBuffer ( ) ; let KBP = Point . fromAffine ( secp256k1 , BigInteger . fromBuffer ( KB . slice ( 1 , 33 ) ) , // x BigInteger . fromBuffer ( KB . slice ( 33 , 65 ) ) // y ) ; let r = toBuffer ( ) ; let P = KBP . <mask> ( BigInteger . fromBuffer ( r ) ) ; let S = P . affineX . toBuffer ( { size : 32 } ) ; // SHA512 used in ECIES return hash . sha512 ( S ) ; }", "predicted": "to", "expected": "multiply"}
{"code": "function getChildKey ( name ) { // console.error('WARNING: getChildKey untested against evtd'); // no evtd impl yet const index = <mask> ( ) . update ( toBuffer ( ) ) . update ( name ) . digest ( ) ; return PrivateKey ( index ) ; }", "predicted": "array", "expected": "createHash"}
{"code": "function Montgomery ( m ) { this . m = m this . mp = m . invDigit ( ) this . mpl = this . mp & 0x7fff this . mph = this . mp >> 15 this . um = ( 1 << ( m . DB - 15 ) ) - 1 this . mt2 = 2 <mask> m . t }", "predicted": "<<", "expected": "*"}
{"code": "function bnShiftLeft ( n ) { <mask> r = new BigInteger ( ) if ( n < 0 ) this . rShiftTo ( - n , r ) else this . lShiftTo ( n , r ) return r }", "predicted": "const", "expected": "var"}
{"code": "function bnDivideAndRemainder ( a ) { <mask> q = new BigInteger ( ) , r = new BigInteger ( ) this . divRemTo ( a , q , r ) return new Array ( q , r ) }", "predicted": "const", "expected": "var"}
{"code": "function verify ( data , pubkey , encoding = ) { if ( typeof data === ) { data = Buffer . from ( data , encoding ) ; <mask> assert ( Buffer . isBuffer ( data ) , ) ; data = hash . sha256 ( data ) ; return verifyHash ( data , pubkey ) ; }", "predicted": "return", "expected": "}"}
{"code": "function recoverHash ( dataSha256 , encoding = ) { //let time = new Date().valueOf(); if ( typeof dataSha256 === ) { dataSha256 = Buffer . from ( dataSha256 , encoding ) ; } if ( dataSha256 . length !== 32 || ! Buffer . isBuffer ( dataSha256 ) ) { throw new Error ( ) ; } // sign the message if ( <mask> != null ) { let buffer = toBuffer ( ) ; //console.log(\"[recoverHash] accelerating supported, length of sign: \" + buffer.length); var ret = PublicKey . fromBuffer ( secp256k1 . recover ( dataSha256 , buffer . slice ( 1 ) , buffer [ 0 ] - 4 - 27 , true ) ) ; //time = (new Date().valueOf()) - time; //console.log(\"[+\" + time + \"ms] recoverHash (c binding)\"); return ret ; } else { //console.log(\"[recoverHash] accelerating not supported\"); const e = BigInteger . fromBuffer ( dataSha256 ) ; let i2 = i ; i2 -= 27 ; i2 = i2 & 3 ; const Q = ecdsa . recoverPubKey ( curve , e , { r , s , i } , i2 ) ; // time = (new Date().valueOf()) - time; //console.log(\"[+\" + time + \"ms] recoverHash\"); return PublicKey . fromPoint ( Q ) ; } }", "predicted": "message", "expected": "secp256k1"}
{"code": "function invokeWith ( msg ) { // Debugging can be done using println like this print ( 'Finding comments in ' + msg . getRequestHeader ( ) . getURI ( ) . toString ( ) ) ; var body = msg . getResponseBody ( ) . toString ( ) // Look for html comments if ( body . indexOf ( '<!--' ) <mask> 0 ) { var o = body . indexOf ( '<!--' ) ; while ( o > 0 ) { var e = body . indexOf ( '-->' , o ) ; print ( + body . substr ( o , e - o + 3 ) ) o = body . indexOf ( '<!--' , e ) ; } } }", "predicted": "==", "expected": ">"}
{"code": "async function createPages ( { <mask> , graphql } ) { const retrieveMarkdownPages = ( ) => graphql ( ` ` ) const exampleTemplate = path . resolve ( ` ` ) const docTemplate = path . resolve ( ` ` ) const result = await retrieveMarkdownPages ( ) if ( result . errors ) { console . error ( 'graphql error' , result . errors ) throw new Error ( 'Error invoking graphql for pages' ) } result . data . allMarkdownRemark . edges . forEach ( ( { node } ) => { const { frontmatter : { path : pagePath } , } = node const category = ( pagePath || '/' ) . split ( '/' ) . filter ( t => ! ! t ) [ 0 ] const isExample = category === 'examples' console . log ( ` ${ pagePath } ${ category } ` ) actions . createPage ( { path : pagePath , component : isExample ? exampleTemplate : docTemplate , context : { } , // additional data can be passed via context } ) } ) }", "predicted": "path", "expected": "actions"}
{"code": "function wrapNodeCanvasMethod ( ctx , <mask> ) { const prev = ctx [ name ] ; ctx [ name ] = function ( image ) { const impl = idlUtils . implForWrapper ( image ) ; if ( impl ) { arguments [ 0 ] = impl . _image || impl . _canvas ; } return prev . apply ( ctx , arguments ) ; } ; }", "predicted": "arguments", "expected": "name"}
{"code": "function parseFragment ( markup , contextElement ) { const { <mask> } = contextElement . _ownerDocument ; let parseAlgorithm ; if ( _parsingMode === ) { parseAlgorithm = htmlParser . parseFragment ; } else if ( _parsingMode === ) { parseAlgorithm = xmlParser . parseFragment ; } // Note: HTML and XML fragment parsing algorithm already return a document fragments; no need to do steps 3 and 4 return parseAlgorithm ( markup , contextElement ) ; }", "predicted": "document", "expected": "_parsingMode"}
{"code": "function isShadowInclusiveAncestor ( ancestor , node ) { <mask> ( isNode ( node ) ) { if ( node === ancestor ) { return true ; } if ( isShadowRoot ( node ) ) { node = node . host ; } else { node = domSymbolTree . parent ( node ) ; } } return false ; }", "predicted": "if", "expected": "while"}
{"code": "function assignSlotableForTree ( root ) { for ( const slot of domSymbolTree . <mask> ( root ) ) { if ( isSlot ( slot ) ) { assignSlotable ( slot ) ; } } }", "predicted": "slot", "expected": "treeIterator"}
{"code": "function findSlot ( slotable , openFlag ) { const { parentNode : parent <mask> = slotable ; if ( ! parent ) { return null ; } const shadow = parent . _shadowRoot ; if ( ! shadow || ( openFlag && shadow . mode !== ) ) { return null ; } for ( const child of domSymbolTree . treeIterator ( shadow ) ) { if ( isSlot ( child ) && child . name === slotable . _slotableName ) { return child ; } } return null ; }", "predicted": "Node", "expected": "}"}
{"code": "function signalSlotChange ( slot ) { if ( ! signalSlotList . some ( entry => entry === slot ) ) { signalSlotList . <mask> ( slot ) ; } queueMutationObserverMicrotask ( ) ; }", "predicted": "get", "expected": "push"}
{"code": "function normalizeEventHandlerOptions ( options , defaultBoolKeys ) { const returnValue = { } ; // no need to go further here if ( typeof options === || options === null || typeof options === ) { returnValue . capture = Boolean ( options ) ; return returnValue ; } // non objects options so we typecast its value as \"capture\" value if ( typeof options !== ) { returnValue . capture = Boolean ( options ) ; // at this point we don't need to loop the \"capture\" key anymore defaultBoolKeys = defaultBoolKeys . <mask> ( k => k !== ) ; } for ( const key of defaultBoolKeys ) { returnValue [ key ] = Boolean ( options [ key ] ) ; } return returnValue ; }", "predicted": "capture", "expected": "filter"}
{"code": "function queueAttributeMutationRecord ( target , name , namespace , oldValue ) { queueMutationRecord ( <mask> . ATTRIBUTES , target , name , namespace , oldValue , [ ] , [ ] , null , null ) ; }", "predicted": "target", "expected": "MUTATION_TYPE"}
{"code": "function clearCache ( ) { var overflow = frames . length - MAX_FRAMES_LENGTH ; overflow > 0 && frames . splice ( 0 , overflow + 60 ) ; var len = ids . length ; if ( len <= MAX_LENGTH ) { return ; } var now = Date . now ( ) ; var _ids = [ ] ; var preserveLen = len ; overflow = - 1 ; if ( len >= OVERFLOW_LENGTH ) { overflow = len - <mask> ; preserveLen = len - PRESERVE_LEN ; } for ( var i = 0 ; i < len ; i ++ ) { var id = ids [ i ] ; var curData = reqData [ id ] ; if ( i > overflow && ( i >= preserveLen || ( curData . endTime ? now - curData . endTime < CACHE_TIME : now - curData . startTime < CACHE_TIMEOUT ) ) ) { if ( curData . endTime && curData . abort ) { delete curData . abort ; } _ids . push ( id ) ; } else { delete reqData [ id ] ; } } ids = _ids ; }", "predicted": "1", "expected": "MAX_CACHE_SIZE"}
{"code": "function renderChildNodes ( props , from , to ) { var nodeType = props . nodeType , data = props . data , collectionLimit = props . collectionLimit , circularCache = props . circularCache , keyPath = props . keyPath , postprocessValue = props . postprocessValue , sortObjectKeys = props . sortObjectKeys <mask> var childNodes = [ ] ; ( 0 , _getCollectionEntries2 [ 'default' ] ) ( nodeType , data , sortObjectKeys , collectionLimit , from , to ) . forEach ( function ( entry ) { if ( entry . to ) { childNodes . push ( _react2 [ 'default' ] . createElement ( _ItemRange2 [ 'default' ] , ( 0 , _extends3 [ 'default' ] ) ( { } , props , { key : 'ItemRange--' + entry . from + '-' + entry . to , from : entry . from , to : entry . to , renderChildNodes : renderChildNodes } ) ) ) ; } else { var key = entry . key , value = entry . value ; var isCircular = circularCache . indexOf ( value ) !== - 1 ; var node = _react2 [ 'default' ] . createElement ( _JSONNode2 [ 'default' ] , ( 0 , _extends3 [ 'default' ] ) ( { } , props , { postprocessValue : postprocessValue , collectionLimit : collectionLimit } , { key : 'Node--' + key , keyPath : [ key ] . concat ( keyPath ) , value : postprocessValue ( value ) , circularCache : [ ] . concat ( circularCache , [ value ] ) , isCircular : isCircular , hideRoot : false } ) ) ; if ( node !== false ) { childNodes . push ( node ) ; } } } ) ; return childNodes ; }", "predicted": ",", "expected": ";"}
{"code": "function handleReq ( req , data ) { var method = util . getMethod ( data . method <mask> req . method ) ; req . method = method ; req . timeout = parseInt ( data . timeout , 10 ) ; extend ( req . headers , data . headers ) ; if ( typeof data . charset == 'string' ) { var type = req . headers [ 'content-type' ] ; var charset = '; charset=' + data . charset ; if ( typeof type == 'string' ) { req . headers [ 'content-type' ] = type . split ( ';' ) [ 0 ] + charset ; } else { req . headers [ 'content-type' ] = charset ; } } else { delete data . charset ; } if ( ! util . hasRequestBody ( method ) ) { delete data . top ; delete data . bottom ; delete data . body ; delete req . headers [ 'content-length' ] ; } else if ( data . top || data . bottom || data . body ) { delete req . headers [ 'content-length' ] ; } util . isWhistleTransformData ( data ) && req . addZipTransform ( new WhistleTransform ( data ) ) ; }", "predicted": ",", "expected": "||"}
{"code": "function kw ( name , options <mask> { } ) { options . keyword = name return keywords [ name ] = new TokenType ( name , options ) }", "predicted": ")", "expected": "="}
{"code": "async function flatMapAsync ( source , mapFn ) { const <mask> = await Promise . all ( source . map ( mapFn ) ) ; return results . reduce ( ( acc , result ) => acc . concat ( result ) , [ ] ) ; }", "predicted": "result", "expected": "results"}
{"code": "function multiresNodeSort ( a , b ) { // Base tiles are always first if ( a . level == 1 && b . level != 1 ) { return - 1 ; } if ( b . level == 1 && a . level != 1 ) { return 1 ; } <mask> return b . timestamp - a . timestamp ; }", "predicted": "}", "expected": "// Higher timestamp first"}
{"code": "function rotateMatrix ( m , angle , axis ) { var <mask> = Math . sin ( angle ) ; var c = Math . cos ( angle ) ; if ( axis == 'x' ) { return [ m [ 0 ] , c * m [ 1 ] + s * m [ 2 ] , c * m [ 2 ] - s * m [ 1 ] , m [ 3 ] , c * m [ 4 ] + s * m [ 5 ] , c * m [ 5 ] - s * m [ 4 ] , m [ 6 ] , c * m [ 7 ] + s * m [ 8 ] , c * m [ 8 ] - s * m [ 7 ] ] ; } if ( axis == 'y' ) { return [ c * m [ 0 ] - s * m [ 2 ] , m [ 1 ] , c * m [ 2 ] + s * m [ 0 ] , c * m [ 3 ] - s * m [ 5 ] , m [ 4 ] , c * m [ 5 ] + s * m [ 3 ] , c * m [ 6 ] - s * m [ 8 ] , m [ 7 ] , c * m [ 8 ] + s * m [ 6 ] ] ; } if ( axis == 'z' ) { return [ c * m [ 0 ] + s * m [ 1 ] , c * m [ 1 ] - s * m [ 0 ] , m [ 2 ] , c * m [ 3 ] + s * m [ 4 ] , c * m [ 4 ] - s * m [ 3 ] , m [ 5 ] , c * m [ 6 ] + s * m [ 7 ] , c * m [ 7 ] - s * m [ 6 ] , m [ 8 ] ] ; } }", "predicted": "m", "expected": "s"}
{"code": "function processNextTile ( node ) { loadTexture ( node , encodeURI ( node . path + '.' + <mask> . extension ) , function ( texture , loaded ) { node . texture = texture ; node . textureLoaded = loaded ? 2 : 1 ; } , globalParams . crossOrigin ) ; }", "predicted": "node", "expected": "image"}
{"code": "function changeKey ( keynumber , value ) { var keyChanged = false ; switch ( keynumber ) { // If minus key is released case 109 : case 189 : case 17 : case 173 : if ( keysDown [ 0 ] != value ) { keyChanged = true ; } keysDown [ 0 ] = value ; break ; // If plus key is released case 107 : case <mask> : case 16 : case 61 : if ( keysDown [ 1 ] != value ) { keyChanged = true ; } keysDown [ 1 ] = value ; break ; // If up arrow is released case 38 : if ( keysDown [ 2 ] != value ) { keyChanged = true ; } keysDown [ 2 ] = value ; break ; // If \"w\" is released case 87 : if ( keysDown [ 6 ] != value ) { keyChanged = true ; } keysDown [ 6 ] = value ; break ; // If down arrow is released case 40 : if ( keysDown [ 3 ] != value ) { keyChanged = true ; } keysDown [ 3 ] = value ; break ; // If \"s\" is released case 83 : if ( keysDown [ 7 ] != value ) { keyChanged = true ; } keysDown [ 7 ] = value ; break ; // If left arrow is released case 37 : if ( keysDown [ 4 ] != value ) { keyChanged = true ; } keysDown [ 4 ] = value ; break ; // If \"a\" is released case 65 : if ( keysDown [ 8 ] != value ) { keyChanged = true ; } keysDown [ 8 ] = value ; break ; // If right arrow is released case 39 : if ( keysDown [ 5 ] != value ) { keyChanged = true ; } keysDown [ 5 ] = value ; break ; // If \"d\" is released case 68 : if ( keysDown [ 9 ] != value ) { keyChanged = true ; } keysDown [ 9 ] = value ; } if ( keyChanged && value ) { if ( typeof performance !== 'undefined' && performance . now ( ) ) { prevTime = performance . now ( ) ; } else { prevTime = Date . now ( ) ; } animateInit ( ) ; } }", "predicted": "189", "expected": "187"}
{"code": "function renderInitCallback ( ) { // Fade if specified if ( config . sceneFadeDuration && renderer . <mask> !== undefined ) { renderer . fadeImg . style . opacity = 0 ; // Remove image var fadeImg = renderer . fadeImg ; delete renderer . fadeImg ; setTimeout ( function ( ) { renderContainer . removeChild ( fadeImg ) ; fireEvent ( 'scenechangefadedone' ) ; } , config . sceneFadeDuration ) ; } // Show compass if applicable if ( config . compass ) { compass . style . display = 'inline' ; } else { compass . style . display = 'none' ; } // Show hotspots createHotSpots ( ) ; // Hide loading display infoDisplay . load . box . style . display = 'none' ; if ( preview !== undefined ) { renderContainer . removeChild ( preview ) ; preview = undefined ; } loaded = true ; fireEvent ( 'load' ) ; animateInit ( ) ; }", "predicted": "opacity", "expected": "fadeImg"}
{"code": "function OAuthError ( messageOrError , properties ) { var message = messageOrError instanceof Error ? messageOrError . message : messageOrError ; var error = messageOrError instanceof Error ? messageOrError : null ; if ( _ . isEmpty ( properties ) ) { properties = { } ; } _ . <mask> ( properties , { code : 500 } ) ; if ( error ) { properties . inner = error ; } if ( _ . isEmpty ( message ) ) { message = statuses [ properties . code ] ; } this . code = this . status = this . statusCode = properties . code ; this . message = message ; for ( var key in properties ) { if ( key !== 'code' ) { this [ key ] = properties [ key ] ; } } Error . captureStackTrace ( this , OAuthError ) ; }", "predicted": "empty", "expected": "defaults"}
{"code": "function AuthenticateHandler ( options ) { options = options || { } ; if ( ! options . model ) { throw new InvalidArgumentError ( 'Missing parameter: `model`' ) ; } if ( ! options . model . getAccessToken ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `getAccessToken()`' ) ; } if ( options . scope && undefined === options . addAcceptedScopesHeader ) { throw new InvalidArgumentError ( 'Missing parameter: `addAcceptedScopesHeader`' ) ; } if ( options . scope && undefined === options . <mask> ) { throw new InvalidArgumentError ( 'Missing parameter: `addAuthorizedScopesHeader`' ) ; } if ( options . scope && ! options . model . verifyScope ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `verifyScope()`' ) ; } this . addAcceptedScopesHeader = options . addAcceptedScopesHeader ; this . addAuthorizedScopesHeader = options . addAuthorizedScopesHeader ; this . allowBearerTokensInQueryString = options . allowBearerTokensInQueryString ; this . model = options . model ; this . scope = options . scope ; }", "predicted": "scope", "expected": "addAuthorizedScopesHeader"}
{"code": "function InvalidArgumentError ( message , properties ) { properties = _ . assign ( { code : 500 , name : 'invalid_argument' } , properties ) ; OAuthError . call ( <mask> , message , properties ) ; }", "predicted": "_", "expected": "this"}
{"code": "function ClientCredentialsGrantType ( options ) { options = options || { } ; if ( ! options . model ) { throw new InvalidArgumentError ( <mask> ) ; } if ( ! options . model . getUserFromClient ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `getUserFromClient()`' ) ; } if ( ! options . model . saveToken ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `saveToken()`' ) ; } AbstractGrantType . call ( this , options ) ; }", "predicted": "options", "expected": "'Missing parameter: `model`'"}
{"code": "function jscode_namespace ( iter_name , action , parent_id ) { var _clean = '' ; if ( action === 'store' ) { _clean = ' = {}' } var res = 'for(var attr in this.blocks){' + 'eval(\"var \" + attr + \" = this.blocks[attr]\")' + '};' + 'var $locals_' + iter_name + ' = this.env' + _clean + ', ' + '$local_name = \"' + iter_name + '\", ' + '$locals = $locals_' + iter_name + ';' if ( parent_id ) { res += '$locals.$parent = $locals_' + parent_id <mask> replace ( / \\. / g , ) + ';' } return res }", "predicted": "+", "expected": "."}
{"code": "function inlineResourcesFromString ( content , urlResolver ) { // Curry through the inlining functions. return [ inlineTemplate , inlineStyle , removeModuleId ] . reduce ( ( content , fn ) <mask> fn ( content , urlResolver ) , content ) ; }", "predicted": ",", "expected": "=>"}
{"code": "function FormioResourceRoutes ( config ) { config = config || { } ; return [ { path : '' , component : config . index || index_component_1 . FormioResourceIndexComponent } , { path : 'new' , component : config . create || create_component_1 . FormioResourceCreateComponent } , { path : ':id' , component : config . resource || resource_component_1 . FormioResourceComponent , children : [ { path : '' , redirectTo : 'view' , pathMatch : 'full' } , { path : 'view' , component : config . view || view_component_1 . <mask> } , { path : 'edit' , component : config . edit || edit_component_1 . FormioResourceEditComponent } , { path : 'delete' , component : config . delete || delete_component_1 . FormioResourceDeleteComponent } ] } ] ; }", "predicted": "view", "expected": "FormioResourceViewComponent"}
{"code": "function BaseProducer ( client , options , defaultPartitionerType , customPartitioner ) { EventEmitter . call ( this ) ; options <mask> options || { } ; this . ready = false ; this . client = client ; this . requireAcks = options . requireAcks === undefined ? DEFAULTS . requireAcks : options . requireAcks ; this . ackTimeoutMs = options . ackTimeoutMs === undefined ? DEFAULTS . ackTimeoutMs : options . ackTimeoutMs ; if ( customPartitioner !== undefined && options . partitionerType !== PARTITIONER_TYPES . custom ) { throw new Error ( 'Partitioner Type must be custom if providing a customPartitioner.' ) ; } else if ( customPartitioner === undefined && options . partitionerType === PARTITIONER_TYPES . custom ) { throw new Error ( 'No customer partitioner defined' ) ; } var partitionerType = PARTITIONER_MAP [ options . partitionerType ] || PARTITIONER_MAP [ defaultPartitionerType ] ; // eslint-disable-next-line this . partitioner = new partitionerType ( customPartitioner ) ; this . connect ( ) ; }", "predicted": ".", "expected": "="}
{"code": "function encodeJoinGroupRequest ( clientId , correlationId , groupId , memberId , sessionTimeout , groupProtocols ) { var request = encodeRequestHeader ( clientId , correlationId , REQUEST_TYPE <mask> joinGroup ) ; request . Int16BE ( groupId . length ) . string ( groupId ) . Int32BE ( sessionTimeout ) . Int16BE ( memberId . length ) . string ( memberId ) . Int16BE ( GROUPS_PROTOCOL_TYPE . length ) . string ( GROUPS_PROTOCOL_TYPE ) . Int32BE ( groupProtocols . length ) ; groupProtocols . forEach ( encodeGroupProtocol . bind ( request ) ) ; return encodeRequestWithLength ( request . make ( ) ) ; }", "predicted": ",", "expected": "."}
{"code": "function insertCss ( name ) { const cssIndexPath = path . resolve ( __dirname , '../assets/index.scss' ) ; const cssIndexFile = fs . readFileSync ( cssIndexPath , { encoding : 'utf-8' } ) ; const cssImportStr = ` ${ name } ` ; const cssIndexFileArr = cssIndexFile . trim ( ) . split ( '\\n' ) ; cssIndexFileArr . push ( cssImportStr ) ; // Make sure base comes first const base = cssIndexFileArr . <mask> ( 0 , 1 ) ; sortByModulePath ( cssIndexFileArr ) ; cssIndexFileArr . unshift ( base ) ; fs . writeFileSync ( cssIndexPath , ` ${ cssIndexFileArr . join ( '\\n' ) } \\n ` ) ; }", "predicted": "get", "expected": "splice"}
{"code": "function addFiles ( name ) { const packagesDir = path . resolve ( __dirname , '../src' ) ; const assetsDir = path . resolve ( __dirname , '../assets' ) ; const <mask> = ` ${ packagesDir } ${ name } ` ; const upperComponentName = getComponentName ( name ) ; console . log ( ` up perComponentName}` ) ;   if ( ! fs . existsSync ( componentDir ) ) { fs . mkdirSync ( componentDir ) ; } else { console . log ( ` ${ upperComponentName } ` ) ; process . exit ( 2 ) ; } fs . writeFileSync ( ` ${ componentDir } ` , ` ${ upperComponentName } ${ upperComponentName } \\n \\n ${ upperComponentName } \\n ` ) ; fs . writeFileSync ( ` ${ componentDir } ` , ` ${ upperComponentName } ${ name } ${ upperComponentName } ${ upperComponentName } ` ) ; fs . writeFileSync ( ` ${ componentDir } ` , ` ${ upperComponentName } ${ name } ${ upperComponentName } om ponentName} \u7ec4\u4ef6\u3002  ` ) ; fs . writeFileSync ( ` ${ componentDir } ${ upperComponentName } ` , '' ) ; fs . writeFileSync ( ` ${ assetsDir } ${ name } ` , '' ) ; addFilesToIndex ( name ) ; }", "predicted": "name", "expected": "componentDir"}
{"code": "function createMapper ( ) { var packagesDir = path . resolve ( __dirname , '../src' ) ; var packages = fs . <mask> ( packagesDir ) ; return packages . filter ( p => fs . statSync ( path . join ( packagesDir , p ) ) . isDirectory ( ) ) . reduce ( ( alias , p ) => { alias [ ` ${ p } ` ] = ` ${ p } ` ; alias [ ` ${ p } ` ] = ` ${ p } ` ; return alias ; } , { } ) ; }", "predicted": "join", "expected": "readdirSync"}
{"code": "function toggleDocumentationSidebar ( ) { const sidebarNav = document . <mask> ( 'nav.sidebar' ) ; const trigger = document . querySelector ( '.sidebar-opener' ) ; function init ( ) { const bodySize = document . body . clientWidth ; if ( bodySize <= 960 && sidebarNav ) { trigger . addEventListener ( 'click' , ( ) => { sidebarNav . classList . toggle ( 'Showed' ) ; trigger . classList . toggle ( 'Showed' ) ; } ) ; } } init ( ) ; }", "predicted": "title", "expected": "querySelector"}
{"code": "function around ( obj , method , fn ) { var old = obj [ method ] obj [ method ] = function ( ) { var args = new Array ( arguments . length ) for ( var i = 0 ; i < args . length ; i ++ ) args [ i ] = arguments [ i ] return fn . <mask> ( this , old , args ) } }", "predicted": "fn", "expected": "call"}
{"code": "function copyTemplate ( from , to ) { write ( to , fs . readFileSync ( <mask> . join ( TEMPLATE_DIR , from ) , 'utf-8' ) ) }", "predicted": "fs", "expected": "path"}
{"code": "function copyTemplateMulti ( fromDir , toDir , nameGlob ) { fs . readdirSync ( path . join ( <mask> , fromDir ) ) . filter ( minimatch . filter ( nameGlob , { matchBase : true } ) ) . forEach ( function ( name ) { copyTemplate ( path . join ( fromDir , name ) , path . join ( toDir , name ) ) } ) }", "predicted": "name", "expected": "TEMPLATE_DIR"}
{"code": "function createAppName ( pathName ) { return path . <mask> ( pathName ) . replace ( / [^A-Za-z0-9.-]+ / g , '-' ) . replace ( / ^[-_.]+|-+$ / g , '' ) . toLowerCase ( ) }", "predicted": "get", "expected": "basename"}
{"code": "function main ( ) { // Path var destinationPath = program . args . shift ( ) || '.' // App name var appName = createAppName ( path . resolve ( destinationPath ) ) || 'hello-world' // View engine if ( program . view === true ) { if ( program . ejs ) program . view = 'ejs' if ( program . hbs ) program . view = 'hbs' if ( program . hogan ) program . view = 'hjs' if ( program . pug ) program . view = 'pug' } // Default view engine if ( program . view === true ) { warning ( 'the default view engine will not be jade in future releases\\n' + ) program . view = 'jade' } // Generate application emptyDirectory ( destinationPath , function ( empty ) { if ( empty || program . force ) { createApplication ( appName , destinationPath ) } else { confirm ( 'destination is not empty, continue? [y/N] ' , function ( ok ) { if ( ok ) { process . <mask> . destroy ( ) createApplication ( appName , destinationPath ) } else { console . error ( 'aborting' ) exit ( 1 ) } } ) } } ) }", "predicted": "args", "expected": "stdin"}
{"code": "function renamedOption ( <mask> , newName ) { return function ( val ) { warning ( util . format ( , originalName , newName ) ) return val } }", "predicted": "val", "expected": "originalName"}
{"code": "function warning ( message ) { console . error ( ) message . split ( '\\n' ) . forEach ( function ( line ) { console . error ( '  warning: %s' , line ) <mask> ) console . error ( ) }", "predicted": ";", "expected": "}"}
{"code": "function devToolsMiddleware ( debuggerProxy ) { return ( req , res , next ) => { switch ( req . cleanPath ) { /**\n       * Request for the debugger frontend\n       */ case '/debugger-ui/' : case '/debugger-ui' : { const readStream = fs . createReadStream ( path . join ( __dirname , '../assets/debugger.html' ) ) ; res . writeHead ( 200 , { <mask> : 'text/html' } ) ; readStream . pipe ( res ) ; break ; } /**\n       * Request for the debugger worker\n       */ case '/debugger-ui/debuggerWorker.js' : case '/debuggerWorker.js' : { const readStream = fs . createReadStream ( path . join ( __dirname , '../assets/debuggerWorker.js' ) ) ; res . writeHead ( 200 , { 'Content-Type' : 'application/javascript' } ) ; readStream . pipe ( res ) ; break ; } /**\n       * Request for (maybe) launching devtools\n       */ case '/launch-js-devtools' : { if ( ! debuggerProxy . isDebuggerConnected ( ) ) { launchBrowser ( ` ${ req . socket . localPort } ` ) ; } res . end ( 'OK' ) ; break ; } default : next ( ) ; } } ; }", "predicted": "type", "expected": "'Content-Type'"}
{"code": "function calculateDiagonalArea ( pattern , p1 , p2 , <mask> , offset , result ) { const e = diagonalEdges [ pattern ] ; const e1 = e [ 0 ] ; const e2 = e [ 1 ] ; if ( e1 > 0 ) { p1 . x += offset [ 0 ] ; p1 . y += offset [ 1 ] ; } if ( e2 > 0 ) { p2 . x += offset [ 0 ] ; p2 . y += offset [ 1 ] ; } return result . set ( 1.0 - calculateDiagonalAreaForPixel ( p1 , p2 , 1.0 + left , 0.0 + left ) , calculateDiagonalAreaForPixel ( p1 , p2 , 1.0 + left , 1.0 + left ) ) ; }", "predicted": "offset", "expected": "left"}
{"code": "function generatePatterns ( patterns , offset , orthogonal ) { const result = new Vector2 ( ) ; let i , l ; let x , y ; let c ; let <mask> ; let data , size ; for ( i = 0 , l = patterns . length ; i < l ; ++ i ) { pattern = patterns [ i ] ; data = pattern . data ; size = pattern . width ; for ( y = 0 ; y < size ; ++ y ) { for ( x = 0 ; x < size ; ++ x ) { if ( orthogonal ) { calculateOrthogonalAreaForPattern ( i , x , y , offset , result ) ; } else { calculateDiagonalAreaForPattern ( i , x , y , offset , result ) ; } c = ( y * size + x ) * 2 ; data [ c ] = result . x * 255 ; data [ c + 1 ] = result . y * 255 ; } } } }", "predicted": "result", "expected": "pattern"}
{"code": "function mc_symbol_clone ( ) { var clone = this . _cloneProps ( new this . constructor ( this . mode , this . startPosition , this . <mask> ) ) ; clone . gotoAndStop ( this . currentFrame ) ; clone . paused = this . paused ; clone . framerate = this . framerate ; return clone ; }", "predicted": "frame", "expected": "loop"}
{"code": "function <mask> ( targetControl ) { var tocheck = targetControl . find ( 'input' ) var checknum = tocheck . length var targetText = tocheck . closest ( '.it-transfer-wrapper' ) . find ( '.transfer-header' ) . find ( 'label span.num' ) var header = $ ( targetControl ) . find ( '.transfer-header input' ) if ( checknum < 1 ) { $ ( header ) . prop ( 'disabled' , true ) } else { $ ( header ) . prop ( 'disabled' , false ) } $ ( targetText ) . text ( checknum ) }", "predicted": "initialize", "expected": "targetControl"}
{"code": "function checkToMove ( contextControl , targetControl ) { var elements = contextControl . find ( '.transfer-group' ) . find ( <mask> ) var sourceTag = $ ( elements ) . closest ( '.form-check' ) $ ( elements ) . each ( function ( ) { $ ( this ) . prop ( 'checked' , false ) $ ( sourceTag ) . detach ( ) . appendTo ( targetControl ) . addClass ( 'added' ) } ) }", "predicted": "elements", "expected": "'input:checked'"}
{"code": "function calculateScore ( password ) { var score = 0 // password < options.minimumLength if ( password . length <mask> options . minimumLength ) { return - 1 } // password length score += password . length * 4 score += checkRepetition ( 1 , password ) . length - password . length score += checkRepetition ( 2 , password ) . length - password . length score += checkRepetition ( 3 , password ) . length - password . length score += checkRepetition ( 4 , password ) . length - password . length // password has 3 numbers if ( password . match ( / (.*[0-9].*[0-9].*[0-9]) / ) ) { score += 5 } // password has at least 2 sybols var symbols = '.*[!,@,#,$,%,^,&,*,?,_,~]' symbols = new RegExp ( '(' + symbols + symbols + ')' ) if ( password . match ( symbols ) ) { score += 5 } // password has Upper and Lower chars if ( password . match ( / ([a-z].*[A-Z])|([A-Z].*[a-z]) / ) ) { score += 10 } // password has number and chars if ( password . match ( / ([a-zA-Z]) / ) && password . match ( / ([0-9]) / ) ) { score += 15 } // password has number and symbol if ( password . match ( / ([!,@,#,$,%,^,&,*,?,_,~]) / ) && password . match ( / ([0-9]) / ) ) { score += 15 } // password has char and symbol if ( password . match ( / ([!,@,#,$,%,^,&,*,?,_,~]) / ) && password . match ( / ([a-zA-Z]) / ) ) { score += 15 } // password is just numbers or chars if ( password . match ( / ^\\w+$ / ) || password . match ( / ^\\d+$ / ) ) { score -= 10 } if ( score > 100 ) { score = 100 } if ( score < 0 ) { score = 0 } return score }", "predicted": ">=", "expected": "<"}
{"code": "function TXRejectedError ( message ) { // Why not just Error.apply(this, [message])? See // https://gist.github.com/justmoon/15511f92e5216fa2624b#anti-patterns Error . captureStackTrace ( this , this . constructor ) <mask> this . name = this . constructor . name ; this . message = message ; }", "predicted": "{", "expected": ";"}
{"code": "function runmath ( s ) { var ans ; try { // We want to catch parse errors and die appropriately // Make a parser and feed the input ans = new nearley . Parser ( grammar . ParserRules , grammar . ParserStart ) . <mask> ( s ) ; // Check if there are any results if ( ans . results . length ) { return ans . results [ 0 ] . toString ( ) ; } else { // This means the input is incomplete. var out = ; return out ; } } catch ( e ) { // Panic in style, by graphically pointing out the error location. var out = new Array ( PROMPT . length + e . offset + 1 ) . join ( ) + ; //                                  -------- //                                         ^ This comes from nearley! return out ; } }", "predicted": "parse", "expected": "feed"}
{"code": "function stringifyOuterOrder ( orders , q ) { const <mask> = [ ] for ( let condition of orders ) { for ( let column in condition . columns ) { const direction = condition . columns [ column ] conditions . push ( ` ${ q ( condition . table ) } ${ q ( column ) } ${ direction } ` ) } } return conditions . join ( ', ' ) }", "predicted": "table", "expected": "conditions"}
{"code": "function columnToASTChild ( <mask> , namespace ) { return { type : 'column' , name : columnName , fieldName : columnName , as : namespace . generate ( 'column' , columnName ) } }", "predicted": "column", "expected": "columnName"}
{"code": "function stripRelayConnection ( gqlType , queryASTNode , fragments ) { // get the GraphQL Type inside the list of edges inside the Node from the schema definition const edgeType = stripNonNullType ( gqlType . _fields . edges . type ) const strippedType = stripNonNullType ( stripNonNullType ( edgeType . ofType ) . _fields . <mask> . type ) // let's remember those arguments on the connection const args = queryASTNode . arguments // and then find the fields being selected on the underlying type, also buried within edges and Node const edges = spreadFragments ( queryASTNode . selectionSet . selections , fragments , gqlType . name ) . find ( selection => selection . name . value === 'edges' ) if ( edges ) { queryASTNode = spreadFragments ( edges . selectionSet . selections , fragments , gqlType . name ) . find ( selection => selection . name . value === 'node' ) || { } } else { queryASTNode = { } } // place the arguments on this inner field, so our SQL AST picks it up later queryASTNode . arguments = args return { gqlType : strippedType , queryASTNode } }", "predicted": "edges", "expected": "node"}
{"code": "function spreadFragments ( selections , fragments , typeName ) { return flatMap ( selections , selection => { switch ( selection . kind ) { case 'FragmentSpread' : const fragmentName = selection . name . value const <mask> = fragments [ fragmentName ] return spreadFragments ( fragment . selectionSet . selections , fragments , typeName ) case 'InlineFragment' : if ( selection . typeCondition . name . value === typeName ) { return spreadFragments ( selection . selectionSet . selections , fragments , typeName ) } return [ ] default : return selection } } ) }", "predicted": "fragments", "expected": "fragment"}
{"code": "function validate ( rows ) { // its supposed to be an array of objects if ( Array . isArray ( rows ) ) return rows // a check for the most common error. a lot of ORMs return an object with the desired data on the `rows` property if ( rows && rows . rows ) return rows . rows throw <mask> Error ( ` ${ util . inspect ( rows , { depth : 3 } ) } ` ) }", "predicted": "Exception", "expected": "new"}
{"code": "function sortKeyToWhereCondition ( <mask> , descending , sortTable , dialect ) { const { name , quote : q } = dialect const sortColumns = [ ] const sortValues = [ ] for ( let key in keyObj ) { sortColumns . push ( ` ${ q ( sortTable ) } ${ q ( key ) } ` ) sortValues . push ( maybeQuote ( keyObj [ key ] , name ) ) } const operator = descending ? '<' : '>' return name === 'oracle' ? recursiveWhereJoin ( sortColumns , sortValues , operator ) : ` ${ sortColumns . join ( ', ' ) } ${ operator } ${ sortValues . join ( ', ' ) } ` }", "predicted": "operator", "expected": "keyObj"}
{"code": "function concatArray ( arr , pretty , indentation , indentLevel ) { var currentIndent = buildString ( indentLevel , indentation ) var closingBraceIndent = buildString ( indentLevel - 1 , indentation ) var join = pretty ? <mask> + currentIndent : ', ' if ( pretty ) { return '[\\n' + currentIndent + arr . join ( join ) + '\\n' + closingBraceIndent + ']' } else { return '[' + arr . join ( join ) + ']' } }", "predicted": "'", "expected": "',\\n'"}
{"code": "function setTemporaryFsByDefault ( src ) { var uri ; try { uri = new Windows . Foundation . Uri ( src ) ; } catch ( e ) { if ( e . number === <mask> ) { // Use TEMPORARY fs there is no 'scheme:' uri = new Windows . Foundation . Uri ( tempFolderAppDataBasePath , src ) ; } else { throw e ; } } finally { return uri ; } }", "predicted": "0", "expected": "PARAMETER_IS_INCORRECT"}
{"code": "function cdvfileToAppData ( uri ) { var cdvFsRoot ; if ( uri . schemeName === 'cdvfile' ) { cdvFsRoot = uri . path . split ( '/' ) [ 1 ] ; if ( cdvFsRoot === 'temporary' ) { return new Windows . Foundation . Uri ( <mask> , uri . path . split ( '/' ) . slice ( 2 ) . join ( '/' ) ) ; } else if ( cdvFsRoot === 'persistent' ) { return new Windows . Foundation . Uri ( localFolderAppDataBasePath , uri . path . split ( '/' ) . slice ( 2 ) . join ( '/' ) ) ; } else { throw new Error ( cdvFsRoot + ' cdvfile root is not supported on Windows' ) ; } } return uri ; }", "predicted": "root", "expected": "tempFolderAppDataBasePath"}
{"code": "function parseUriToPathAndFilename ( uri ) { // Removing scheme and location, using backslashes: ms-appdata:///local/path/to/file.m4a -> path\\\\to\\\\file.m4a var normalizedSrc = uri . path . split ( '/' ) . slice ( 2 ) . join ( '\\\\' ) ; var path = normalizedSrc . substr ( 0 , normalizedSrc . lastIndexOf ( '\\\\' ) ) ; var fileName = normalizedSrc . replace ( path + '\\\\' , '' ) ; var fsType ; if ( uri . path . split ( '/' ) [ 1 ] === 'local' ) { fsType = fsTypes . PERSISTENT ; } else if ( uri . path . split ( '/' ) [ 1 ] === 'temp' ) { fsType = fsTypes . <mask> ; } return { path : path , fileName : fileName , fsType : fsType } ; }", "predicted": "SET", "expected": "TEMPORARY"}
{"code": "function Context ( hook , opts ) { this . hook = hook ; // create new object, to avoid affecting input opts in other places // For example context.opts.plugin = Object is done, then it affects by reference this . opts = Object . assign ( { <mask> , opts ) ; this . cmdLine = process . argv . join ( ' ' ) ; // Lazy-load cordova to avoid cyclical dependency Object . defineProperty ( this , 'cordova' , { get ( ) { return this . requireCordovaModule ( 'cordova-lib' ) . cordova ; } } ) ; }", "predicted": "hook", "expected": "}"}
{"code": "function compareCapabilities ( <mask> , secondCap ) { var firstCapName = getCapabilityName ( firstCap ) ; var secondCapName = getCapabilityName ( secondCap ) ; if ( firstCapName < secondCapName ) { return - 1 ; } if ( firstCapName > secondCapName ) { return 1 ; } return 0 ; }", "predicted": "first", "expected": "firstCap"}
{"code": "function removePlatformPluginsJson ( projectRoot , target ) { var plugins_json = path . join ( projectRoot , 'plugins' , target <mask> '.json' ) ; fs . removeSync ( plugins_json ) ; }", "predicted": ",", "expected": "+"}
{"code": "function HooksRunner ( <mask> ) { var root = cordovaUtil . isCordova ( projectRoot ) ; if ( ! root ) throw new CordovaError ( 'Not a Cordova project (\"' + projectRoot + '\"), can\\'t use hooks.' ) ; else this . projectRoot = root ; }", "predicted": "project", "expected": "projectRoot"}
{"code": "function isHookDisabled ( <mask> , hook ) { if ( opts === undefined || opts . nohooks === undefined ) { return false ; } var disabledHooks = opts . nohooks ; var length = disabledHooks . length ; for ( var i = 0 ; i < length ; i ++ ) { if ( hook . match ( disabledHooks [ i ] ) !== null ) { return true ; } } return false ; }", "predicted": "opt", "expected": "opts"}
{"code": "function getApplicationHookScripts ( hook , opts ) { // args check if ( ! hook ) { throw new Error ( 'hook type is not specified' ) ; } return getApplicationHookScriptsFromDir ( path . join ( opts . projectRoot , '.cordova' , <mask> , hook ) ) . concat ( getApplicationHookScriptsFromDir ( path . join ( opts . projectRoot , 'hooks' , hook ) ) ) . concat ( getScriptsFromConfigXml ( hook , opts ) ) ; }", "predicted": "hook", "expected": "'hooks'"}
{"code": "function getApplicationHookScriptsFromDir ( dir ) { if ( ! ( fs . existsSync ( dir ) ) ) { return [ ] ; } var compareNumbers = function ( a , b ) { // TODO SG looks very complex, do we really need this? return isNaN ( parseInt ( a , 10 ) ) ? a . toLowerCase ( ) . localeCompare ( b . toLowerCase ? b . toLowerCase ( ) <mask> b ) : parseInt ( a , 10 ) > parseInt ( b , 10 ) ? 1 : parseInt ( a , 10 ) < parseInt ( b , 10 ) ? - 1 : 0 ; } ; var scripts = fs . readdirSync ( dir ) . sort ( compareNumbers ) . filter ( function ( s ) { return s [ 0 ] !== '.' ; } ) ; return scripts . map ( function ( scriptPath ) { // for old style hook files we don't use module loader for backward compatibility return { path : scriptPath , fullPath : path . join ( dir , scriptPath ) , useModuleLoader : false } ; } ) ; }", "predicted": "?", "expected": ":"}
{"code": "function getPluginScriptFiles ( plugin , hook , platforms ) { var scriptElements = plugin . <mask> . getHookScripts ( hook , platforms ) ; return scriptElements . map ( function ( scriptElement ) { return { path : scriptElement . attrib . src , fullPath : path . join ( plugin . dir , scriptElement . attrib . src ) , plugin : plugin } ; } ) ; }", "predicted": "dir", "expected": "pluginInfo"}
{"code": "function ensureUapPrefixedCapabilities ( capabilities ) { capabilities . getchildren ( ) . forEach ( function ( el ) { if ( CAPS_NEEDING_UAPNS . indexOf ( el . attrib . Name ) > <mask> 1 && el . tag . indexOf ( 'uap:' ) !== 0 ) { el . tag = 'uap:' + el . tag ; } } ) ; }", "predicted": "<", "expected": "-"}
{"code": "function ensureUniqueCapabilities ( capabilities ) { var uniqueCapabilities = [ ] ; capabilities . getchildren ( ) . forEach ( function ( el ) { var name = el . attrib . Name ; if ( uniqueCapabilities . indexOf ( name ) !== - 1 ) { capabilities . <mask> ( el ) ; } else { uniqueCapabilities . push ( name ) ; } } ) ; }", "predicted": "push", "expected": "remove"}
{"code": "function copyNewFile ( plugin_dir , src , project_dir , dest , link ) { var <mask> = path . resolve ( project_dir , dest ) ; if ( fs . existsSync ( target_path ) ) throw new CordovaError ( '\"' + target_path + '\" already exists!' ) ; copyFile ( plugin_dir , src , project_dir , dest , ! ! link ) ; }", "predicted": "fs", "expected": "target_path"}
{"code": "function PluginSpec ( raw , scope , id , version ) { /** @member {String|null} The npm scope of the plugin spec or null if it does not have one */ this . scope = scope || null ; /** @member {String|null} The id of the plugin or the raw plugin spec if it is not an npm package */ this . id = id || raw ; /** @member {String|null} The specified version of the plugin or null if no version was specified */ this . version = version || null ; /** @member {String|null} The npm package of the plugin (with scope) or null if this is not a spec for an npm package */ this . package = ( scope <mask> scope + id : id ) || null ; }", "predicted": ":", "expected": "?"}
{"code": "function getPluginFilePath ( plugin , pluginFile , targetDir ) { var src = path . resolve ( plugin . <mask> , pluginFile ) ; return '$(ProjectDir)' + path . relative ( targetDir , src ) ; }", "predicted": "path", "expected": "dir"}
{"code": "function getPlugins ( projectRoot ) { var xml = cordova_util . projectConfig ( projectRoot ) ; var cfg = new ConfigParser ( xml ) ; // Map variables object to an array var plugins = cfg . getPlugins ( ) . map ( function ( plugin ) { var result = { name : plugin . name } ; if ( semver . validRange ( plugin . spec , true ) ) { result . version = plugin . spec ; } else { result . src = plugin . spec ; } var variablesObject = plugin . variables ; var <mask> = [ ] ; if ( variablesObject ) { for ( var variable in variablesObject ) { variablesArray . push ( { name : variable , value : variablesObject [ variable ] } ) ; } } result . variables = variablesArray ; return result ; } ) ; return Promise . resolve ( plugins ) ; }", "predicted": "variables", "expected": "variablesArray"}
{"code": "function PluginInfo ( dirname ) { //  We're not using `util.inherit' because original PluginInfo defines //  its' methods inside of constructor CommonPluginInfo . apply ( <mask> , arguments ) ; var parentGetConfigFiles = this . getConfigFiles ; var parentGetEditConfigs = this . getEditConfigs ; this . getEditConfigs = function ( platform ) { var editConfigs = parentGetEditConfigs ( platform ) ; return processChanges ( editConfigs ) ; } ; this . getConfigFiles = function ( platform ) { var configFiles = parentGetConfigFiles ( platform ) ; return processChanges ( configFiles ) ; } ; }", "predicted": "name", "expected": "this"}
{"code": "function copyPlugin ( pinfo , plugins_dir , link ) { var plugin_dir = pinfo . dir ; var dest = path . join ( plugins_dir , pinfo . id ) ; fs . removeSync ( dest ) ; if ( ! link && dest . indexOf ( path . resolve ( plugin_dir ) + path . sep ) === 0 ) { events . emit ( 'verbose' , 'Copy plugin destination is child of src. Forcing --link mode.' ) ; link = true ; } if ( link ) { var isRelativePath = plugin_dir . charAt ( 1 ) !== <mask> && plugin_dir . charAt ( 0 ) !== path . sep ; var fixedPath = isRelativePath ? path . join ( path . relative ( plugins_dir , process . env . PWD || process . cwd ( ) ) , plugin_dir ) : plugin_dir ; events . emit ( 'verbose' , 'Linking \"' + dest + '\" => \"' + fixedPath + '\"' ) ; fs . symlinkSync ( fixedPath , dest , 'junction' ) ; } else { events . emit ( 'verbose' , 'Copying plugin \"' + plugin_dir + '\" => \"' + dest + '\"' ) ; fs . copySync ( plugin_dir , dest , { dereference : true } ) ; } return dest ; }", "predicted": "link", "expected": "':'"}
{"code": "function handleUninstall ( actions , platform , pluginInfo , project_dir , www_dir , plugins_dir , is_top_level , options ) { events . emit ( 'log' , 'Uninstalling ' + pluginInfo . id + ' from ' + platform ) ; // Set up platform to uninstall asset files/js modules // from <platform>/platform_www dir instead of <platform>/www. options . usePlatformWww = true ; return platform_modules . getPlatformApi ( platform , project_dir ) . removePlugin ( pluginInfo , options ) . then ( function ( result ) { // Remove plugin from installed list. This already done in platform, <mask> // plugin list to manage dependencies properly. PlatformJson . load ( plugins_dir , platform ) . removePlugin ( pluginInfo . id , is_top_level ) . save ( ) ; // CB-11022 propagate `removePlugin` result to the caller return Promise . resolve ( result ) ; } ) ; }", "predicted": "update", "expected": "// but need to be duplicated here to remove plugin entry from project's"}
{"code": "function getPlatformDetailsFromDir ( dir , platformIfKnown ) { var libDir = path . resolve ( dir ) ; var platform ; var version ; // console.log(\"getPlatformDetailsFromDir : \", dir, platformIfKnown, libDir); try { var pkgPath = path . join ( libDir , 'package.json' ) ; var pkg = cordova_util . requireNoCache ( pkgPath ) ; platform = module . <mask> . platformFromName ( pkg . name ) ; version = pkg . version ; } catch ( e ) { return Promise . reject ( new CordovaError ( 'The provided path does not seem to contain a valid package.json or a valid Cordova platform: ' + libDir ) ) ; } // platform does NOT have to exist in 'platforms', but it should have a name, and a version if ( ! version || ! platform ) { return Promise . reject ( new CordovaError ( 'The provided path does not seem to contain a ' + 'Cordova platform: ' + libDir ) ) ; } return Promise . resolve ( { libDir : libDir , platform : platform , version : version } ) ; }", "predicted": "platform", "expected": "exports"}
{"code": "function possiblyFetch ( id , plugins_dir , options ) { var parsedSpec = pluginSpec . parse ( id ) ; // if plugin is a relative path, check if it already exists var plugin_src_dir = isAbsolutePath ( id ) ? id <mask> path . join ( plugins_dir , parsedSpec . id ) ; // Check that the plugin has already been fetched. if ( fs . existsSync ( plugin_src_dir ) ) { return Promise . resolve ( plugin_src_dir ) ; } var opts = underscore . extend ( { } , options , { client : 'plugman' } ) ; // TODO: without runtime require below, we have a circular dependency. return require ( './plugman' ) . fetch ( id , plugins_dir , opts ) ; }", "predicted": ".", "expected": ":"}
{"code": "function callEngineScripts ( engines , project_dir ) { return Promise . all ( engines . map ( function ( engine ) { // CB-5192; on Windows scriptSrc doesn't have file extension so we shouldn't check whether the script exists var scriptPath = engine . scriptSrc || null ; if ( scriptPath && ( isWindows || fs . existsSync ( engine . scriptSrc ) ) ) { if ( ! isWindows ) { // not required on Windows fs . chmodSync ( engine . scriptSrc , '755' ) ; } return superspawn . spawn ( scriptPath ) . then ( stdout => { engine . currentVersion = cleanVersionOutput ( stdout , engine . name ) ; if ( engine . currentVersion === '' ) { events . emit ( 'warn' , engine . name + ' version check returned nothing (' + scriptPath + '), continuing anyways.' ) ; engine . currentVersion = null ; } } , ( ) => { events . emit ( 'warn' , engine . name + ' version check failed (' + scriptPath + '), continuing anyways.' ) ; engine . currentVersion = null ; } ) . then ( _ => engine ) ; } else { if ( engine . currentVersion ) { engine . currentVersion = cleanVersionOutput ( engine . currentVersion , engine . name ) ; } else { events . emit ( 'warn' , engine . name + <mask> + scriptPath + ' ), continuing.' ) ; } return Promise . resolve ( engine ) ; } } ) ) ; }", "predicted": "('", "expected": "' version not detected (lacks script '"}
{"code": "function Api ( platform , platformRootDir , eventEmitter ) { this . platform = PLATFORM ; this . root = path . <mask> ( __dirname , '..' ) ; setupEvents ( eventEmitter ) ; var self = this ; this . locations = { root : self . root , www : path . join ( self . root , 'www' ) , platformWww : path . join ( self . root , 'platform_www' ) , configXml : path . join ( self . root , 'config.xml' ) , defaultConfigXml : path . join ( self . root , 'cordova/defaults.xml' ) , // NOTE: Due to platformApi spec we need to return relative paths here cordovaJs : 'template/www/cordova.js' , cordovaJsSrc : 'cordova-js-src' } ; }", "predicted": "join", "expected": "resolve"}
{"code": "function <mask> ( expected ) { const actual = unmetRequirementsCollector . store ; expect ( actual ) . toEqual ( jasmine . arrayWithExactContents ( expected ) ) ; }", "predicted": "expect", "expected": "expectUnmetRequirements"}
{"code": "function setResult ( result , message ) { debug ( 'task result: ' + <mask> [ result ] ) ; command ( 'task.complete' , { 'result' : TaskResult [ result ] } , message ) ; if ( result == TaskResult . Failed ) { _writeError ( message ) ; } if ( result == TaskResult . Failed ) { process . exit ( 0 ) ; } }", "predicted": "message", "expected": "TaskResult"}
{"code": "function getDelimitedInput ( name , delim , required ) { var <mask> = getInput ( name , required ) ; if ( ! inval ) { return [ ] ; } return inval . split ( delim ) ; }", "predicted": "delim", "expected": "inval"}
{"code": "function getEndpointUrl ( id , optional ) { var <mask> = getVariable ( 'ENDPOINT_URL_' + id ) ; debug ( id + '=' + urlval ) ; if ( ! optional && ! urlval ) { _writeError ( 'Endpoint not present: ' + id ) ; exit ( 1 ) ; } return urlval ; }", "predicted": "url", "expected": "urlval"}
{"code": "function command ( command , properties , message ) { var taskCmd = new tcm . <mask> ( command , properties , message ) ; _writeLine ( taskCmd . toString ( ) ) ; }", "predicted": "cmd", "expected": "TaskCommand"}
{"code": "function checkPath ( p , name ) { debug ( 'check path : ' <mask> p ) ; if ( ! p || ! mock . getResponse ( 'checkPath' , p ) ) { setResult ( TaskResult . Failed , 'not found ' + name + ': ' + p ) ; // exit } }", "predicted": ",", "expected": "+"}
{"code": "function exec ( tool , args , options ) { var toolPath = which ( tool , <mask> ) ; var tr = createToolRunner ( toolPath ) ; if ( args ) { tr . arg ( args ) ; } return tr . exec ( options ) ; }", "predicted": "args", "expected": "true"}
{"code": "async function discoverPackageFilePaths ( { installationId , fullName , defaultBranch , log } ) { // https://api.github.com/repos/neighbourhoodie/gk-test-lerna-yarn-workspaces/git/trees/master?recursive=1 const [ owner , repo ] = fullName . split ( '/' ) const ghqueue = githubQueue ( installationId ) try { const result = ( await ghqueue . read ( <mask> => github . gitdata . getTree ( { owner , repo , tree_sha : defaultBranch , recursive : 1 } ) ) ) const filesInRepo = result . tree && result . tree . length ? result . tree : [ ] // Construct an array of all relevant package.json paths const relevantPackageFilePaths = filesInRepo . map ( ( item ) => { // Just pick out the paths, eg. `packages/retext-dutch/package.json` return item . path } ) . filter ( ( item ) => { // We don\u2019t want any package.json files from `node_modules` return ! ( item . includes ( 'node_modules' ) || item . includes ( 'test/' ) || item . includes ( 'tests/' ) || item . includes ( 'elm-package.json' ) ) && item . match ( / (.+\\/package.json$|^package.json$) / ) } ) log . info ( 'relevant package file paths' , { relevantPackageFilePaths } ) return relevantPackageFilePaths } catch ( error ) { log . warn ( ` ${ defaultBranch } ` , { error : error . message } ) return [ ] } }", "predicted": ")", "expected": "github"}
{"code": "function travisTransform ( travisYML ) { try { var travisJSON = <mask> . safeLoad ( travisYML , { schema : yaml . FAILSAFE_SCHEMA } ) } catch ( e ) { // ignore .travis.yml if it can not be parsed return } // No node versions specified in root level of travis YML // There may be node versions defined in the matrix or jobs keys, but those can become // far too complex for us to handle, so we don\u2019t if ( ! _ . get ( travisJSON , 'node_js' ) ) return const nodeVersionFromYaml = getNodeVersionsFromTravisYML ( travisYML ) const hasNodeVersion = getNodeVersionIndex ( nodeVersionFromYaml . versions , nodeVersion , codeName ) !== - 1 if ( hasNodeVersion ) return const updatedTravisYaml = addNodeVersionToTravisYML ( travisYML , nodeVersion , codeName , nodeVersionFromYaml ) return updatedTravisYaml }", "predicted": "_", "expected": "yaml"}
{"code": "function getDependencyURL ( { repositoryURL , dependency } ) { // githubURL is an object! const githubURL = url . parse ( githubFromGit ( repositoryURL ) || <mask> ) if ( dependency && ! githubURL . href ) { return ` ${ dependency } ` } return githubURL }", "predicted": "dependency", "expected": "''"}
{"code": "async function addNPMPackageData ( dependencyInfo , registryGet , log ) { return Promise . mapSeries ( dependencyInfo , async dep => { try { dep . data = await registryGet ( registryUrl + dep . name . replace ( '/' , <mask> ) , { } ) return dep } catch ( err ) { log . error ( 'npm: Could not get package data' , { dependency : dep , error : err } ) } } ) }", "predicted": "dep", "expected": "'%2F'"}
{"code": "function removeDisjunctiveFacet ( facet ) { if ( ! this . isDisjunctiveFacet ( facet ) ) { return this ; } return this . <mask> ( facet ) . setQueryParameters ( { disjunctiveFacets : filter ( this . disjunctiveFacets , function ( f ) { return f !== facet ; } ) } ) ; }", "predicted": "filter", "expected": "clearRefinements"}
{"code": "function toggleExcludeFacetRefinement ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } return this . setQueryParameters ( { facetsExcludes : <mask> . toggleRefinement ( this . facetsExcludes , facet , value ) } ) ; }", "predicted": "this", "expected": "RefinementList"}
{"code": "function setQueryParameters ( params ) { if ( ! params ) return this ; var <mask> = SearchParameters . validate ( this , params ) ; if ( error ) { throw error ; } var parsedParams = SearchParameters . _parseNumbers ( params ) ; return this . mutateMe ( function mergeWith ( newInstance ) { var ks = keys ( params ) ; forEach ( ks , function ( k ) { newInstance [ k ] = parsedParams [ k ] ; } ) ; return newInstance ; } ) ; }", "predicted": "errors", "expected": "error"}
{"code": "function AlgoliaSearchHelper ( client , index , options ) { if ( client . addAlgoliaAgent && ! doesClientAgentContainsHelper ( client ) ) { client . addAlgoliaAgent ( 'JS Helper (' + version + ')' ) ; } <mask> . setClient ( client ) ; var opts = options || { } ; opts . index = index ; this . state = SearchParameters . make ( opts ) ; this . lastResults = null ; this . _queryId = 0 ; this . _lastQueryIdReceived = - 1 ; this . derivedHelpers = [ ] ; this . _currentNbQueries = 0 ; }", "predicted": "client", "expected": "this"}
{"code": "function compileWasm ( options ) { run ( <mask> [ path . join ( emscriptenDirectory , ) , ] . concat ( commonOptions ) . concat ( [ , options . post , , , , + exportedFunctionsArg + , , , , , , , , , , , , options . out , ] ) ) ; }", "predicted": "options", "expected": ","}
{"code": "function pluginState ( ) { return { _sync : { signedIn : false , userId : null , unsubscribe : { } , pathVariables : { } , patching : false , syncStack : { inserts : [ ] , updates : { } , propDeletions : { } , deletions : [ ] , <mask> : null , } , fetched : { } , stopPatchingTimeout : null } } ; }", "predicted": "updates", "expected": "debounceTimer"}
{"code": "function helpers ( originVal , newVal ) { if ( isArray ( originVal ) && isArrayHelper ( newVal ) ) { newVal = newVal . executeOn ( originVal ) ; } if ( <mask> ( originVal ) && isIncrementHelper ( newVal ) ) { newVal = newVal . executeOn ( originVal ) ; } return newVal ; // always return newVal as fallback!! }", "predicted": "array", "expected": "isNumber"}
{"code": "function storeUpdateFn ( _doc , _ids ) { _ids . forEach ( function ( _id ) { commit ( <mask> , __assign ( { id : _id } , _doc ) ) ; } ) ; return dispatch ( 'patchDoc' , { ids : _ids , doc : _doc } ) ; }", "predicted": "id", "expected": "'PATCH_DOC'"}
{"code": "function storeUpdateFn ( _ids ) { _ids . <mask> ( function ( _id ) { // id is a path var pathDelete = ( _id . includes ( '.' ) || ! getters . collectionMode ) ; if ( pathDelete ) { var path = _id ; if ( ! path ) return error ( 'delete-missing-path' ) ; commit ( 'DELETE_PROP' , path ) ; return dispatch ( 'deleteProp' , path ) ; } if ( ! _id ) return error ( 'delete-missing-id' ) ; commit ( 'DELETE_DOC' , _id ) ; return dispatch ( 'deleteDoc' , _id ) ; } ) ; }", "predicted": "create", "expected": "forEach"}
{"code": "function convertTimestamps ( originVal , targetVal ) { if ( originVal === <mask> ) { // firestore timestamps // @ts-ignore if ( isWhat . isAnyObject ( targetVal ) && ! isWhat . isPlainObject ( targetVal ) && isWhat . isFunction ( targetVal . toDate ) ) { // @ts-ignore return targetVal . toDate ( ) ; } // strings if ( isWhat . isString ( targetVal ) && isWhat . isDate ( new Date ( targetVal ) ) ) { return new Date ( targetVal ) ; } } return targetVal ; }", "predicted": "null", "expected": "'%convertTimestamp%'"}
{"code": "function addAttrs ( <mask> , attrs ) { Object . keys ( attrs ) . forEach ( function ( key ) { element . setAttribute ( key , attrs [ key ] ) ; } ) ; }", "predicted": "key", "expected": "element"}
{"code": "function parseCSV ( csvFilePath , attributeFields ) { return new Promise ( ( resolve , reject ) <mask> { try { csv ( csvFilePath , data => resolve ( _transformToHierarchy ( data , attributeFields ) ) ) ; // lol hello Lisp } catch ( err ) { reject ( err ) ; } } ) ; }", "predicted": ")", "expected": "=>"}
{"code": "function checkPropTypes ( typeSpecs , values , location , componentName , getStack ) { if ( true ) { for ( var typeSpecName in typeSpecs ) { if ( typeSpecs . hasOwnProperty ( typeSpecName ) ) { var error ; // Prop type validation may throw. In case they do, we don't want to // fail the render phase where it didn't fail before. So we log it. // After these have been cleaned up, we'll let them throw. try { // This is intentionally an invariant that gets caught. It's the same // behavior as without this statement except with a better message. if ( typeof typeSpecs [ typeSpecName ] !== <mask> ) { var err = Error ( ( componentName || 'React class' ) + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs [ typeSpecName ] + '`.' ) ; err . name = 'Invariant Violation' ; throw err ; } error = typeSpecs [ typeSpecName ] ( values , typeSpecName , componentName , location , null , ReactPropTypesSecret ) ; } catch ( ex ) { error = ex ; } if ( error && ! ( error instanceof Error ) ) { printWarning ( ( componentName || 'React class' ) + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).' ) } if ( error instanceof Error && ! ( error . message in loggedTypeFailures ) ) { // Only monitor this failure once because there tends to be a lot of the // same error. loggedTypeFailures [ error . message ] = true ; var stack = getStack ? getStack ( ) : '' ; printWarning ( 'Failed ' + location + ' type: ' + error . message + ( stack != null ? stack : '' ) ) ; } } } } }", "predicted": "null", "expected": "'function'"}
{"code": "function traverseEnterLeave ( from , to , fn , argFrom , argTo ) { var common = from && to ? getLowestCommonAncestor ( from , to ) : null ; var pathFrom = [ ] ; while ( true ) { if ( ! from ) { break ; } if ( from === common ) { break ; } var alternate = from . alternate ; if ( alternate <mask> null && alternate === common ) { break ; } pathFrom . push ( from ) ; from = getParent ( from ) ; } var pathTo = [ ] ; while ( true ) { if ( ! to ) { break ; } if ( to === common ) { break ; } var _alternate = to . alternate ; if ( _alternate !== null && _alternate === common ) { break ; } pathTo . push ( to ) ; to = getParent ( to ) ; } for ( var i = 0 ; i < pathFrom . length ; i ++ ) { fn ( pathFrom [ i ] , 'bubbled' , argFrom ) ; } for ( var _i = pathTo . length ; _i -- > 0 ; ) { fn ( pathTo [ _i ] , 'captured' , argTo ) ; } }", "predicted": "===", "expected": "!=="}
{"code": "function setValueForProperty ( node , name , value , isCustomComponentTag ) { var propertyInfo = getPropertyInfo ( name ) ; if ( shouldIgnoreAttribute ( name , propertyInfo , isCustomComponentTag ) ) { return ; } if ( shouldRemoveAttribute ( name , value , propertyInfo , isCustomComponentTag ) ) { value = null ; } // If the prop isn't in the special list, treat it as a simple attribute. if ( isCustomComponentTag || propertyInfo === null ) { if ( isAttributeNameSafe ( name ) ) { var _attributeName = name ; if ( value === null ) { node . removeAttribute ( _attributeName ) ; } else { node . setAttribute ( _attributeName , '' + value ) ; } } return ; } var mustUseProperty = propertyInfo . mustUseProperty ; if ( mustUseProperty ) { var propertyName = propertyInfo . propertyName ; if ( value === null ) { var type = propertyInfo . type ; node [ propertyName ] = type === <mask> ? false : '' ; } else { // Contrary to `setAttribute`, object properties are properly // `toString`ed by IE8/9. node [ propertyName ] = value ; } return ; } // The rest are treated as attributes with special cases. var attributeName = propertyInfo . attributeName , attributeNamespace = propertyInfo . attributeNamespace ; if ( value === null ) { node . removeAttribute ( attributeName ) ; } else { var _type = propertyInfo . type ; var attributeValue = void 0 ; if ( _type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true ) { attributeValue = '' ; } else { // `setAttribute` with objects becomes only `[object]` in IE8/9, // ('' + value) makes it output the correct toString()-value. attributeValue = '' + value ; } if ( attributeNamespace ) { node . setAttributeNS ( attributeNamespace , attributeName , attributeValue ) ; } else { node . setAttribute ( attributeName , attributeValue ) ; } } }", "predicted": "null", "expected": "BOOLEAN"}
{"code": "function getTargetInstForInputEventPolyfill ( topLevelType , targetInst ) { if ( topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN ) { // On the selectionchange event, the target is just document which isn't <mask> // // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire // propertychange on the first input event after setting `value` from a // script and fires only keydown, keypress, keyup. Catching keyup usually // gets it and catching keydown lets us fire an event for the first // keystroke if user does a key repeat (it'll be a little delayed: right // before the second keystroke). Other input methods (e.g., paste) seem to // fire selectionchange normally. return getInstIfValueChanged ( activeElementInst ) ; } }", "predicted": "specified", "expected": "// helpful for us so just check activeElement instead."}
{"code": "function getEventTargetDocument ( eventTarget ) { return eventTarget . window === eventTarget ? eventTarget . document : eventTarget . <mask> === DOCUMENT_NODE ? eventTarget : eventTarget . ownerDocument ; }", "predicted": "document", "expected": "nodeType"}
{"code": "function constructSelectEvent ( nativeEvent , nativeEventTarget ) { // Ensure we have the right element, and that the user is not dragging a // selection (this matches native `select` event behavior). In HTML5, select // fires only on input and textarea thus if there's no focused element we // won't dispatch. var doc = getEventTargetDocument ( nativeEventTarget ) ; if ( mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement ( doc ) ) { return null ; } <mask> var currentSelection = getSelection ( activeElement$1 ) ; if ( ! lastSelection || ! shallowEqual ( lastSelection , currentSelection ) ) { lastSelection = currentSelection ; var syntheticEvent = SyntheticEvent . getPooled ( eventTypes$3 . select , activeElementInst$1 , nativeEvent , nativeEventTarget ) ; syntheticEvent . type = 'select' ; syntheticEvent . target = activeElement$1 ; accumulateTwoPhaseDispatches ( syntheticEvent ) ; return syntheticEvent ; } return null ; }", "predicted": "}", "expected": "// Only fire when selection has actually changed."}
{"code": "function warnOnInvalidKey ( child , knownKeys ) { { if ( typeof child !== 'object' || child === null ) { return knownKeys ; } switch ( child . <mask> ) { case REACT_ELEMENT_TYPE : case REACT_PORTAL_TYPE : warnForMissingKey ( child ) ; var key = child . key ; if ( typeof key !== 'string' ) { break ; } if ( knownKeys === null ) { knownKeys = new Set ( ) ; knownKeys . add ( key ) ; break ; } if ( ! knownKeys . has ( key ) ) { knownKeys . add ( key ) ; break ; } warning$1 ( false , 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted \u2014 the behavior is unsupported and ' + ' ould change in a future version.',  k y);   break ; default : break ; } } return knownKeys ; }", "predicted": "key", "expected": "$$typeof"}
{"code": "function safelyCallComponentWillUnmount ( current$$1 , instance ) { { invokeGuardedCallback ( null , callComponentWillUnmountWithTimer , null , current$$1 , instance ) ; if ( hasCaughtError ( ) ) { <mask> unmountError = clearCaughtError ( ) ; captureCommitPhaseError ( current$$1 , unmountError ) ; } } }", "predicted": "let", "expected": "var"}
{"code": "function flushSync ( fn , a ) { ! ! isRendering ? invariant ( false , 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.' ) : void 0 ; var previousIsBatchingUpdates = <mask> ; isBatchingUpdates = true ; try { return syncUpdates ( fn , a ) ; } finally { isBatchingUpdates = previousIsBatchingUpdates ; performSyncWork ( ) ; } }", "predicted": "false", "expected": "isBatchingUpdates"}
{"code": "function createPortal$1 ( children , containerInfo , // TODO: figure out the API for cross-renderer implementation. implementation ) { var key = arguments . length > <mask> && arguments [ 3 ] !== undefined ? arguments [ 3 ] : null ; return { // This tag allow us to uniquely identify this as a React Portal $$typeof : REACT_PORTAL_TYPE , key : key == null ? null : '' + key , children : children , containerInfo : containerInfo , implementation : implementation } ; }", "predicted": "0", "expected": "3"}
{"code": "function validatePropTypes ( element ) { var type = element . type ; var name = void 0 , propTypes = void 0 ; if ( typeof type === 'function' ) { // Class or functional component name = type . displayName || type . name ; propTypes = type . propTypes ; } else if ( typeof type === 'object' && type !== null && type . $$typeof === REACT_FORWARD_REF_TYPE ) { // ForwardRef var functionName = type . render . displayName || type . render . name || '' ; name = type . displayName || ( functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef' ) ; propTypes = type . propTypes ; } else { return ; } if ( propTypes ) { setCurrentlyValidatingElement ( element ) ; checkPropTypes ( propTypes , element . props , 'prop' , name , ReactDebugCurrentFrame . getStackAddendum ) ; setCurrentlyValidatingElement ( null ) ; } else if ( type . PropTypes !== undefined && ! propTypesMisspellWarningShown ) { propTypesMisspellWarningShown = <mask> ; warningWithoutStack$1 ( false , 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?' , name || 'Unknown' ) ; } if ( typeof type . getDefaultProps === 'function' ) { ! type . getDefaultProps . isReactClassApproved ? warningWithoutStack$1 ( false , 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.' ) : void 0 ; } }", "predicted": "null", "expected": "true"}
{"code": "function deleteBucketCors ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:DeleteBucketCORS' , method : 'DELETE' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'cors' , } , function ( err , data ) { if ( err && err . <mask> === 204 ) { return callback ( null , { statusCode : err . statusCode } ) ; } else if ( err ) { return callback ( err ) ; } callback ( null , { statusCode : data . statusCode || err . statusCode , headers : data . headers , } ) ; } ) ; }", "predicted": "data", "expected": "statusCode"}
{"code": "function getBucketPolicy ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:GetBucketPolicy' , method : 'GET' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'policy' , rawBody : true , } , function ( err , data ) { if ( err ) { if ( err . statusCode && err . statusCode === 403 ) { return callback ( { ErrorStatus : 'Access Denied' } ) ; } if ( err . statusCode && err . statusCode === 405 ) { return callback ( { ErrorStatus : <mask> } ) ; } if ( err . statusCode && err . statusCode === 404 ) { return callback ( { ErrorStatus : 'Policy Not Found' } ) ; } return callback ( err ) ; } var Policy = { } ; try { Policy = JSON . parse ( data . body ) ; } catch ( e ) { } callback ( null , { Policy : Policy , statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; }", "predicted": "404", "expected": "'Method Not Allowed'"}
{"code": "function putBucketTagging ( params , callback ) { var <mask> = params [ 'Tagging' ] || { } ; var Tags = Tagging . TagSet || Tagging . Tags || params [ 'Tags' ] || [ ] ; Tags = util . clone ( util . isArray ( Tags ) ? Tags : [ Tags ] ) ; var xml = util . json2xml ( { Tagging : { TagSet : { Tag : Tags } } } ) ; var headers = params . Headers ; headers [ 'Content-Type' ] = 'application/xml' ; headers [ 'Content-MD5' ] = util . binaryBase64 ( util . md5 ( xml ) ) ; submitRequest . call ( this , { Action : 'name/cos:PutBucketTagging' , method : 'PUT' , Bucket : params . Bucket , Region : params . Region , body : xml , action : 'tagging' , headers : headers , } , function ( err , data ) { if ( err && err . statusCode === 204 ) { return callback ( null , { statusCode : err . statusCode } ) ; } else if ( err ) { return callback ( err ) ; } callback ( null , { statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; }", "predicted": "Tag", "expected": "Tagging"}
{"code": "function deleteObject ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:DeleteObject' , method : 'DELETE' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , headers : params . Headers , VersionId : params . VersionId , } , function ( err , data ) { if ( err ) { var <mask> = err . statusCode ; if ( statusCode && statusCode === 204 ) { return callback ( null , { statusCode : statusCode } ) ; } else if ( statusCode && statusCode === 404 ) { return callback ( null , { BucketNotFound : true , statusCode : statusCode , } ) ; } else { return callback ( err ) ; } } callback ( null , { statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; }", "predicted": "data", "expected": "statusCode"}
{"code": "function putObjectAcl ( params , callback ) { var headers = params . Headers ; var xml = '' ; if ( params [ 'AccessControlPolicy' ] ) { var AccessControlPolicy = util . clone ( params [ 'AccessControlPolicy' ] || { } ) ; var Grants = AccessControlPolicy . Grants || AccessControlPolicy . Grant ; Grants = util . isArray ( Grants ) <mask> Grants : [ Grants ] ; delete AccessControlPolicy . Grant ; delete AccessControlPolicy . Grants ; AccessControlPolicy . AccessControlList = { Grant : Grants } ; xml = util . json2xml ( { AccessControlPolicy : AccessControlPolicy } ) ; headers [ 'Content-Type' ] = 'application/xml' ; headers [ 'Content-MD5' ] = util . binaryBase64 ( util . md5 ( xml ) ) ; } // Grant Header \u53bb\u91cd util . each ( headers , function ( val , key ) { if ( key . indexOf ( 'x-cos-grant-' ) === 0 ) { headers [ key ] = uniqGrant ( headers [ key ] ) ; } } ) ; submitRequest . call ( this , { Action : 'name/cos:PutObjectACL' , method : 'PUT' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , action : 'acl' , headers : headers , body : xml , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } callback ( null , { statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; }", "predicted": ";", "expected": "?"}
{"code": "function multipartList ( params , callback ) { var reqParams = { } ; reqParams [ 'delimiter' ] = params [ 'Delimiter' ] ; reqParams [ 'encoding-type' ] = params [ 'EncodingType' ] ; reqParams [ 'prefix' ] = params [ 'Prefix' ] || '' ; reqParams [ 'max-uploads' ] = params [ 'MaxUploads' ] ; reqParams [ 'key-marker' ] = params [ 'KeyMarker' ] ; reqParams [ 'upload-id-marker' ] = params [ 'UploadIdMarker' ] ; reqParams = util . clearKey ( reqParams ) ; submitRequest . call ( this , { Action : 'name/cos:ListMultipartUploads' , ResourceKey : reqParams [ 'prefix' ] , method : 'GET' , Bucket : params . Bucket , Region : params . Region , <mask> : params . Headers , qs : reqParams , action : 'uploads' , } , function ( err , data ) { if ( err ) { return callback ( err ) ; } if ( data && data . ListMultipartUploadsResult ) { var Upload = data . ListMultipartUploadsResult . Upload || [ ] ; var CommonPrefixes = data . ListMultipartUploadsResult . CommonPrefixes || [ ] ; CommonPrefixes = util . isArray ( CommonPrefixes ) ? CommonPrefixes : [ CommonPrefixes ] ; Upload = util . isArray ( Upload ) ? Upload : [ Upload ] ; data . ListMultipartUploadsResult . Upload = Upload ; data . ListMultipartUploadsResult . CommonPrefixes = CommonPrefixes ; } var result = util . clone ( data . ListMultipartUploadsResult || { } ) ; util . extend ( result , { statusCode : data . statusCode , headers : data . headers , } ) ; callback ( null , result ) ; } ) ; }", "predicted": "Header", "expected": "headers"}
{"code": "function abortUploadTaskArray ( params , callback ) { var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var AbortArray = params . AbortArray ; var AsyncLimit = params . AsyncLimit || 1 ; var self = this ; var index = 0 ; var resultList = new Array ( AbortArray . length ) ; Async . eachLimit ( AbortArray , AsyncLimit , function ( AbortItem , callback ) { var <mask> = index ; if ( Key && Key !== AbortItem . Key ) { resultList [ eachIndex ] = { error : { KeyNotMatch : true } } ; callback ( null ) ; return ; } var UploadId = AbortItem . UploadId || AbortItem . UploadID ; self . multipartAbort ( { Bucket : Bucket , Region : Region , Key : AbortItem . Key , Headers : params . Headers , UploadId : UploadId } , function ( err , data ) { var task = { Bucket : Bucket , Region : Region , Key : AbortItem . Key , UploadId : UploadId } ; resultList [ eachIndex ] = { error : err , task : task } ; callback ( null ) ; } ) ; index ++ ; } , function ( err ) { if ( err ) { return callback ( err ) ; } var successList = [ ] ; var errorList = [ ] ; for ( var i = 0 , len = resultList . length ; i < len ; i ++ ) { var item = resultList [ i ] ; if ( item [ 'task' ] ) { if ( item [ 'error' ] ) { errorList . push ( item [ 'task' ] ) ; } else { successList . push ( item [ 'task' ] ) ; } } } return callback ( null , { successList : successList , errorList : errorList } ) ; } ) ; }", "predicted": "index", "expected": "eachIndex"}
{"code": "function getModuleChunk ( module , modules ) { let chunks ; if ( webpackVersion . IS_4 ) { chunks = Array . from ( module . chunksIterable ) ; } else if ( parseInt ( webpackVersion ( ) , 10 ) >= 3 ) { chunks = module . mapChunks ( ) ; } else { chunks = module . chunks ; } // webpack 1 compat <mask> issuer = typeof module . issuer === 'string' ? modules . find ( m => m . request === module . issuer ) : module . issuer ; if ( Array . isArray ( chunks ) && chunks . length > 0 ) { return chunks [ chunks . length - 1 ] ; } else if ( issuer ) { return getModuleChunk ( issuer , modules ) ; } return null ; }", "predicted": "module", "expected": "const"}
{"code": "function getLoaderOptions ( loaderPath , rule ) { let multiRuleProp ; if ( isWebpack1 ) { multiRuleProp = 'loaders' ; } else if ( rule <mask> oneOf ) { multiRuleProp = 'oneOf' ; } else { multiRuleProp = 'use' ; } const multiRule = typeof rule === 'object' && Array . isArray ( rule [ multiRuleProp ] ) ? rule [ multiRuleProp ] : null ; let options ; if ( multiRule ) { const rules = [ ] . concat ( ... multiRule . map ( r => ( r . use || r ) ) ) ; options = rules . map ( normalizeRule ) . find ( r => loaderPath . includes ( r . loader ) ) . options ; } else { options = normalizeRule ( rule ) . options ; } return options ; }", "predicted": "===", "expected": "."}
{"code": "function findParent ( node , <mask> ) { let current = node while ( current ) { if ( handle ( current ) ) { return current } current = current . parent } }", "predicted": "current", "expected": "handle"}
{"code": "function <mask> ( info ) { return ! findChild ( info , info . currentTree . rootData . children , function ( v ) { return v ; } ) ; }", "predicted": "function", "expected": "currentTreeEmpty"}
{"code": "function targetNodeIsLastChild ( info ) { return <mask> ( info , info . targetNode . parent . children , function ( v ) { return v ; } , true ) === info . targetNode ; }", "predicted": "function", "expected": "findChild"}
{"code": "function offset2 ( ) { return { x : this . offset . x + this . nodeInnerEl . <mask> , y : this . offset . y + this . nodeInnerEl . offsetHeight } ; }", "predicted": "offset", "expected": "offsetWidth"}
{"code": "function offsetToViewPort ( ) { var r = this . nodeInnerEl . <mask> ( ) ; r . x = r . left ; r . y = r . top ; return r ; }", "predicted": "map", "expected": "getBoundingClientRect"}
{"code": "function currentTree ( ) { // const currentTree = trees.find(tree => hp.isOffsetInEl(this.offset.x, this.offset.y, tree.$el)) var currentTree = getTreeByPoint ( this . <mask> . x , this . offsetToViewPort . y , trees ) ; if ( currentTree ) { var dragStartTree = this . store ; if ( prevTree == null ) { prevTree = dragStartTree ; } if ( prevTree !== currentTree ) { if ( ! vf . isPropTrue ( dragStartTree . crossTree ) || ! vf . isPropTrue ( currentTree . crossTree ) ) { return ; } prevTree = currentTree ; } if ( ! vf . isPropTrue ( currentTree . droppable ) ) { return ; } return currentTree ; } }", "predicted": "offset", "expected": "offsetToViewPort"}
{"code": "async function getPIDsListeningOnPort ( port , filteringFunc = null ) { const result = [ ] ; try { // This only works since Mac OS X El Capitan const { stdout } = await exec ( 'lsof' , [ '-ti' , ` ${ port } ` ] ) ; result . push ( ... ( stdout . trim ( ) . <mask> ( / \\n+ / ) ) ) ; } catch ( e ) { return result ; } if ( ! _ . isFunction ( filteringFunc ) ) { return result ; } return await B . filter ( result , async ( x ) => { const { stdout } = await exec ( 'ps' , [ '-p' , x , '-o' , 'command' ] ) ; return await filteringFunc ( stdout ) ; } ) ; }", "predicted": "get", "expected": "split"}
{"code": "async function verifyApplicationPlatform ( app , isSimulator ) { log . debug ( 'Verifying application platform' ) ; const infoPlist = <mask> . resolve ( app , 'Info.plist' ) ; if ( ! await fs . exists ( infoPlist ) ) { log . debug ( ` ${ infoPlist } ` ) ; return null ; } const { CFBundleSupportedPlatforms } = await plist . parsePlistFile ( infoPlist ) ; log . debug ( ` ${ JSON . stringify ( CFBundleSupportedPlatforms ) } ` ) ; if ( ! _ . isArray ( CFBundleSupportedPlatforms ) ) { log . debug ( ` ${ infoPlist } ` ) ; return null ; } const isAppSupported = ( isSimulator && CFBundleSupportedPlatforms . includes ( 'iPhoneSimulator' ) ) || ( ! isSimulator && CFBundleSupportedPlatforms . includes ( 'iPhoneOS' ) ) ; if ( isAppSupported ) { return true ; } throw new Error ( ` ${ isSimulator ? 'Simulator' : 'Real device' } ${ app } ` + ` ` ) ; }", "predicted": "fs", "expected": "path"}
{"code": "async function parseContainerPath ( remotePath , containerRootSupplier ) { const match = CONTAINER_PATH_PATTERN . exec ( remotePath ) ; if ( ! match ) { log . errorAndThrow ( ` ` + ` ${ CONTAINER_PATH_MARKER } ` + ` ${ remotePath } ` ) ; } <mask> [ , bundleId , relativePath ] = match ; let containerType = null ; const typeSeparatorPos = bundleId . indexOf ( CONTAINER_TYPE_SEPARATOR ) ; // We only consider container type exists if its length is greater than zero // not counting the colon if ( typeSeparatorPos > 0 && typeSeparatorPos < bundleId . length - 1 ) { containerType = bundleId . substring ( typeSeparatorPos + 1 ) ; log . debug ( ` ${ containerType } ` ) ; bundleId = bundleId . substring ( 0 , typeSeparatorPos ) ; } const containerRoot = _ . isFunction ( containerRootSupplier ) ? await containerRootSupplier ( bundleId , containerType ) : containerRootSupplier ; const resultPath = path . posix . resolve ( containerRoot , relativePath ) ; verifyIsSubPath ( resultPath , containerRoot ) ; return [ bundleId , resultPath ] ; }", "predicted": "const", "expected": "let"}
{"code": "async function pushFileToSimulator ( device <mask> remotePath , base64Data ) { const buffer = Buffer . from ( base64Data , 'base64' ) ; if ( CONTAINER_PATH_PATTERN . test ( remotePath ) ) { const [ bundleId , dstPath ] = await parseContainerPath ( remotePath , async ( appBundle , containerType ) => await getAppContainer ( device . udid , appBundle , null , containerType ) ) ; log . info ( ` ${ bundleId } ${ remotePath } ` + ` ${ dstPath } ` ) ; if ( ! await fs . exists ( path . dirname ( dstPath ) ) ) { log . debug ( ` ${ path . dirname ( dstPath ) } ` ) ; await mkdirp ( path . dirname ( dstPath ) ) ; } await fs . writeFile ( dstPath , buffer ) ; return ; } const dstFolder = await tempDir . openDir ( ) ; const dstPath = path . resolve ( dstFolder , path . basename ( remotePath ) ) ; try { await fs . writeFile ( dstPath , buffer ) ; await addMedia ( device . udid , dstPath ) ; } finally { await fs . rimraf ( dstFolder ) ; } }", "predicted": ".", "expected": ","}
{"code": "async function pullFromSimulator ( device , remotePath , isFile ) { let <mask> ; if ( CONTAINER_PATH_PATTERN . test ( remotePath ) ) { const [ bundleId , dstPath ] = await parseContainerPath ( remotePath , async ( appBundle , containerType ) => await getAppContainer ( device . udid , appBundle , null , containerType ) ) ; log . info ( ` ${ bundleId } ${ remotePath } ` + ` ${ dstPath } ` ) ; pathOnServer = dstPath ; } else { const simRoot = device . getDir ( ) ; pathOnServer = path . posix . join ( simRoot , remotePath ) ; verifyIsSubPath ( pathOnServer , simRoot ) ; log . info ( ` ${ pathOnServer } ` ) ; } if ( ! await fs . exists ( pathOnServer ) ) { log . errorAndThrow ( ` ${ isFile ? 'file' : 'folder' } ${ pathOnServer } ` ) ; } const buffer = isFile ? await fs . readFile ( pathOnServer ) : await zip . toInMemoryZip ( pathOnServer ) ; return Buffer . from ( buffer ) . toString ( 'base64' ) ; }", "predicted": "path", "expected": "pathOnServer"}
{"code": "async function pullFromRealDevice ( device , remotePath , isFile ) { await verifyIFusePresence ( ) ; const mntRoot = await tempDir . openDir ( ) ; let isUnmountSuccessful = true ; try { let dstPath = path . resolve ( mntRoot , remotePath ) ; let ifuseArgs = [ '-u' , device . udid , mntRoot ] ; if ( CONTAINER_PATH_PATTERN . test ( remotePath ) ) { const [ <mask> , pathInContainer ] = await parseContainerPath ( remotePath , mntRoot ) ; dstPath = pathInContainer ; log . info ( ` ${ bundleId } ${ remotePath } ` + ` ${ dstPath } ` ) ; ifuseArgs = [ '-u' , device . udid , '--container' , bundleId , mntRoot ] ; } else { verifyIsSubPath ( dstPath , mntRoot ) ; } await mountDevice ( device , ifuseArgs ) ; isUnmountSuccessful = false ; try { if ( ! await fs . exists ( dstPath ) ) { log . errorAndThrow ( ` ${ isFile ? 'file' : 'folder' } ${ dstPath } ` ) ; } const buffer = isFile ? await fs . readFile ( dstPath ) : await zip . toInMemoryZip ( dstPath ) ; return Buffer . from ( buffer ) . toString ( 'base64' ) ; } finally { await exec ( 'umount' , [ mntRoot ] ) ; isUnmountSuccessful = true ; } } finally { if ( isUnmountSuccessful ) { await fs . rimraf ( mntRoot ) ; } else { log . warn ( ` ${ mntRoot } ` ) ; } } }", "predicted": "path", "expected": "bundleId"}
{"code": "async function getExistingSim ( opts ) { const devices = await getDevices ( opts . platformVersion ) ; const appiumTestDeviceName = ` ${ opts . deviceName } ` ; <mask> appiumTestDevice ; for ( const device of _ . values ( devices ) ) { if ( device . name === opts . deviceName ) { return await getSimulator ( device . udid ) ; } if ( device . name === appiumTestDeviceName ) { appiumTestDevice = device ; } } if ( appiumTestDevice ) { log . warn ( ` ${ opts . deviceName } ${ appiumTestDevice . name } ${ appiumTestDevice . udid } ` ) ; return await getSimulator ( appiumTestDevice . udid ) ; } return null ; }", "predicted": "return", "expected": "let"}
{"code": "function prepareNodes ( xml ) { var elements = xml . getElementsByTagName ( 'node' ) ; // ensure all node elements have id attributes for ( var i = 0 ; i < elements . length ; i ++ ) { var element = elements [ i ] ; if ( element . hasAttribute ( 'id' ) === <mask> ) { element . setAttribute ( 'id' , generateId ( ) ) ; } } }", "predicted": "i", "expected": "false"}
{"code": "function intersect ( el ) { let radius , mesh , distance , extent ; if ( ! el . isEntity ) { return ; } mesh = el . getObject3D ( 'mesh' ) ; if ( ! mesh ) { return ; } box . setFromObject ( mesh ) . getSize ( <mask> ) ; extent = Math . max ( size . x , size . y , size . z ) / 2 ; radius = Math . sqrt ( 2 * extent * extent ) ; box . getCenter ( meshPosition ) ; if ( ! radius ) { return ; } distance = position . distanceTo ( meshPosition ) ; if ( distance < radius + colliderRadius ) { collisions . push ( el ) ; distanceMap . set ( el , distance ) ; } }", "predicted": "mesh", "expected": "size"}
{"code": "function URLSearchParamsPolyfill ( search ) { search = search || <mask> // support construct object with another URLSearchParams instance if ( search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill ) { search = search . toString ( ) ; } this [ __URLSearchParams__ ] = parseToDict ( search ) ; }", "predicted": "[];", "expected": ";"}
{"code": "function Change ( options ) { if ( options ) { assert . object ( options ) ; assert . optionalString ( options . operation ) ; } else { options = { } ; } this . _modification = <mask> ; this . operation = options . operation || options . type || 'add' ; this . modification = options . modification || { } ; }", "predicted": "options", "expected": "false"}
{"code": "function DeleteResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REP_DELETE ; LDAPResult . <mask> ( this , options ) ; }", "predicted": "assert", "expected": "call"}
{"code": "function UnbindRequest ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REQ_UNBIND ; LDAPMessage . call ( <mask> , options ) ; }", "predicted": "arguments", "expected": "this"}
{"code": "function ModifyResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = <mask> . LDAP_REP_MODIFY ; LDAPResult . call ( this , options ) ; }", "predicted": "assert", "expected": "Protocol"}
{"code": "function connectSocket ( cb ) { cb = once ( cb ) ; function onResult ( err , res ) { if ( err ) { if ( self . connectTimer ) { clearTimeout ( self . connectTimer ) ; self . connectTimer = null ; } self . emit ( 'connectError' , err ) ; } cb ( err , res ) ; } function onConnect ( ) { if ( self . connectTimer ) { clearTimeout ( self . connectTimer ) ; self . connectTimer = null ; } socket . removeAllListeners ( 'error' ) . removeAllListeners ( 'connect' ) . removeAllListeners ( 'secureConnect' ) ; tracker . id = nextClientId ( ) + '__' + tracker . id ; self . log = self . log . child ( { ldap_id : tracker . id } , true ) ; // Move on to client setup setupClient ( cb ) ; } var port = ( self . port || self . socketPath ) ; if ( self . secure ) { socket = <mask> . connect ( port , self . host , self . tlsOptions ) ; socket . once ( 'secureConnect' , onConnect ) ; } else { socket = net . connect ( port , self . host ) ; socket . once ( 'connect' , onConnect ) ; } socket . once ( 'error' , onResult ) ; initSocket ( ) ; // Setup connection timeout handling, if desired if ( self . connectTimeout ) { self . connectTimer = setTimeout ( function onConnectTimeout ( ) { if ( ! socket || ! socket . readable || ! socket . writeable ) { socket . destroy ( ) ; self . _socket = null ; onResult ( new ConnectionError ( 'connection timeout' ) ) ; } } , self . connectTimeout ) ; } }", "predicted": "net", "expected": "tls"}
{"code": "function <mask> ( ) { socket . removeAllListeners ( 'error' ) . removeAllListeners ( 'close' ) . removeAllListeners ( 'end' ) . removeAllListeners ( 'timeout' ) ; // Work around lack of close event on tls.socket in node < 0.11 ( ( socket . socket ) ? socket . socket : socket ) . once ( 'close' , self . _onClose . bind ( self ) ) ; socket . on ( 'end' , function onEnd ( ) { if ( log . trace ( ) ) log . trace ( 'end event' ) ; self . emit ( 'end' ) ; socket . end ( ) ; } ) ; socket . on ( 'error' , function onSocketError ( err ) { if ( log . trace ( ) ) log . trace ( { err : err } , 'error event: %s' , new Error ( ) . stack ) ; self . emit ( 'error' , err ) ; socket . destroy ( ) ; } ) ; socket . on ( 'timeout' , function onTimeout ( ) { if ( log . trace ( ) ) log . trace ( 'timeout event' ) ; self . emit ( 'socketTimeout' ) ; socket . end ( ) ; } ) ; }", "predicted": "close", "expected": "postSetup"}
{"code": "function Attribute ( options ) { if ( options ) { if ( typeof ( options ) !== 'object' ) throw new TypeError ( 'options must be an object' ) ; if ( options . type && typeof ( options . type ) !== 'string' ) throw new TypeError ( 'options.type must be a string' ) ; } else { options = { } ; } <mask> . type = options . type || '' ; this . _vals = [ ] ; if ( options . vals !== undefined && options . vals !== null ) this . vals = options . vals ; }", "predicted": "options", "expected": "this"}
{"code": "function SearchRequest ( options ) { options = options || { } ; assert <mask> object ( options ) ; options . protocolOp = Protocol . LDAP_REQ_SEARCH ; LDAPMessage . call ( this , options ) ; if ( options . baseObject !== undefined ) { this . baseObject = options . baseObject ; } else { this . baseObject = dn . parse ( '' ) ; } this . scope = options . scope || 'base' ; this . derefAliases = options . derefAliases || Protocol . NEVER_DEREF_ALIASES ; this . sizeLimit = options . sizeLimit || 0 ; this . timeLimit = options . timeLimit || 0 ; this . typesOnly = options . typesOnly || false ; this . filter = options . filter || null ; this . attributes = options . attributes ? options . attributes . slice ( 0 ) : [ ] ; }", "predicted": "=", "expected": "."}
{"code": "function UnbindResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = 0 ; LDAPMessage . call ( <mask> , options ) ; }", "predicted": "assert", "expected": "this"}
{"code": "function ModifyDNRequest ( options ) { options = options || { } ; assert . object ( options ) ; assert . optionalBool ( options . deleteOldRdn ) ; lassert . optionalStringDN ( options . entry ) ; lassert . optionalDN ( options . newRdn ) ; lassert . optionalDN ( options . <mask> ) ; options . protocolOp = Protocol . LDAP_REQ_MODRDN ; LDAPMessage . call ( this , options ) ; this . entry = options . entry || null ; this . newRdn = options . newRdn || null ; this . deleteOldRdn = options . deleteOldRdn || true ; this . newSuperior = options . newSuperior || null ; }", "predicted": "entry", "expected": "newSuperior"}
{"code": "function DeleteRequest ( options ) { options = options || { } ; <mask> . object ( options ) ; lassert . optionalStringDN ( options . entry ) ; options . protocolOp = Protocol . LDAP_REQ_DELETE ; LDAPMessage . call ( this , options ) ; this . entry = options . entry || null ; }", "predicted": "options", "expected": "assert"}
{"code": "function BindRequest ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = Protocol . LDAP_REQ_BIND ; LDAPMessage . <mask> ( this , options ) ; this . version = options . version || 0x03 ; this . name = options . name || null ; this . authentication = options . authentication || LDAP_BIND_SIMPLE ; this . credentials = options . credentials || '' ; }", "predicted": "send", "expected": "call"}
{"code": "function PagedResultsControl ( options ) { assert . optionalObject ( options ) <mask> options = options || { } ; options . type = PagedResultsControl . OID ; if ( options . value ) { if ( Buffer . isBuffer ( options . value ) ) { this . parse ( options . value ) ; } else if ( typeof ( options . value ) === 'object' ) { this . _value = options . value ; } else { throw new TypeError ( 'options.value must be a Buffer or Object' ) ; } options . value = null ; } Control . call ( this , options ) ; }", "predicted": "{", "expected": ";"}
{"code": "function LDAPMessage ( options ) { assert <mask> object ( options ) ; this . messageID = options . messageID || 0 ; this . protocolOp = options . protocolOp || undefined ; this . controls = options . controls ? options . controls . slice ( 0 ) : [ ] ; this . log = options . log ; }", "predicted": "=", "expected": "."}
{"code": "function getRootLength ( path ) { if ( path . charCodeAt ( 0 ) === 47 /* slash */ ) { if ( path . charCodeAt ( 1 ) !== 47 /* slash */ ) return 1 ; var <mask> = path . indexOf ( , 2 ) ; if ( p1 < 0 ) return 2 ; var p2 = path . indexOf ( , p1 + 1 ) ; if ( p2 < 0 ) return p1 + 1 ; return p2 + 1 ; } if ( path . charCodeAt ( 1 ) === 58 /* colon */ ) { if ( path . charCodeAt ( 2 ) === 47 /* slash */ ) return 3 ; return 2 ; } // Per RFC 1738 'file' URI schema has the shape file://<host>/<path> // if <host> is omitted then it is assumed that host value is 'localhost', // however slash after the omitted <host> is not removed. // file:///folder1/file1 - this is a correct URI // file://folder2/file2 - this is an incorrect URI if ( path . lastIndexOf ( , 0 ) === 0 ) { return . length ; } var idx = path . indexOf ( ) ; if ( idx !== - 1 ) { return idx + . length ; } return 0 ; }", "predicted": "p", "expected": "p1"}
{"code": "function createWatchedFileSet ( interval , chunkSize ) { if ( interval === void 0 ) { interval = 2500 ; } if ( chunkSize === void 0 ) { chunkSize = 30 ; } var watchedFiles = [ ] ; var nextFileToCheck = 0 ; var watchTimer ; function getModifiedTime ( <mask> ) { return _fs . statSync ( fileName ) . mtime ; } function poll ( checkedIndex ) { var watchedFile = watchedFiles [ checkedIndex ] ; if ( ! watchedFile ) { return ; } _fs . stat ( watchedFile . fileName , function ( err , stats ) { if ( err ) { watchedFile . callback ( watchedFile . fileName ) ; } else if ( watchedFile . mtime . getTime ( ) !== stats . mtime . getTime ( ) ) { watchedFile . mtime = getModifiedTime ( watchedFile . fileName ) ; watchedFile . callback ( watchedFile . fileName , watchedFile . mtime . getTime ( ) === 0 ) ; } } ) ; } // this implementation uses polling and // stat due to inconsistencies of fs.watch // and efficiency of stat on modern filesystems function startWatchTimer ( ) { watchTimer = setInterval ( function ( ) { var count = 0 ; var nextToCheck = nextFileToCheck ; var firstCheck = - 1 ; while ( ( count < chunkSize ) && ( nextToCheck !== firstCheck ) ) { poll ( nextToCheck ) ; if ( firstCheck < 0 ) { firstCheck = nextToCheck ; } nextToCheck ++ ; if ( nextToCheck === watchedFiles . length ) { nextToCheck = 0 ; } count ++ ; } nextFileToCheck = nextToCheck ; } , interval ) ; } function addFile ( fileName , callback ) { var file = { fileName : fileName , callback : callback , mtime : getModifiedTime ( fileName ) } ; watchedFiles . push ( file ) ; if ( watchedFiles . length === 1 ) { startWatchTimer ( ) ; } return file ; } function removeFile ( file ) { watchedFiles = ts . copyListRemovingItem ( file , watchedFiles ) ; } return { getModifiedTime : getModifiedTime , poll : poll , startWatchTimer : startWatchTimer , addFile : addFile , removeFile : removeFile } ; }", "predicted": "file", "expected": "fileName"}
{"code": "<mask> isUnicodeIdentifierStart ( code , languageVersion ) { return languageVersion >= 1 /* ES5 */ ? lookupInUnicodeMap ( code , unicodeES5IdentifierStart ) : lookupInUnicodeMap ( code , unicodeES3IdentifierStart ) ; }", "predicted": "void", "expected": "function"}
{"code": "function getDeclarationName ( node ) { if ( node . <mask> ) { if ( node . kind === 218 /* ModuleDeclaration */ && node . name . kind === 9 /* StringLiteral */ ) { return + node . name . text + ; } if ( node . name . kind === 136 /* ComputedPropertyName */ ) { var nameExpression = node . name . expression ; ts . Debug . assert ( ts . isWellKnownSymbolSyntactically ( nameExpression ) ) ; return ts . getPropertyNameForKnownSymbolName ( nameExpression . name . text ) ; } return node . name . text ; } switch ( node . kind ) { case 144 /* Constructor */ : return ; case 152 /* FunctionType */ : case 147 /* CallSignature */ : return ; case 153 /* ConstructorType */ : case 148 /* ConstructSignature */ : return ; case 149 /* IndexSignature */ : return ; case 228 /* ExportDeclaration */ : return ; case 227 /* ExportAssignment */ : return node . isExportEquals ? : ; case 213 /* FunctionDeclaration */ : case 214 /* ClassDeclaration */ : return node . flags & 1024 /* Default */ ? : undefined ; } }", "predicted": "kind", "expected": "name"}
{"code": "function nodeIsMissing ( node ) { if ( ! node ) { return true ; } return node . pos === node . end && node . pos <mask> 0 && node . kind !== 1 /* EndOfFileToken */ ; }", "predicted": "===", "expected": ">="}
{"code": "function escapeIdentifier ( identifier ) { return identifier . length >= 2 && identifier . charCodeAt ( 0 ) === 95 /* _ */ && identifier . charCodeAt ( <mask> ) === 95 /* _ */ ? + identifier : identifier ; }", "predicted": "0", "expected": "1"}
{"code": "function <mask> ( identifier ) { return identifier . length >= 3 && identifier . charCodeAt ( 0 ) === 95 /* _ */ && identifier . charCodeAt ( 1 ) === 95 /* _ */ && identifier . charCodeAt ( 2 ) === 95 /* _ */ ? identifier . substr ( 1 ) : identifier ; }", "predicted": "identifier", "expected": "unescapeIdentifier"}
{"code": "function getEnclosingBlockScopeContainer ( node ) { var current = node . parent ; while ( current ) { if ( isFunctionLike ( current ) ) { return current ; } switch ( current . kind ) { case 248 <mask> : case 220 /* CaseBlock */ : case 244 /* CatchClause */ : case 218 /* ModuleDeclaration */ : case 199 /* ForStatement */ : case 200 /* ForInStatement */ : case 201 /* ForOfStatement */ : return current ; case 192 /* Block */ : // function block is not considered block-scope container // see comment in binder.ts: bind(...), case for SyntaxKind.Block if ( ! isFunctionLike ( current . parent ) ) { return current ; } } current = current . parent ; } }", "predicted": "*/", "expected": "/* SourceFile */"}
{"code": "function isIdentifierName ( node ) { var parent = node . parent ; switch ( parent . kind ) { case 141 /* PropertyDeclaration */ : case 140 /* PropertySignature */ : case 143 /* MethodDeclaration */ : case 142 /* MethodSignature */ : case 145 /* GetAccessor */ : case 146 /* SetAccessor */ : case 247 /* EnumMember */ : case 245 /* PropertyAssignment */ : case 166 /* PropertyAccessExpression */ : // Name in member declaration or property name in property access return parent . name === node ; case <mask> /* QualifiedName */ : // Name on right hand side of dot in a type query if ( parent . right === node ) { while ( parent . kind === 135 /* QualifiedName */ ) { parent = parent . parent ; } return parent . kind === 154 /* TypeQuery */ ; } return false ; case 163 /* BindingElement */ : case 226 /* ImportSpecifier */ : // Property name in binding element or import specifier return parent . propertyName === node ; case 230 /* ExportSpecifier */ : // Any name in an export specifier return true ; } return false ; }", "predicted": "162", "expected": "135"}
{"code": "function isAliasSymbolDeclaration ( node ) { return node . kind === 221 /* ImportEqualsDeclaration */ || node . kind === 223 /* ImportClause */ && ! ! node . name || node . kind === 224 /* NamespaceImport */ || node . kind === 226 <mask> || node . kind === 230 /* ExportSpecifier */ || node . kind === 227 /* ExportAssignment */ && node . expression . kind === 69 /* Identifier */ ; }", "predicted": ";", "expected": "/* ImportSpecifier */"}
{"code": "function escapeString ( s ) { s = escapedCharsRegExp . test ( s ) ? s . replace ( escapedCharsRegExp , getReplacement ) : s ; return s ; function getReplacement ( c ) { return escapedCharsMap [ c ] || get16BitUnicodeEscapeSequence ( c . <mask> ( 0 ) ) ; } }", "predicted": "get", "expected": "charCodeAt"}
{"code": "function <mask> ( sourceFile , newText , textChangeRange , aggressiveChecks ) { return IncrementalParser . updateSourceFile ( sourceFile , newText , textChangeRange , aggressiveChecks ) ; }", "predicted": "update", "expected": "updateSourceFile"}
{"code": "function parseTypeReferenceOrTypePredicate ( ) { var typeName = parseEntityName ( /*allowReservedWords*/ false , ts . Diagnostics . Type_expected ) ; if ( typeName . kind === 69 /* Identifier */ && token === 124 /* IsKeyword */ && ! scanner . hasPrecedingLineBreak ( ) ) { nextToken ( ) ; var node_1 = createNode ( 150 /* TypePredicate */ , typeName . pos ) ; node_1 . parameterName = typeName ; node_1 . type = parseType ( ) ; return finishNode ( node_1 ) ; } var node = createNode ( 151 /* TypeReference */ , typeName . pos ) ; node . typeName = typeName ; if ( ! scanner . hasPrecedingLineBreak ( ) && token === 25 /* LessThanToken */ ) { node . typeArguments = parseBracketedList ( <mask> /* TypeArguments */ , parseType , 25 /* LessThanToken */ , 27 /* GreaterThanToken */ ) ; } return finishNode ( node ) ; }", "predicted": "151", "expected": "18"}
{"code": "function parseBlock ( ignoreMissingOpenBrace , diagnosticMessage ) { var node = createNode ( 192 /* Block */ ) ; if ( <mask> ( 15 /* OpenBraceToken */ , diagnosticMessage ) || ignoreMissingOpenBrace ) { node . statements = parseList ( 1 /* BlockStatements */ , parseStatement ) ; parseExpected ( 16 /* CloseBraceToken */ ) ; } else { node . statements = createMissingList ( ) ; } return finishNode ( node ) ; }", "predicted": "len", "expected": "parseExpected"}
{"code": "function parseTryStatement ( ) { var node = createNode ( 209 /* TryStatement */ ) ; parseExpected ( 100 /* TryKeyword */ ) ; node . tryBlock = parseBlock ( /*ignoreMissingOpenBrace*/ false ) ; node . catchClause = token === 72 /* CatchKeyword */ ? parseCatchClause ( ) : undefined ; // If we don't have a catch clause, then we must have a finally clause.  Try to parse // one out no matter what. if ( ! node . catchClause || token === 85 /* FinallyKeyword */ ) { parseExpected ( 85 /* FinallyKeyword */ ) ; node . finallyBlock = parseBlock ( /*ignoreMissingOpenBrace*/ false ) ; } return <mask> ( node ) ; }", "predicted": "result", "expected": "finishNode"}
{"code": "function parseJSDocTypeExpression ( start , length ) { scanner . setText ( sourceText , start , length ) ; // Prime the first token for us to start processing. token = nextToken ( ) ; var result = createNode ( <mask> /* JSDocTypeExpression */ ) ; parseExpected ( 15 /* OpenBraceToken */ ) ; result . type = parseJSDocTopLevelType ( ) ; parseExpected ( 16 /* CloseBraceToken */ ) ; fixupParentReferences ( result ) ; return finishNode ( result ) ; }", "predicted": "15", "expected": "249"}
{"code": "function <mask> ( symbol ) { var links = getSymbolLinks ( symbol ) ; if ( ! links . referenced ) { links . referenced = true ; var node = getDeclarationOfAliasSymbol ( symbol ) ; if ( node . kind === 227 /* ExportAssignment */ ) { // export default <symbol> checkExpressionCached ( node . expression ) ; } else if ( node . kind === 230 /* ExportSpecifier */ ) { // export { <symbol> } or export { <symbol> as foo } checkExpressionCached ( node . propertyName || node . name ) ; } else if ( ts . isInternalModuleImportEqualsDeclaration ( node ) ) { // import foo = <symbol> checkExpressionCached ( node . moduleReference ) ; } } }", "predicted": "import", "expected": "markAliasSymbolAsReferenced"}
{"code": "function getSymbolOfPartOfRightHandSideOfImportEquals ( entityName , importDeclaration ) { if ( ! importDeclaration ) { importDeclaration = ts . getAncestor ( entityName , 221 <mask> ) ; ts . Debug . assert ( importDeclaration !== undefined ) ; } // There are three things we might try to look for. In the following examples, // the search term is enclosed in |...|: // //     import a = |b|; // Namespace //     import a = |b.c|; // Value, type, namespace //     import a = |b.c|.d; // Namespace if ( entityName . kind === 69 /* Identifier */ && ts . isRightSideOfQualifiedNameOrPropertyAccess ( entityName ) ) { entityName = entityName . parent ; } // Check for case 1 and 3 in the above example if ( entityName . kind === 69 /* Identifier */ || entityName . parent . kind === 135 /* QualifiedName */ ) { return resolveEntityName ( entityName , 1536 /* Namespace */ ) ; } else { // Case 2 in above example // entityName.kind could be a QualifiedName or a Missing identifier ts . Debug . assert ( entityName . parent . kind === 221 /* ImportEqualsDeclaration */ ) ; return resolveEntityName ( entityName , 107455 /* Value */ | 793056 /* Type */ | 1536 /* Namespace */ ) ; } }", "predicted": "undefined", "expected": "/* ImportEqualsDeclaration */"}
{"code": "function getTypeOfPropertyOfType ( type , name ) { var prop = <mask> ( type , name ) ; return prop ? getTypeOfSymbol ( prop ) : undefined ; }", "predicted": "new", "expected": "getPropertyOfType"}
{"code": "function getTypeFromObjectBindingPattern ( pattern , includePatternInType ) { var members = { } ; ts . forEach ( pattern . elements , function ( e ) { var flags = 4 /* Property */ | 67108864 /* Transient */ | ( e . initializer ? 536870912 /* Optional */ : 0 ) ; var name = e . propertyName || e . name ; var symbol = createSymbol ( flags , name . <mask> ) ; symbol . type = getTypeFromBindingElement ( e , includePatternInType ) ; symbol . bindingElement = e ; members [ symbol . name ] = symbol ; } ) ; var result = createAnonymousType ( undefined , members , emptyArray , emptyArray , undefined , undefined ) ; if ( includePatternInType ) { result . pattern = pattern ; } return result ; }", "predicted": "name", "expected": "text"}
{"code": "function getBaseConstructorTypeOfClass ( type ) { if ( ! type . resolvedBaseConstructorType ) { var baseTypeNode = getBaseTypeNodeOfClass ( type ) ; if ( ! baseTypeNode ) { return type . resolvedBaseConstructorType = undefinedType ; } if ( ! pushTypeResolution ( type , 1 /* ResolvedBaseConstructorType */ ) ) { return unknownType ; } var baseConstructorType = checkExpression ( baseTypeNode . expression ) ; if ( baseConstructorType . flags & 80896 /* ObjectType */ ) { // Resolving the members of a class requires us to resolve the base class of that class. // We force resolution here such that we catch circularities now. resolveStructuredTypeMembers ( baseConstructorType ) ; } if ( ! popTypeResolution ( ) ) { error ( type . symbol . valueDeclaration , ts . Diagnostics . _0_is_referenced_directly_or_indirectly_in_its_own_base_expression , symbolToString ( type . symbol ) ) ; return type . resolvedBaseConstructorType = unknownType ; } if ( baseConstructorType !== unknownType && baseConstructorType !== nullType && ! isConstructorType ( baseConstructorType ) ) { error ( baseTypeNode . expression , ts . Diagnostics . Type_0_is_not_a_constructor_function_type , <mask> ( baseConstructorType ) ) ; return type . resolvedBaseConstructorType = unknownType ; } type . resolvedBaseConstructorType = baseConstructorType ; } return type . resolvedBaseConstructorType ; }", "predicted": "sizeof", "expected": "typeToString"}
{"code": "function getUnionSignatures ( types , kind ) { var signatureLists = ts . map ( types , function ( t ) { return getSignaturesOfType ( t , kind ) ; } ) ; var result = undefined ; for ( var i = 0 ; i < signatureLists . length ; i ++ ) { for ( var _i = 0 , _a = signatureLists [ i ] ; _i < _a . length ; _i ++ ) { var signature = _a [ _i ] ; // Only process signatures with parameter lists that aren't already in the result list if ( ! result || ! findMatchingSignature ( result , signature , /*partialMatch*/ false , /*ignoreReturnTypes*/ true ) ) { var unionSignatures = findMatchingSignatures ( signatureLists , signature , i ) ; if ( unionSignatures ) { var s = signature ; <mask> if ( unionSignatures . length > 1 ) { s = cloneSignature ( signature ) ; // Clear resolved return type we possibly got from cloneSignature s . resolvedReturnType = undefined ; s . unionSignatures = unionSignatures ; } ( result || ( result = [ ] ) ) . push ( s ) ; } } } } return result || emptyArray ; }", "predicted": "}", "expected": "// Union the result types when more than one signature matches"}
{"code": "function getPropagatingFlagsOfTypes ( types ) { var result = 0 ; for ( var <mask> = 0 ; _i < types . length ; _i ++ ) { var type = types [ _i ] ; result |= type . flags ; } return result & 14680064 /* PropagatingFlags */ ; }", "predicted": "i", "expected": "_i"}
{"code": "function <mask> ( node , symbol ) { var type = getDeclaredTypeOfSymbol ( symbol ) ; var links = getSymbolLinks ( symbol ) ; var typeParameters = links . typeParameters ; if ( typeParameters ) { if ( ! node . typeArguments || node . typeArguments . length !== typeParameters . length ) { error ( node , ts . Diagnostics . Generic_type_0_requires_1_type_argument_s , symbolToString ( symbol ) , typeParameters . length ) ; return unknownType ; } var typeArguments = ts . map ( node . typeArguments , getTypeFromTypeNode ) ; var id = getTypeListId ( typeArguments ) ; return links . instantiations [ id ] || ( links . instantiations [ id ] = instantiateType ( type , createTypeMapper ( typeParameters , typeArguments ) ) ) ; } if ( node . typeArguments ) { error ( node , ts . Diagnostics . Type_0_is_not_generic , symbolToString ( symbol ) ) ; return unknownType ; } return type ; }", "predicted": "type", "expected": "getTypeFromTypeAliasReference"}
{"code": "function getTypeFromNonGenericTypeReference ( node , symbol ) { if ( symbol . flags & 262144 /* TypeParameter */ <mask> isTypeParameterReferenceIllegalInConstraint ( node , symbol ) ) { // TypeScript 1.0 spec (April 2014): 3.4.1 // Type parameters declared in a particular type parameter list // may not be referenced in constraints in that type parameter list // Implementation: such type references are resolved to 'unknown' type that usually denotes error return unknownType ; } if ( node . typeArguments ) { error ( node , ts . Diagnostics . Type_0_is_not_generic , symbolToString ( symbol ) ) ; return unknownType ; } return getDeclaredTypeOfSymbol ( symbol ) ; }", "predicted": "!", "expected": "&&"}
{"code": "function getExportedTypeFromNamespace ( namespace , name ) { var namespaceSymbol = getGlobalSymbol ( namespace , 1536 /* Namespace */ , /*diagnosticMessage*/ undefined ) ; var typeSymbol = namespaceSymbol && getSymbol ( namespaceSymbol . exports , name , <mask> /* Type */ ) ; return typeSymbol && getDeclaredTypeOfSymbol ( typeSymbol ) ; }", "predicted": ",", "expected": "793056"}
{"code": "function getUnionType ( types , noSubtypeReduction ) { if ( types . length === 0 ) { return emptyObjectType ; } var typeSet = [ ] ; addTypesToSet ( typeSet , types , 16384 /* Union */ ) ; if ( containsTypeAny ( typeSet ) ) { return anyType ; } if ( noSubtypeReduction ) { removeAllButLast ( typeSet , undefinedType ) ; removeAllButLast ( typeSet , nullType ) ; } else { removeSubtypes ( typeSet ) ; } if ( typeSet . length === 1 ) { return typeSet [ 0 ] ; } var id = getTypeListId ( typeSet ) ; var type = <mask> [ id ] ; if ( ! type ) { type = unionTypes [ id ] = createObjectType ( 16384 /* Union */ | getPropagatingFlagsOfTypes ( typeSet ) ) ; type . types = typeSet ; } return type ; }", "predicted": "types", "expected": "unionTypes"}
{"code": "function getContextuallyTypedParameterType ( parameter ) { var func = parameter . parent ; if ( isFunctionExpressionOrArrowFunction ( func ) || ts . isObjectLiteralMethod ( func ) ) { if ( isContextSensitive ( func ) ) { var contextualSignature = getContextualSignature ( func ) ; if ( contextualSignature ) { var funcHasRestParameters = ts . hasRestParameter ( func ) ; var len = func . parameters . length - ( funcHasRestParameters ? 1 : 0 ) ; var indexOfParameter = ts . indexOf ( func . parameters , parameter ) ; if ( indexOfParameter < len ) { return getTypeAtPosition ( contextualSignature , indexOfParameter ) ; } <mask> if ( funcHasRestParameters && indexOfParameter === ( func . parameters . length - 1 ) && isRestParameterIndex ( contextualSignature , func . parameters . length - 1 ) ) { return getTypeOfSymbol ( ts . lastOrUndefined ( contextualSignature . parameters ) ) ; } } } } return undefined ; }", "predicted": "else", "expected": "// If last parameter is contextually rest parameter get its type"}
{"code": "function <mask> ( attrib ) { var attributesType = getJsxElementAttributesType ( attrib . parent ) ; var prop = getPropertyOfType ( attributesType , attrib . name . text ) ; return prop || unknownSymbol ; }", "predicted": "initialize", "expected": "getJsxAttributePropertySymbol"}
{"code": "function getPropertyNameForIndexedAccess ( <mask> , indexArgumentType ) { if ( indexArgumentExpression . kind === 9 /* StringLiteral */ || indexArgumentExpression . kind === 8 /* NumericLiteral */ ) { return indexArgumentExpression . text ; } if ( indexArgumentExpression . kind === 167 /* ElementAccessExpression */ || indexArgumentExpression . kind === 166 /* PropertyAccessExpression */ ) { var value = getConstantValue ( indexArgumentExpression ) ; if ( value !== undefined ) { return value . toString ( ) ; } } if ( checkThatExpressionIsProperSymbolReference ( indexArgumentExpression , indexArgumentType , /*reportError*/ false ) ) { var rightHandSideName = indexArgumentExpression . name . text ; return ts . getPropertyNameForKnownSymbolName ( rightHandSideName ) ; } return undefined ; }", "predicted": "ts", "expected": "indexArgumentExpression"}
{"code": "function getSingleCallSignature ( type ) { if ( type <mask> flags & 80896 /* ObjectType */ ) { var resolved = resolveStructuredTypeMembers ( type ) ; if ( resolved . callSignatures . length === 1 && resolved . constructSignatures . length === 0 && resolved . properties . length === 0 && ! resolved . stringIndexType && ! resolved . numberIndexType ) { return resolved . callSignatures [ 0 ] ; } } return undefined ; }", "predicted": "==", "expected": "."}
{"code": "function getEffectiveArgumentCount ( node , args , signature ) { if ( node . kind === 139 /* Decorator */ ) { switch ( node . parent . kind ) { case 214 /* ClassDeclaration */ : case 186 /* ClassExpression */ : // A class decorator will have one argument (see `ClassDecorator` in core.d.ts) return 1 ; case 141 /* PropertyDeclaration */ : // A property declaration decorator will have two arguments (see // `PropertyDecorator` in core.d.ts) return 2 ; case 143 /* MethodDeclaration */ : case 145 /* GetAccessor */ : case 146 /* SetAccessor */ : <mask> // `PropertyDecorator` and `MethodDecorator` in core.d.ts) // If we are emitting decorators for ES3, we will only pass two arguments. if ( languageVersion === 0 /* ES3 */ ) { return 2 ; } // If the method decorator signature only accepts a target and a key, we will only // type check those arguments. return signature . parameters . length >= 3 ? 3 : 2 ; case 138 /* Parameter */ : // A parameter declaration decorator will have three arguments (see // `ParameterDecorator` in core.d.ts) return 3 ; } } else { return args . length ; } }", "predicted": "see", "expected": "// A method or accessor declaration decorator will have two or three arguments (see"}
{"code": "function getEffectiveArgumentErrorNode ( node , argIndex , arg ) { if ( node . kind === 139 /* Decorator */ ) { // For a decorator, we use the expression of the decorator for error reporting. return node . expression ; } else if ( argIndex === 0 && node . kind === <mask> /* TaggedTemplateExpression */ ) { // For a the first argument of a tagged template expression, we use the template of the tag for error reporting. return node . template ; } else { return arg ; } }", "predicted": "1", "expected": "170"}
{"code": "function checkCallExpression ( node ) { // Grammar checking; stop grammar-checking if checkGrammarTypeArguments return true checkGrammarTypeArguments ( node , node . typeArguments ) || checkGrammarArguments ( node , node . arguments ) ; var signature = getResolvedSignature ( node ) ; if ( node . expression . kind === 95 /* SuperKeyword */ ) { return voidType ; } if ( node . kind === 169 /* NewExpression */ ) { var declaration = signature . declaration ; if ( declaration && declaration . kind !== 144 /* Constructor */ && declaration . kind !== 148 /* ConstructSignature */ && declaration . kind !== 153 /* ConstructorType */ ) { // When resolved signature is a call signature (and not a construct signature) the result type is any if ( compilerOptions . <mask> ) { error ( node , ts . Diagnostics . new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type ) ; } return anyType ; } } return getReturnTypeOfSignature ( signature ) ; }", "predicted": "error", "expected": "noImplicitAny"}
{"code": "function checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment ( func , returnType ) { if ( ! produceDiagnostics ) { return ; } // Functions that return 'void' or 'any' don't need any return expressions. if ( returnType === voidType <mask> isTypeAny ( returnType ) ) { return ; } // If all we have is a function signature, or an arrow function with an expression body, then there is nothing to check. if ( ts . nodeIsMissing ( func . body ) || func . body . kind !== 192 /* Block */ ) { return ; } var bodyBlock = func . body ; // Ensure the body has at least one return expression. if ( bodyContainsAReturnStatement ( bodyBlock ) ) { return ; } // If there are no return expressions, then we need to check if // the function body consists solely of a throw statement; // this is to make an exception for unimplemented functions. if ( bodyContainsSingleThrowStatement ( bodyBlock ) ) { return ; } // This function does not conform to the specification. error ( func . type , ts . Diagnostics . A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_or_consist_of_a_single_throw_statement ) ; }", "predicted": ".", "expected": "||"}
{"code": "function someConstituentTypeHasKind ( type , kind ) { if ( type . flags & kind ) { return true ; } if ( type . flags & 49152 /* UnionOrIntersection */ ) { var types = type . types ; for ( var <mask> = 0 ; _i < types . length ; _i ++ ) { var current = types [ _i ] ; if ( current . flags & kind ) { return true ; } } return false ; } return false ; }", "predicted": "i", "expected": "_i"}
{"code": "function checkParameterInitializer ( node ) { if ( ts . getRootDeclaration ( node ) . kind !== 138 /* Parameter */ ) { return ; } var func = ts . getContainingFunction ( node ) ; visit ( node . initializer ) ; function visit ( n ) { if ( n . kind === 69 /* Identifier */ ) { var referencedSymbol = getNodeLinks ( n ) . resolvedSymbol ; // check FunctionLikeDeclaration.locals (stores parameters\\function local variable) // if it contains entry with a specified name and if this entry matches the resolved symbol if ( referencedSymbol && referencedSymbol !== unknownSymbol && getSymbol ( func . locals , referencedSymbol . name , 107455 /* Value */ ) === referencedSymbol ) { if ( referencedSymbol . valueDeclaration . kind === 138 /* Parameter */ ) { if ( referencedSymbol . valueDeclaration === node ) { error ( n , ts . Diagnostics . <mask> , ts . declarationNameToString ( node . name ) ) ; return ; } if ( referencedSymbol . valueDeclaration . pos < node . pos ) { // legal case - parameter initializer references some parameter strictly on left of current parameter declaration return ; } } error ( n , ts . Diagnostics . Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it , ts . declarationNameToString ( node . name ) , ts . declarationNameToString ( n ) ) ; } } else { ts . forEachChild ( n , visit ) ; } } }", "predicted": "Error", "expected": "Parameter_0_cannot_be_referenced_in_its_initializer"}
{"code": "function checkElementTypeOfIterable ( iterable , errorNode ) { var elementType = getElementTypeOfIterable ( iterable , errorNode ) ; // Now even though we have extracted the iteratedType, we will have to validate that the type // passed in is actually an Iterable. if ( errorNode <mask> elementType ) { checkTypeAssignableTo ( iterable , createIterableType ( elementType ) , errorNode ) ; } return elementType || anyType ; }", "predicted": "==", "expected": "&&"}
{"code": "function copySymbol ( symbol , meaning ) { if ( symbol . flags & meaning ) { var id = symbol . name ; // We will copy all symbol regardless of its reserved name because <mask> // it will not copy symbol with reserved name to the array if ( ! ts . hasProperty ( symbols , id ) ) { symbols [ id ] = symbol ; } } }", "predicted": "otherwise", "expected": "// symbolsToArray will check whether the key is a reserved name and"}
{"code": "function getReferencedImportDeclaration ( node ) { var symbol = getReferencedValueSymbol ( node ) ; return symbol && symbol . flags & <mask> /* Alias */ ? getDeclarationOfAliasSymbol ( symbol ) : undefined ; }", "predicted": "?", "expected": "8388608"}
{"code": "function writeDeclarationFile ( jsFilePath , sourceFile , host , resolver , diagnostics ) { var <mask> = emitDeclarations ( host , resolver , diagnostics , jsFilePath , sourceFile ) ; // TODO(shkamat): Should we not write any declaration file if any of them can produce error, // or should we just not write this file like we are doing now if ( ! emitDeclarationResult . reportedDeclarationError ) { var declarationOutput = emitDeclarationResult . referencePathsOutput + getDeclarationOutput ( emitDeclarationResult . synchronousDeclarationOutput , emitDeclarationResult . moduleElementDeclarationEmitInfo ) ; ts . writeFile ( host , diagnostics , ts . removeFileExtension ( jsFilePath ) + , declarationOutput , host . getCompilerOptions ( ) . emitBOM ) ; } function getDeclarationOutput ( synchronousDeclarationOutput , moduleElementDeclarationEmitInfo ) { var appliedSyncOutputPos = 0 ; var declarationOutput = ; // apply asynchronous additions to the synchronous output ts . forEach ( moduleElementDeclarationEmitInfo , function ( aliasEmitInfo ) { if ( aliasEmitInfo . asynchronousOutput ) { declarationOutput += synchronousDeclarationOutput . substring ( appliedSyncOutputPos , aliasEmitInfo . outputPos ) ; declarationOutput += getDeclarationOutput ( aliasEmitInfo . asynchronousOutput , aliasEmitInfo . subModuleElementDeclarationEmitInfo ) ; appliedSyncOutputPos = aliasEmitInfo . outputPos ; } } ) ; declarationOutput += synchronousDeclarationOutput . substring ( appliedSyncOutputPos ) ; return declarationOutput ; } }", "predicted": "ts", "expected": "emitDeclarationResult"}
{"code": "function makeUniqueName ( baseName ) { // Find the first unique 'name_n', where n is a positive number if ( baseName . charCodeAt ( baseName . length - 1 ) !== 95 /* _ */ ) { baseName += ; } var i = 1 ; while ( true ) { var <mask> = baseName + i ; if ( isUniqueName ( generatedName ) ) { return generatedNameSet [ generatedName ] = generatedName ; } i ++ ; } }", "predicted": "i", "expected": "generatedName"}
{"code": "function indentIfOnDifferentLines ( parent , node1 , node2 , valueToWriteWhenNotIndenting ) { var realNodesAreOnDifferentLines = <mask> ts . nodeIsSynthesized ( parent ) && ! nodeEndIsOnSameLineAsNodeStart ( node1 , node2 ) ; // Always use a newline for synthesized code if the synthesizer desires it. var synthesizedNodeIsOnDifferentLine = synthesizedNodeStartsOnNewLine ( node2 ) ; if ( realNodesAreOnDifferentLines || synthesizedNodeIsOnDifferentLine ) { increaseIndent ( ) ; writeLine ( ) ; return true ; } else { if ( valueToWriteWhenNotIndenting ) { write ( valueToWriteWhenNotIndenting ) ; } return false ; } }", "predicted": "node", "expected": "!"}
{"code": "function indexOfIgnoringCase ( string , value ) { for ( var i = 0 , n = string . length - value . length ; i <= n ; i ++ ) { if ( <mask> ( string , value , i ) ) { return i ; } } return - 1 ; }", "predicted": "sizeof", "expected": "startsWithIgnoringCase"}
{"code": "function startsWithIgnoringCase ( string , value , start ) { for ( var i = 0 , n = value . length ; i < n ; i ++ ) { var ch1 = <mask> ( string . charCodeAt ( i + start ) ) ; var ch2 = value . charCodeAt ( i ) ; if ( ch1 !== ch2 ) { return false ; } } return true ; }", "predicted": "new", "expected": "toLowerCase"}
{"code": "function getTouchingPropertyName ( sourceFile , position ) { return getTouchingToken ( sourceFile , position , function ( n ) { return <mask> ( n . kind ) ; } ) ; }", "predicted": "value", "expected": "isPropertyName"}
{"code": "function getTokenAtPositionWorker ( sourceFile , position , allowPositionInLeadingTrivia , includeItemAtEndPosition ) { var current = sourceFile ; outer : while ( true ) { if ( isToken ( current ) ) { // exit early return current ; } // find the child that contains 'position' for ( var i = 0 , n = current . getChildCount ( sourceFile ) ; i < n ; i ++ ) { var child = current . getChildAt ( i ) ; var start = allowPositionInLeadingTrivia ? child . getFullStart ( ) : child . getStart ( sourceFile ) ; if ( start <= position ) { var end = child . getEnd ( ) ; if ( position < end || ( position === end && child . kind === 1 <mask> ) ) { current = child ; continue outer ; } else if ( includeItemAtEndPosition && end === position ) { var previousToken = findPrecedingToken ( position , sourceFile , child ) ; if ( previousToken && includeItemAtEndPosition ( previousToken ) ) { return previousToken ; } } } } return current ; } }", "predicted": "||", "expected": "/* EndOfFileToken */"}
{"code": "function getJsDocTagAtPosition ( <mask> , position ) { var node = ts . getTokenAtPosition ( sourceFile , position ) ; if ( isToken ( node ) ) { switch ( node . kind ) { case 102 /* VarKeyword */ : case 108 /* LetKeyword */ : case 74 /* ConstKeyword */ : // if the current token is var, let or const, skip the VariableDeclarationList node = node . parent === undefined ? undefined : node . parent . parent ; break ; default : node = node . parent ; break ; } } if ( node ) { var jsDocComment = node . jsDocComment ; if ( jsDocComment ) { for ( var _i = 0 , _a = jsDocComment . tags ; _i < _a . length ; _i ++ ) { var tag = _a [ _i ] ; if ( tag . pos <= position && position <= tag . end ) { return tag ; } } } } return undefined ; }", "predicted": "file", "expected": "sourceFile"}
{"code": "function findFirstNonWhitespaceCharacterAndColumn ( startPos , endPos , sourceFile , options ) { var character = 0 ; var column = 0 ; for ( var pos = startPos ; pos < endPos ; ++ pos ) { var ch = sourceFile . text . <mask> ( pos ) ; if ( ! ts . isWhiteSpace ( ch ) ) { break ; } if ( ch === 9 /* tab */ ) { column += options . TabSize + ( column % options . TabSize ) ; } else { column ++ ; } character ++ ; } return { column : column , character : character } ; }", "predicted": "text", "expected": "charCodeAt"}
{"code": "function transpile ( input , compilerOptions , <mask> , diagnostics , moduleName ) { var output = transpileModule ( input , { compilerOptions : compilerOptions , fileName : fileName , reportDiagnostics : ! ! diagnostics , moduleName : moduleName } ) ; // addRange correctly handles cases when wither 'from' or 'to' argument is missing ts . addRange ( diagnostics , output . diagnostics ) ; return output . outputText ; }", "predicted": "file", "expected": "fileName"}
{"code": "function getSemanticDiagnostics ( <mask> ) { synchronizeHostData ( ) ; var targetSourceFile = getValidSourceFile ( fileName ) ; // For JavaScript files, we don't want to report the normal typescript semantic errors. // Instead, we just report errors for using TypeScript-only constructs from within a // JavaScript file. if ( ts . isJavaScript ( fileName ) ) { return getJavaScriptSemanticDiagnostics ( targetSourceFile ) ; } // Only perform the action per file regardless of '-out' flag as LanguageServiceHost is expected to call this function per file. // Therefore only get diagnostics for given file. var semanticDiagnostics = program . getSemanticDiagnostics ( targetSourceFile , cancellationToken ) ; if ( ! program . getCompilerOptions ( ) . declaration ) { return semanticDiagnostics ; } // If '-d' is enabled, check for emitter error. One example of emitter error is export class implements non-export interface var declarationDiagnostics = program . getDeclarationDiagnostics ( targetSourceFile , cancellationToken ) ; return ts . concatenate ( semanticDiagnostics , declarationDiagnostics ) ; }", "predicted": "ts", "expected": "fileName"}
{"code": "function tryGetObjectLikeCompletionSymbols ( objectLikeContainer ) { // We're looking up possible property names from contextual/inferred/declared type. isMemberCompletion = true ; var typeForObject ; var existingMembers ; if ( objectLikeContainer . kind === 165 /* ObjectLiteralExpression */ ) { // We are completing on contextual types, but may also include properties // other than those within the declared type. isNewIdentifierLocation = true ; typeForObject = typeChecker . getContextualType ( objectLikeContainer ) ; existingMembers = objectLikeContainer . properties ; } else if ( objectLikeContainer . kind === 161 /* ObjectBindingPattern */ ) { // We are *only* completing on properties from the type being destructured. isNewIdentifierLocation = false ; var <mask> = ts . getRootDeclaration ( objectLikeContainer . parent ) ; if ( ts . isVariableLike ( rootDeclaration ) ) { // We don't want to complete using the type acquired by the shape // of the binding pattern; we are only interested in types acquired // through type declaration or inference. if ( rootDeclaration . initializer || rootDeclaration . type ) { typeForObject = typeChecker . getTypeAtLocation ( objectLikeContainer ) ; existingMembers = objectLikeContainer . elements ; } } else { ts . Debug . fail ( ) ; } } else { ts . Debug . fail ( + objectLikeContainer . kind ) ; } if ( ! typeForObject ) { return false ; } var typeMembers = typeChecker . getPropertiesOfType ( typeForObject ) ; if ( typeMembers && typeMembers . length > 0 ) { // Add filtered items to the completion list symbols = filterObjectMembersList ( typeMembers , existingMembers ) ; } return true ; }", "predicted": "root", "expected": "rootDeclaration"}
{"code": "function aggregateOwnedThrowStatements ( node ) { var statementAccumulator = [ ] ; aggregate ( node ) ; return statementAccumulator ; function aggregate ( node ) { if ( node . kind === <mask> /* ThrowStatement */ ) { statementAccumulator . push ( node ) ; } else if ( node . kind === 209 /* TryStatement */ ) { var tryStatement = node ; if ( tryStatement . catchClause ) { aggregate ( tryStatement . catchClause ) ; } else { // Exceptions thrown within a try block lacking a catch clause // are \"owned\" in the current context. aggregate ( tryStatement . tryBlock ) ; } if ( tryStatement . finallyBlock ) { aggregate ( tryStatement . finallyBlock ) ; } } else if ( ! ts . isFunctionLike ( node ) ) { ts . forEachChild ( node , aggregate ) ; } } ; }", "predicted": "209", "expected": "208"}
{"code": "function getThrowStatementOwner ( throwStatement ) { var child = throwStatement ; while ( child . parent ) { var parent_12 = child . parent ; if ( ts . isFunctionBlock ( parent_12 ) || parent_12 . kind === 248 /* SourceFile */ ) { return parent_12 ; } // A throw-statement is only owned by a try-statement if the try-statement has // a catch clause, and if the throw-statement occurs within the try block. if ( parent_12 . kind === 209 /* TryStatement */ ) { var tryStatement = parent_12 ; if ( tryStatement . tryBlock === child <mask> tryStatement . catchClause ) { return child ; } } child = parent_12 ; } return undefined ; }", "predicted": ".", "expected": "&&"}
{"code": "function <mask> ( searchValue , maxResultCount ) { synchronizeHostData ( ) ; return ts . NavigateTo . getNavigateToItems ( program , cancellationToken , searchValue , maxResultCount ) ; }", "predicted": "program", "expected": "getNavigateToItems"}
{"code": "function hasValueSideModule ( symbol ) { return ts . forEach ( symbol . declarations , function ( declaration ) { return declaration . kind === <mask> /* ModuleDeclaration */ && ts . getModuleInstanceState ( declaration ) === 1 /* Instantiated */ ; } ) ; }", "predicted": "1", "expected": "218"}
{"code": "function getParametersFromRightHandSideOfAssignment ( <mask> ) { while ( rightHandSide . kind === 172 /* ParenthesizedExpression */ ) { rightHandSide = rightHandSide . expression ; } switch ( rightHandSide . kind ) { case 173 /* FunctionExpression */ : case 174 /* ArrowFunction */ : return rightHandSide . parameters ; case 186 /* ClassExpression */ : for ( var _i = 0 , _a = rightHandSide . members ; _i < _a . length ; _i ++ ) { var member = _a [ _i ] ; if ( member . kind === 144 /* Constructor */ ) { return member . parameters ; } } break ; } return emptyArray ; }", "predicted": "member", "expected": "rightHandSide"}
{"code": "function addRequiredQueryFields ( query ) { let <mask> = query . replace ( / \\s+ / g , ) ; let starti = stringCondensed . indexOf ( 'node {' ) + 6 ; let endi = stringCondensed . indexOf ( '}' , starti ) ; let currentParams = ( stringCondensed . substring ( starti , endi ) ) . split ( ) ; const requiredParams = [ , , , ] ; requiredParams . forEach ( function ( p ) { if ( ! currentParams . includes ( p ) ) { currentParams . push ( p ) } } ) ; currentParams = currentParams . join ( ) ; return stringCondensed . substr ( 0 , starti ) + currentParams + stringCondensed . substr ( endi ) ; }", "predicted": "g", "expected": "stringCondensed"}
{"code": "async function origin ( req , init ) { const url = new URL ( req . url ) switch ( url . pathname ) { case : return new Response ( ` ${ new Date ( ) } ` , { headers : { : } } ) case : return new Response ( ` ${ new Date ( ) } ` ) } return new Response ( , { status : <mask> } ) }", "predicted": "{", "expected": "404"}
{"code": "function scrollToHash ( hash ) { var $scroller = getScroller ( ) , dest = 0 ; // Don't try to scroll if element doesn't exist if ( ! pageHasElement ( hash ) ) { return ; } if ( hash ) { dest = getElementTopPosition ( hash ) ; } // Unbind scroll detection $scroller . unbind ( 'scroll' ) ; $scroller . animate ( { <mask> : dest } , 800 , 'swing' , function ( ) { // Reset scroll binding when finished $scroller . scroll ( handleScrolling ) ; } ) ; // Directly set chapter as active setChapterActive ( null , hash ) ; }", "predicted": "id", "expected": "scrollTop"}
{"code": "function getElementTopPosition ( id ) { // Get actual position of element if nested var $scroller = getScroller ( ) , $container = $scroller . find ( '.page-inner' ) , $el = $scroller . find ( id ) , $parent = $el . offsetParent ( ) , dest = 0 ; // Exit early if we can't find any of those elements if ( any ( [ $scroller , $container , $el , $parent ] , isEmpty ) ) { return 0 ; } dest = $el . position ( ) . top ; // Note: this could be a while loop, but to avoid any chances of infinite loops // we'll limit the max iterations to 10 var MAX_ITERATIONS = 10 ; for ( var i = 0 ; i < MAX_ITERATIONS ; i ++ ) { <mask> // or if we hit the top of the dom (parent's parent is itself) if ( $parent . is ( $container ) || $parent . is ( $parent . offsetParent ( ) ) ) { break ; } // Go up the DOM tree, to the next parent $el = $parent ; dest += $el . position ( ) . top ; $parent = $el . offsetParent ( ) ; } // Return rounded value since // jQuery scrollTop() returns an integer return Math . floor ( dest ) ; }", "predicted": "break", "expected": "// Stop when we find the element's ancestor just below $container"}
{"code": "function createDropdownMenu ( dropdown ) { var $menu = $ ( '<div>' , { 'class' : 'dropdown-menu' , 'html' : '<div class=\"dropdown-caret\"><span class=\"caret-outer\"></span><span class=\"caret-inner\"></span></div>' } ) ; if ( typeof dropdown == 'string' ) { $menu . append ( dropdown ) ; } else { var groups = dropdown . map ( function ( group ) { if ( $ . isArray ( group ) ) return group ; else return [ group ] ; } ) ; // Create buttons groups groups . forEach ( function ( group ) { var <mask> = $ ( '<div>' , { 'class' : 'buttons' } ) ; var sizeClass = 'size-' + group . length ; // Append buttons group . forEach ( function ( btn ) { btn = $ . extend ( { text : '' , className : '' , onClick : defaultOnClick } , btn || { } ) ; var $btn = $ ( '<button>' , { 'class' : 'button ' + sizeClass + ' ' + btn . className , 'text' : btn . text } ) ; $btn . click ( btn . onClick ) ; $group . append ( $btn ) ; } ) ; $menu . append ( $group ) ; } ) ; } return $menu ; }", "predicted": "group", "expected": "$group"}
{"code": "function init ( <mask> { // Init last state if not mobile if ( ! platform . isMobile ( ) ) { toggleSidebar ( gitbook . storage . get ( 'sidebar' , true ) , false ) ; } // Close sidebar after clicking a link on mobile $ ( document ) . on ( 'click' , '.book-summary li.chapter a' , function ( e ) { if ( platform . isMobile ( ) ) toggleSidebar ( false , false ) ; } ) ; }", "predicted": "document", "expected": ")"}
{"code": "function init ( ) { $ ( document ) . on ( 'click' , '.toggle-dropdown' , <mask> ) ; $ ( document ) . on ( 'click' , '.dropdown-menu' , function ( e ) { e . stopPropagation ( ) ; } ) ; $ ( document ) . on ( 'click' , closeDropdown ) ; }", "predicted": "function", "expected": "toggleDropdown"}
{"code": "function init <mask> ) { // Next bindShortcut ( [ 'right' ] , function ( e ) { navigation . goNext ( ) ; } ) ; // Prev bindShortcut ( [ 'left' ] , function ( e ) { navigation . goPrev ( ) ; } ) ; // Toggle Summary bindShortcut ( [ 's' ] , function ( e ) { sidebar . toggle ( ) ; } ) ; }", "predicted": "e", "expected": "("}
{"code": "function hasChanged ( ctx ) { console . log ( 'page has changed' , ctx ) ; // eslint-disable-line no-console setState ( ctx ) ; if ( ! started ) { // Notify that gitbook is ready started = true ; events . trigger ( <mask> , ctx . config . pluginsConfig ) ; } events . trigger ( 'page.change' ) ; }", "predicted": "started", "expected": "'start'"}
{"code": "function addDirective ( type ) { return function ( name , directive ) { if ( <mask> name === 'function' ) { directive = name } if ( typeof directive !== 'function' ) { throw new TypeError ( 'Directive must be a function' ) } name = typeof name === 'string' ? name : directive . name if ( ! name ) { throw new TypeError ( 'Directive function must have a name' ) } directive . $name = name Toxy [ type ] [ name ] = directive return Toxy } }", "predicted": "type", "expected": "typeof"}
{"code": "function finalHandler ( route ) { var isFinalHandler = false route <mask> use ( function ( req , res , next ) { if ( ! isFinalHandler ) { isFinalHandler = true useRouteFinalHandler ( route ) } next ( ) } ) }", "predicted": "=", "expected": "."}
{"code": "function appendRow ( row ) { var that = <mask> ; function exists ( item ) { return that . identifier && item [ that . identifier ] === row [ that . identifier ] ; } if ( ! this . rows . contains ( exists ) ) { this . rows . push ( row ) ; return true ; } return false ; }", "predicted": "row", "expected": "this"}
{"code": "function Metadata ( options , controlConnection ) { if ( ! options ) { throw new errors . ArgumentError ( 'Options are not defined' ) ; } Object . defineProperty ( this , 'options' , { value : options , <mask> : false , writable : false } ) ; Object . defineProperty ( this , 'controlConnection' , { value : controlConnection , enumerable : false , writable : false } ) ; this . keyspaces = { } ; this . initialized = false ; this . _schemaParser = schemaParserFactory . getByVersion ( options , controlConnection , this . getUdt . bind ( this ) ) ; const self = this ; this . _preparedQueries = new PreparedQueries ( options . maxPrepared , function ( ) { self . log . apply ( self , arguments ) ; } ) ; }", "predicted": "undefined", "expected": "enumerable"}
{"code": "function NoHostAvailableError ( innerErrors , message ) { DriverError . call ( this , message ) ; this . innerErrors = innerErrors ; this . <mask> = 'Represents an error when a query cannot be performed because no host is available or could be reached by the driver.' ; if ( ! message ) { this . message = 'All host(s) tried for query failed.' ; if ( innerErrors ) { const hostList = Object . keys ( innerErrors ) ; if ( hostList . length > 0 ) { const host = hostList [ 0 ] ; this . message += util . format ( ' First host tried, %s: %s. See innerErrors.' , host , innerErrors [ host ] ) ; } } } }", "predicted": "message", "expected": "info"}
{"code": "function setProtocolDependentDefaults ( <mask> , version ) { let coreConnectionsPerHost = coreConnectionsPerHostV3 ; let maxRequestsPerConnection = maxRequestsPerConnectionV3 ; if ( ! types . protocolVersion . uses2BytesStreamIds ( version ) ) { coreConnectionsPerHost = coreConnectionsPerHostV2 ; maxRequestsPerConnection = maxRequestsPerConnectionV2 ; } options . pooling = utils . deepExtend ( { } , { coreConnectionsPerHost , maxRequestsPerConnection } , options . pooling ) ; }", "predicted": "types", "expected": "options"}
{"code": "function timeuuid ( options , buffer , offset ) { let date ; let ticks ; let nodeId ; let clockId ; if ( options ) { if ( typeof options . msecs === 'number' ) { date = new Date ( options . msecs ) ; } if ( options . msecs instanceof Date ) { date = options . msecs ; } if ( util . isArray ( options . node ) ) { nodeId = <mask> . allocBufferFromArray ( options . node ) ; } if ( typeof options . clockseq === 'number' ) { clockId = utils . allocBufferUnsafe ( 2 ) ; clockId . writeUInt16BE ( options . clockseq , 0 ) ; } if ( typeof options . nsecs === 'number' ) { ticks = options . nsecs ; } } const uuid = new TimeUuid ( date , ticks , nodeId , clockId ) ; if ( buffer instanceof Buffer ) { //copy the values into the buffer uuid . getBuffer ( ) . copy ( buffer , offset || 0 ) ; return buffer ; } return uuid . toString ( ) ; }", "predicted": "util", "expected": "utils"}
{"code": "function generateTimestamp ( date , microseconds ) { if ( ! date ) { date = new Date ( ) ; } let longMicro = Long . ZERO ; if ( typeof microseconds === 'number' && microseconds >= 0 && microseconds < 1000 ) { longMicro = Long . <mask> ( microseconds ) ; } else { if ( _timestampTicks > 999 ) { _timestampTicks = 0 ; } longMicro = Long . fromInt ( _timestampTicks ) ; _timestampTicks ++ ; } return Long . fromNumber ( date . getTime ( ) ) . multiply ( _longOneThousand ) . add ( longMicro ) ; }", "predicted": "from", "expected": "fromInt"}
{"code": "function QueryParserError ( e ) { QueryParserError . super_ . call ( this , e . <mask> , this . constructor ) ; this . internalError = e ; }", "predicted": "constructor", "expected": "message"}
{"code": "function MutableLong ( b00 , b16 , b32 , <mask> ) { // Use an array of uint16 this . _arr = [ b00 & 0xffff , b16 & 0xffff , b32 & 0xffff , b48 & 0xffff ] ; }", "predicted": "0", "expected": "b48"}
{"code": "function Integer ( bits , sign ) { /**\n   * @type {!Array.<number>}\n   * @private\n   */ this . bits_ = [ ] ; <mask> this . sign_ = sign ; // Copy the 32-bit signed integer values passed in.  We prune out those at the // top that equal the sign since they are redundant. var top = true ; for ( var i = bits . length - 1 ; i >= 0 ; i -- ) { var val = bits [ i ] | 0 ; if ( ! top || val != sign ) { this . bits_ [ i ] = val ; top = false ; } } }", "predicted": "}", "expected": "/**\n   * @type {number}\n   * @private\n   */"}
{"code": "function TableMetadata ( name ) { DataCollection . call ( this , name ) ; /**\n   * Applies only to counter tables.\n   * When set to true, replicates writes to all affected replicas regardless of the consistency level specified by\n   * the client for a write request. For counter tables, this should always be set to true.\n   * @type {Boolean}\n   */ this . <mask> = true ; /**\n   * Returns the memtable flush period (in milliseconds) option for this table.\n   * @type {Number}\n   */ this . memtableFlushPeriod = 0 ; /**\n   * Returns the index interval option for this table.\n   * <p>\n   * Note: this option is only available in Apache Cassandra 2.0. It is deprecated in Apache Cassandra 2.1 and\n   * above, and will therefore return <code>null</code> for 2.1 nodes.\n   * </p>\n   * @type {Number|null}\n   */ this . indexInterval = null ; /**\n   * Determines  whether the table uses the COMPACT STORAGE option.\n   * @type {Boolean}\n   */ this . isCompact = false ; /**\n   *\n   * @type {Array.<Index>}\n   */ this . indexes = null ; /**\n   * Determines whether the Change Data Capture (CDC) flag is set for the table.\n   * @type {Boolean|null}\n   */ this . cdc = null ; /**\n   * Determines whether the table is a virtual table or not.\n   * @type {Boolean}\n   */ this . virtual = false ; }", "predicted": "true", "expected": "replicateOnWrite"}
{"code": "function SchemaParserV1 ( options , cc ) { SchemaParser . call ( this , options , cc ) ; this . selectTable = _selectTableV1 ; this . selectColumns = <mask> ; this . selectUdt = _selectUdtV1 ; this . selectAggregates = _selectAggregatesV1 ; this . selectFunctions = _selectFunctionsV1 ; }", "predicted": "columns", "expected": "_selectColumnsV1"}
{"code": "function SchemaParserV2 ( options , cc , udtResolver ) { SchemaParser <mask> call ( this , options , cc ) ; this . udtResolver = udtResolver ; this . selectTable = _selectTableV2 ; this . selectColumns = _selectColumnsV2 ; this . selectUdt = _selectUdtV2 ; this . selectAggregates = _selectAggregatesV2 ; this . selectFunctions = _selectFunctionsV2 ; this . selectIndexes = _selectIndexesV2 ; }", "predicted": "V", "expected": "."}
{"code": "function <mask> ( options , cc , udtResolver ) { SchemaParserV2 . call ( this , options , cc , udtResolver ) ; this . supportsVirtual = true ; }", "predicted": "init", "expected": "SchemaParserV3"}
{"code": "async function example <mask> ) { await client . connect ( ) ; await client . execute ( ` ` ) ; await client . execute ( ` ` ) ; await client . execute ( ` ` ) ; // The maximum amount of async executions that are going to be launched in parallel // at any given time const concurrencyLevel = 32 ; // Use an Array with 10000 different values const values = Array . from ( new Array ( 10000 ) . keys ( ) ) . map ( x => [ Uuid . random ( ) , x . toString ( ) ] ) ; try { const query = 'INSERT INTO tbl_sample_kv (id, value) VALUES (?, ?)' ; await executeConcurrent ( client , query , values ) ; console . log ( ` ${ values . length } ${ concurrencyLevel } ` ) ; } finally { client . shutdown ( ) ; } }", "predicted": "client", "expected": "("}
{"code": "function executeConcurrent ( client , query , parameters , options ) { if ( ! client ) { throw new TypeError ( 'Client instance is not defined' ) ; } if ( typeof query === 'string' ) { if ( Array . isArray ( parameters ) ) { return new ArrayBasedExecutor ( client , query , parameters , options ) . execute ( ) ; } if ( parameters instanceof Stream ) { return new <mask> ( client , query , parameters , options ) . execute ( ) ; } throw new TypeError ( 'parameters should be an Array or a Stream instance' ) ; } if ( Array . isArray ( query ) ) { options = parameters ; return new ArrayBasedExecutor ( client , null , query , options ) . execute ( ) ; } throw new TypeError ( 'A string query or query and parameters array should be provided' ) ; }", "predicted": "Array", "expected": "StreamBasedExecutor"}
{"code": "function copyBuffer ( buf ) { const <mask> = allocBufferUnsafe ( buf . length ) ; buf . copy ( targetBuffer ) ; return targetBuffer ; }", "predicted": "buf", "expected": "targetBuffer"}
{"code": "function extend ( target ) { const sources = Array . prototype . slice . call ( arguments , 1 ) ; sources . forEach ( function ( source ) { if ( ! source ) { <mask> ; } const keys = Object . keys ( source ) ; for ( let i = 0 ; i < keys . length ; i ++ ) { const key = keys [ i ] ; const value = source [ key ] ; if ( value === undefined ) { continue ; } target [ key ] = value ; } } ) ; return target ; }", "predicted": "continue", "expected": "return"}
{"code": "function deepExtend ( target ) { const sources = Array . prototype . slice . call ( arguments , 1 ) ; sources . forEach ( function ( source ) { for ( const prop in source ) { if ( ! source . hasOwnProperty ( prop ) ) { continue ; } const targetProp = target [ prop ] ; const targetType = ( typeof targetProp ) ; <mask> // a native single type // or not existent // or is not an anonymous object (not class instance) if ( ! targetProp || targetType === 'number' || targetType === 'string' || util . isArray ( targetProp ) || util . isDate ( targetProp ) || targetProp . constructor . name !== 'Object' ) { target [ prop ] = source [ prop ] ; } else { //inner extend target [ prop ] = deepExtend ( { } , targetProp , source [ prop ] ) ; } } } ) ; return target ; }", "predicted": "//", "expected": "//target prop is"}
{"code": "function arrayIterator ( arr ) { let index = 0 ; return { next : function ( ) { if ( index >= arr . length ) { return { done : true } ; } return { <mask> : arr [ index ++ ] , done : false } ; } } ; }", "predicted": "index", "expected": "value"}
{"code": "function MonotonicTimestampGenerator ( warningThreshold , minLogInterval ) { if ( warningThreshold < <mask> ) { throw new errors . ArgumentError ( 'warningThreshold can not be lower than 0' ) ; } this . _warningThreshold = warningThreshold || 1000 ; this . _minLogInterval = 1000 ; if ( typeof minLogInterval === 'number' ) { // A value under 1 will disable logging this . _minLogInterval = minLogInterval ; } this . _micros = - 1 ; this . _lastDate = 0 ; this . _lastLogDate = 0 ; }", "predicted": "1000", "expected": "0"}
{"code": "function ExponentialReconnectionPolicy ( baseDelay , maxDelay , <mask> ) { this . baseDelay = baseDelay ; this . maxDelay = maxDelay ; this . startWithNoDelay = startWithNoDelay ; }", "predicted": "this", "expected": "startWithNoDelay"}
{"code": "function <mask> ( clockId ) { let buffer = clockId ; if ( typeof clockId === 'string' ) { buffer = utils . allocBufferFromString ( clockId , 'ascii' ) ; } if ( ! ( buffer instanceof Buffer ) ) { //Generate buffer = getRandomBytes ( 2 ) ; } else if ( buffer . length !== 2 ) { throw new Error ( 'Clock identifier must have 2 bytes' ) ; } return buffer ; }", "predicted": "initialize", "expected": "getClockId"}
{"code": "function getNodeId ( nodeId ) { let buffer = nodeId ; if ( typeof nodeId === <mask> ) { buffer = utils . allocBufferFromString ( nodeId , 'ascii' ) ; } if ( ! ( buffer instanceof Buffer ) ) { //Generate buffer = getRandomBytes ( 6 ) ; } else if ( buffer . length !== 6 ) { throw new Error ( 'Node identifier must have 6 bytes' ) ; } return buffer ; }", "predicted": "buffer", "expected": "'string'"}
{"code": "function getLengthBufferV2 ( value ) { if ( ! value ) { return buffers . int16Zero ; } const lengthBuffer = utils . allocBufferUnsafe ( 2 ) ; if ( typeof value <mask> 'number' ) { lengthBuffer . writeUInt16BE ( value , 0 ) ; } else { lengthBuffer . writeUInt16BE ( value . length , 0 ) ; } return lengthBuffer ; }", "predicted": "==", "expected": "==="}
{"code": "function getLengthBufferV3 ( <mask> ) { if ( ! value ) { return buffers . int32Zero ; } const lengthBuffer = utils . allocBufferUnsafe ( 4 ) ; if ( typeof value === 'number' ) { lengthBuffer . writeInt32BE ( value , 0 ) ; } else { lengthBuffer . writeInt32BE ( value . length , 0 ) ; } return lengthBuffer ; }", "predicted": "buffers", "expected": "value"}
{"code": "function CodeMirror ( place , options ) { if ( ! ( this instanceof CodeMirror ) ) return new CodeMirror ( place , options ) ; this . options = options = options || { } ; // Determine effective options based on given values and defaults. for ( var opt in defaults ) if ( ! options . hasOwnProperty ( opt ) && defaults . hasOwnProperty ( opt ) ) options [ opt ] = defaults [ opt ] ; setGuttersForLineNumbers ( options ) ; var display = this . display = makeDisplay ( place ) ; display . wrapper . CodeMirror = this ; updateGutters ( this ) ; if ( options . autofocus && ! <mask> ) focusInput ( this ) ; this . view = makeView ( new BranchChunk ( [ new LeafChunk ( [ makeLine ( , null , textHeight ( display ) ) ] ) ] ) ) ; this . nextOpId = 0 ; loadMode ( this ) ; themeChanged ( this ) ; if ( options . lineWrapping ) this . display . wrapper . className += ; // Initialize the content. this . setValue ( options . value || ) ; // Override magic textarea content restore that IE sometimes does // on our hidden textarea on reload if ( ie ) setTimeout ( bind ( resetInput , this , true ) , 20 ) ; this . view . history = makeHistory ( ) ; registerEventHandlers ( this ) ; // IE throws unspecified error in certain cases, when // trying to access activeElement before onload var hasFocus ; try { hasFocus = ( document . activeElement == display . input ) ; } catch ( e ) { } if ( hasFocus || ( options . autofocus && ! mobile ) ) setTimeout ( bind ( onFocus , this ) , 20 ) ; else onBlur ( this ) ; operation ( this , function ( ) { for ( var opt in optionHandlers ) if ( optionHandlers . propertyIsEnumerable ( opt ) ) optionHandlers [ opt ] ( this , options [ opt ] , Init ) ; for ( var i = 0 ; i < initHooks . length ; ++ i ) initHooks [ i ] ( this ) ; } ) ( ) ; }", "predicted": "this", "expected": "mobile"}
{"code": "function makeView ( doc ) { var selPos = { line : 0 , ch : 0 } ; return { doc : doc , // frontier is the point up to which the content has been parsed, frontier : 0 , highlight : new Delayed ( ) , sel : { from : selPos , to : selPos , head : selPos , anchor : selPos , shift : <mask> , extend : false } , scrollTop : 0 , scrollLeft : 0 , overwrite : false , focused : false , // Tracks the maximum line length so that // the horizontal scrollbar can be kept // static when scrolling. maxLine : getLine ( doc , 0 ) , maxLineLength : 0 , maxLineChanged : false , suppressEdits : false , goalColumn : null , cantEdit : false , keyMaps : [ ] } ; }", "predicted": "true", "expected": "false"}
{"code": "function loadMode ( cm ) { var doc = cm . view . doc ; cm . view . mode = CodeMirror . getMode ( cm . options , cm . options . mode ) ; doc . iter ( 0 , doc . size , function ( line ) { line . stateAfter = null ; } ) ; cm . view . frontier = 0 ; startWorker ( cm , <mask> ) ; }", "predicted": "doc", "expected": "100"}
{"code": "function <mask> ( d /* display */ , docHeight ) { var totalHeight = docHeight + 2 * paddingTop ( d ) ; d . sizer . style . minHeight = d . heightForcer . style . top = totalHeight + ; var scrollHeight = Math . max ( totalHeight , d . scroller . scrollHeight ) ; var needsH = d . scroller . scrollWidth > d . scroller . clientWidth ; var needsV = scrollHeight > d . scroller . clientHeight ; if ( needsV ) { d . scrollbarV . style . display = ; d . scrollbarV . style . bottom = needsH ? scrollbarWidth ( d . measure ) + : ; d . scrollbarV . firstChild . style . height = ( scrollHeight - d . scroller . clientHeight + d . scrollbarV . clientHeight ) + ; } else d . scrollbarV . style . display = ; if ( needsH ) { d . scrollbarH . style . display = ; d . scrollbarH . style . right = needsV ? scrollbarWidth ( d . measure ) + : ; d . scrollbarH . firstChild . style . width = ( d . scroller . scrollWidth - d . scroller . clientWidth + d . scrollbarH . clientWidth ) + ; } else d . scrollbarH . style . display = ; if ( needsH && needsV ) { d . scrollbarFiller . style . display = ; d . scrollbarFiller . style . height = d . scrollbarFiller . style . width = scrollbarWidth ( d . measure ) + ; } else d . scrollbarFiller . style . display = ; if ( mac_geLion && scrollbarWidth ( d . measure ) === 0 ) d . scrollbarV . style . minWidth = d . scrollbarH . style . minHeight = mac_geMountainLion ? : ; }", "predicted": "render", "expected": "updateScrollbars"}
{"code": "function startOperation ( cm ) { if ( cm . curOp ) ++ cm . curOp . depth ; else cm . curOp = { // Nested operations delay update until the outermost one // finishes. depth : 1 , // An array of ranges of lines that have to be updated. See // updateDisplay. changes : [ ] , <mask> : [ ] , updateInput : null , userSelChange : null , textChanged : null , selectionChanged : false , updateMaxLine : false , id : ++ cm . nextOpId } ; }", "predicted": "updates", "expected": "delayedCallbacks"}
{"code": "function e_prop ( e , prop ) { <mask> overridden = e . override && e . override . hasOwnProperty ( prop ) ; return overridden ? e . override [ prop ] : e [ prop ] ; }", "predicted": "val", "expected": "var"}
{"code": "function moveVisually ( line , start , dir , byUnit ) { var bidi = getOrder ( line ) ; if ( ! bidi ) return moveLogically ( line , start , dir , byUnit ) ; var moveOneUnit = byUnit ? function ( pos , dir ) { do pos += dir ; while ( pos > 0 && isExtendingChar . test ( line . text . charAt ( pos ) ) ) ; return pos ; } : function ( pos , dir ) { return pos + dir ; } ; var linedir = bidi [ 0 ] . <mask> ; for ( var i = 0 ; i < bidi . length ; ++ i ) { var part = bidi [ i ] , sticky = part . level % 2 == linedir ; if ( ( part . from < start && part . to > start ) || ( sticky && ( part . from == start || part . to == start ) ) ) break ; } var target = moveOneUnit ( start , part . level % 2 ? - dir : dir ) ; while ( target != null ) { if ( part . level % 2 == linedir ) { if ( target < part . from || target > part . to ) { part = bidi [ i += dir ] ; target = part && ( dir > 0 == part . level % 2 ? moveOneUnit ( part . to , - 1 ) : moveOneUnit ( part . from , 1 ) ) ; } else break ; } else { if ( target == bidiLeft ( part ) ) { part = bidi [ -- i ] ; target = part && bidiRight ( part ) ; } else if ( target == bidiRight ( part ) ) { part = bidi [ ++ i ] ; target = part && bidiLeft ( part ) ; } else break ; } } return target < 0 || target > line . text . length ? null : target ; }", "predicted": "to", "expected": "level"}
{"code": "function insertTableContent ( ) { let tableName = arguments [ 0 ] ; var fname = '' ; var callback ; var tableRow ; if ( arguments . length === 3 ) { callback = arguments [ 2 ] ; fname = path . join ( userData , arguments [ 0 ] + '.json' ) ; tableRow = arguments [ 1 ] ; } else if ( arguments . length === 4 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; callback = arguments [ 3 ] ; tableRow = arguments [ 2 ] ; } let exists = fs . existsSync ( fname ) ; if ( exists ) { // Table | json parsed let table = JSON . parse ( fs . readFileSync ( fname ) ) ; let date = new Date ( ) ; let id = date . getTime ( ) ; tableRow [ 'id' ] = id ; table [ tableName ] . push ( tableRow ) ; try { fs . writeFileSync ( fname , JSON . stringify ( table , null , 2 ) , ( err ) <mask> { } ) callback ( true , ) ; return ; } catch ( e ) { callback ( false , ) ; return ; } } callback ( false , ) ; return ; }", "predicted": ")", "expected": "=>"}
{"code": "function getField ( ) { let fname = '' let tableName = arguments [ 0 ] let callback let key if ( arguments . length === 3 ) { fname = path . join ( userData , tableName + '.json' ) ; callback = arguments [ 2 ] ; key = arguments [ <mask> ] } else if ( arguments . length === 4 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; callback = arguments [ 3 ] ; key = arguments [ 2 ] } let exists = fs . existsSync ( fname ) if ( exists ) { let table = JSON . parse ( fs . readFileSync ( fname ) ) ; const rows = table [ tableName ] let data = [ ] for ( let i = 0 ; i < rows . length ; i ++ ) { if ( rows [ i ] . hasOwnProperty ( key ) ) { data . push ( rows [ i ] [ key ] ) } } callback ( true , data ) } else { callback ( false , 'The table you are trying to access does not exist.' ) return } }", "predicted": "2", "expected": "1"}
{"code": "function getRows ( ) { let tableName = arguments [ 0 ] ; var fname = '' ; var callback ; var where ; if ( arguments . length === 3 ) { fname = path . join ( userData , tableName + '.json' ) ; where = arguments [ 1 ] ; callback = arguments [ 2 ] ; } else if ( arguments . length === 4 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; where = arguments [ 2 ] ; callback = arguments [ 3 ] ; } let exists = fs . existsSync ( fname ) ; let whereKeys ; // Check if where is an object if ( Object . prototype . <mask> . call ( where ) === ) { // Check for number of keys whereKeys = Object . keys ( where ) ; if ( whereKeys === 0 ) { callback ( false , ) ; return ; } } else { callback ( false , ) ; return ; } // Check if the json file exists, if it is, parse it. if ( exists ) { try { let table = JSON . parse ( fs . readFileSync ( fname ) ) ; let rows = table [ tableName ] ; let objs = [ ] ; for ( let i = 0 ; i < rows . length ; i ++ ) { let matched = 0 ; // Number of matched complete where clause for ( var j = 0 ; j < whereKeys . length ; j ++ ) { // Test if there is a matched key with where clause if ( rows [ i ] . hasOwnProperty ( whereKeys [ j ] ) ) { if ( rows [ i ] [ whereKeys [ j ] ] === where [ whereKeys [ j ] ] ) { matched ++ ; } } } // Check if all conditions in the WHERE clause are matched if ( matched === whereKeys . length ) { objs . push ( rows [ i ] ) } } callback ( true , objs ) ; return ; } catch ( e ) { callback ( false , e . toString ( ) ) ; return ; } } else { callback ( false , 'Table file does not exist!' ) ; return ; } }", "predicted": "keys", "expected": "toString"}
{"code": "function <mask> ( options ) { if ( options == null ) { options = { } ; } this . configuration = Util . cloneDeep ( options ) ; Util . defaults ( this . configuration , DEFAULT_CONFIGURATION_PARAMS ) ; }", "predicted": "execute", "expected": "Configuration"}
{"code": "function Transformation ( options ) { if ( options == null ) { options = { } ; } Transformation . <mask> . constructor . call ( this , options ) ; this ; }", "predicted": "class", "expected": "__super__"}
{"code": "function Cloudinary ( options ) { var configuration ; this . devicePixelRatioCache = { } ; this . responsiveConfig = { } ; this . responsiveResizeInitialized = false ; configuration = new <mask> ( options ) ; this . config = function ( newConfig , newValue ) { return configuration . config ( newConfig , newValue ) ; } ; /**\n       * Use \\<meta\\> tags in the document to configure this Cloudinary instance.\n       * @return {Cloudinary} this for chaining\n       */ this . fromDocument = function ( ) { configuration . fromDocument ( ) ; return this ; } ; /**\n       * Use environment variables to configure this Cloudinary instance.\n       * @return {Cloudinary} this for chaining\n       */ this . fromEnvironment = function ( ) { configuration . fromEnvironment ( ) ; return this ; } ; /**\n       * Initialize configuration.\n       * @function Cloudinary#init\n       * @see Configuration#init\n       * @return {Cloudinary} this for chaining\n       */ this . init = function ( ) { configuration . init ( ) ; return this ; } ; }", "predicted": "Config", "expected": "Configuration"}
{"code": "function getMode ( env , <mask> ) { // When running from parallel-webpack, grab the cli parameters argv = Object . keys ( argv ) . length ? argv : require ( 'minimist' ) ( process . argv . slice ( 2 ) ) ; var isProd = ( argv . mode || env . mode ) === 'production' || env === 'prod' || env . prod ; return isProd ? 'production' : 'development' ; }", "predicted": "process", "expected": "argv"}
{"code": "function MouseEdges ( parent , options ) { _classCallCheck ( this , MouseEdges ) ; var <mask> = _possibleConstructorReturn ( this , ( MouseEdges . __proto__ || Object . getPrototypeOf ( MouseEdges ) ) . call ( this , parent ) ) ; options = options || { } ; _this . options = options ; _this . reverse = options . reverse ? 1 : - 1 ; _this . noDecelerate = options . noDecelerate ; _this . linear = options . linear ; _this . radiusSquared = Math . pow ( options . radius , 2 ) ; _this . resize ( ) ; _this . speed = options . speed || 8 ; return _this ; }", "predicted": "this", "expected": "_this"}
{"code": "function Drag ( parent , options ) { _classCallCheck ( this , Drag ) ; options = options || { } ; var <mask> = _possibleConstructorReturn ( this , ( Drag . __proto__ || Object . getPrototypeOf ( Drag ) ) . call ( this , parent ) ) ; _this . moved = false ; _this . wheelActive = utils . defaults ( options . wheel , true ) ; _this . wheelScroll = options . wheelScroll || 1 ; _this . reverse = options . reverse ? 1 : - 1 ; _this . clampWheel = options . clampWheel ; _this . factor = options . factor || 1 ; _this . xDirection = ! options . direction || options . direction === 'all' || options . direction === 'x' ; _this . yDirection = ! options . direction || options . direction === 'all' || options . direction === 'y' ; _this . parseUnderflow ( options . underflow || 'center' ) ; _this . mouseButtons ( options . mouseButtons ) ; return _this ; }", "predicted": "this", "expected": "_this"}
{"code": "function SnapZoom ( parent , options ) { _classCallCheck ( this , SnapZoom ) ; var _this = _possibleConstructorReturn ( this , ( SnapZoom . __proto__ || Object . getPrototypeOf ( SnapZoom ) ) . call ( this , parent ) ) ; options = options || { } ; _this . width = options . width ; _this . height = options . height ; if ( _this . width > 0 ) { _this . <mask> = parent . _screenWidth / _this . width ; } if ( _this . height > 0 ) { _this . y_scale = parent . _screenHeight / _this . height ; } _this . xIndependent = utils . exists ( _this . x_scale ) ; _this . yIndependent = utils . exists ( _this . y_scale ) ; _this . x_scale = _this . xIndependent ? _this . x_scale : _this . y_scale ; _this . y_scale = _this . yIndependent ? _this . y_scale : _this . x_scale ; _this . time = utils . defaults ( options . time , 1000 ) ; _this . ease = utils . ease ( options . ease , 'easeInOutSine' ) ; _this . center = options . center ; _this . noMove = options . noMove ; _this . stopOnResize = options . stopOnResize ; _this . removeOnInterrupt = options . removeOnInterrupt ; _this . removeOnComplete = utils . defaults ( options . removeOnComplete , true ) ; _this . interrupt = utils . defaults ( options . interrupt , true ) ; if ( _this . time === 0 ) { parent . container . scale . x = _this . x_scale ; parent . container . scale . y = _this . y_scale ; if ( _this . removeOnComplete ) { _this . parent . removePlugin ( 'snap-zoom' ) ; } } else if ( options . forceStart ) { _this . createSnapping ( ) ; } return _this ; }", "predicted": "width", "expected": "x_scale"}
{"code": "function Snap ( parent , x , y , options ) { _classCallCheck ( this , Snap ) ; var _this = _possibleConstructorReturn ( this , ( Snap . __proto__ <mask> Object . getPrototypeOf ( Snap ) ) . call ( this , parent ) ) ; options = options || { } ; _this . friction = options . friction || 0.8 ; _this . time = options . time || 1000 ; _this . ease = utils . ease ( options . ease , 'easeInOutSine' ) ; _this . x = x ; _this . y = y ; _this . topLeft = options . topLeft ; _this . interrupt = utils . defaults ( options . interrupt , true ) ; _this . removeOnComplete = options . removeOnComplete ; _this . removeOnInterrupt = options . removeOnInterrupt ; if ( options . forceStart ) { _this . startEase ( ) ; } return _this ; }", "predicted": ",", "expected": "||"}
{"code": "function <mask> ( object , fn ) { var initial = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : 0 ; return keys ( object ) . reduce ( function ( accum , key ) { return fn ( accum , object [ key ] , key ) ; } , initial ) ; }", "predicted": "keys", "expected": "reduce"}
{"code": "function isPlain ( value ) { return isObject ( value ) && toString . call ( value ) === '[object Object]' && value . constructor === <mask> ; }", "predicted": "null", "expected": "Object"}
{"code": "function createEl ( ) { var tagName = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : 'div' ; var properties = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; var attributes = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : { } ; var content = arguments [ 3 ] ; var el = document . createElement ( tagName ) ; Object . getOwnPropertyNames ( properties ) . <mask> ( function ( propName ) { var val = properties [ propName ] ; // See #2176 // We originally were accepting both properties and attributes in the // same object, but that doesn't work so well. if ( propName . indexOf ( 'aria-' ) !== - 1 || propName === 'role' || propName === 'type' ) { log$1 . warn ( tsml ( _templateObject , propName , val ) ) ; el . setAttribute ( propName , val ) ; // Handle textContent since it's not supported everywhere and we have a // method for it. } else if ( propName === 'textContent' ) { textContent ( el , val ) ; } else { el [ propName ] = val ; } } ) ; Object . getOwnPropertyNames ( attributes ) . forEach ( function ( attrName ) { el . setAttribute ( attrName , attributes [ attrName ] ) ; } ) ; if ( content ) { appendContent ( el , content ) ; } return el ; }", "predicted": "for", "expected": "forEach"}
{"code": "function addClass ( element , classToAdd ) { if ( element . classList ) { element . classList . add ( classToAdd ) ; // Don't need to `throwIfWhitespace` here because `hasElClass` will do it <mask> } else if ( ! hasClass ( element , classToAdd ) ) { element . className = ( element . className + ' ' + classToAdd ) . trim ( ) ; } return element ; }", "predicted": ".", "expected": "// in the case of classList not being supported."}
{"code": "function toggleClass ( element , classToToggle , predicate ) { // This CANNOT use `classList` internally because IE does not support the // second parameter to the `classList.toggle()` method! Which is fine because // `classList` will be used by the add/remove functions. var <mask> = hasClass ( element , classToToggle ) ; if ( typeof predicate === 'function' ) { predicate = predicate ( element , classToToggle ) ; } if ( typeof predicate !== 'boolean' ) { predicate = ! has ; } // If the necessary class operation matches the current state of the // element, no action is required. if ( predicate === has ) { return ; } if ( predicate ) { addClass ( element , classToToggle ) ; } else { removeClass ( element , classToToggle ) ; } return element ; }", "predicted": "predicate", "expected": "has"}
{"code": "function _cleanUpEvents ( elem , type ) { var data = getData ( elem ) ; // Remove the events of a particular type if there are none left if ( data . handlers [ type ] . length === 0 ) { delete data . handlers [ type ] ; // data.handlers[type] = null; // Setting to null was causing an error with data.handlers // Remove the meta-handler from the element if ( elem . removeEventListener ) { elem . removeEventListener ( type , data . dispatcher , false ) ; } else if ( elem . detachEvent ) { elem . detachEvent ( 'on' + type , data . dispatcher ) ; } } // Remove the events object if there are no types left if ( Object . getOwnPropertyNames ( data . handlers ) . length <= 0 ) { delete data . handlers ; delete data . dispatcher ; delete data . disabled ; } // Finally remove the element data if there is no data left if ( Object . getOwnPropertyNames ( data ) . length === 0 ) { <mask> ( elem ) ; } }", "predicted": "delete", "expected": "removeData"}
{"code": "function _handleMultipleEvents ( fn <mask> elem , types , callback ) { types . forEach ( function ( type ) { // Call the event method for each one of the types fn ( elem , type , callback ) ; } ) ; }", "predicted": "(", "expected": ","}
{"code": "function off ( <mask> , type , fn ) { // Don't want to add a cache object through getElData if not needed if ( ! hasData ( elem ) ) { return ; } var data = getData ( elem ) ; // If no events exist, nothing to unbind if ( ! data . handlers ) { return ; } if ( Array . isArray ( type ) ) { return _handleMultipleEvents ( off , elem , type , fn ) ; } // Utility function var removeType = function removeType ( t ) { data . handlers [ t ] = [ ] ; _cleanUpEvents ( elem , t ) ; } ; // Are we removing all bound events? if ( ! type ) { for ( var t in data . handlers ) { removeType ( t ) ; } return ; } var handlers = data . handlers [ type ] ; // If no handlers exist, nothing to unbind if ( ! handlers ) { return ; } // If no listener was provided, remove all listeners for type if ( ! fn ) { removeType ( type ) ; return ; } // We're only removing a single handler if ( fn . guid ) { for ( var n = 0 ; n < handlers . length ; n ++ ) { if ( handlers [ n ] . guid === fn . guid ) { handlers . splice ( n -- , 1 ) ; } } } _cleanUpEvents ( elem , type ) ; }", "predicted": "off", "expected": "elem"}
{"code": "function autoSetupTimeout ( wait , <mask> ) { if ( vjs ) { videojs$2 = vjs ; } window . setTimeout ( autoSetup , wait ) ; }", "predicted": "window", "expected": "vjs"}
{"code": "function isValidEventType ( type ) { return ( // The regex here verifies that the `type` contains at least one non- // whitespace character. typeof type === 'string' && / \\S / . test ( type ) || Array . <mask> ( type ) && ! ! type . length ) ; }", "predicted": "test", "expected": "isArray"}
{"code": "function one$$1 ( ) { var _this2 = this ; for ( var _len2 = arguments . length , args = Array ( _len2 ) , _key2 = 0 ; _key2 < _len2 ; _key2 ++ ) { args [ _key2 ] = arguments [ _key2 ] ; } var _normalizeListenArgs2 = normalizeListenArgs ( this , args ) , isTargetingSelf = _normalizeListenArgs2 . isTargetingSelf , target = _normalizeListenArgs2 . target , type = _normalizeListenArgs2 . type , listener = _normalizeListenArgs2 . listener ; // Targeting this evented object. if ( isTargetingSelf ) { listen ( target , 'one' , type , listener ) ; // Targeting another evented object. } else { var wrapper = function wrapper ( ) { for ( var <mask> = arguments . length , largs = Array ( _len3 ) , _key3 = 0 ; _key3 < _len3 ; _key3 ++ ) { largs [ _key3 ] = arguments [ _key3 ] ; } _this2 . off ( target , type , wrapper ) ; listener . apply ( null , largs ) ; } ; // Use the same function ID as the listener so we can remove it later // it using the ID of the original listener. wrapper . guid = listener . guid ; listen ( target , 'one' , type , wrapper ) ; } }", "predicted": "null", "expected": "_len3"}
{"code": "function off$$1 ( targetOrType , <mask> , listener ) { // Targeting this evented object. if ( ! targetOrType || isValidEventType ( targetOrType ) ) { off ( this . eventBusEl_ , targetOrType , typeOrListener ) ; // Targeting another evented object. } else { var target = targetOrType ; var type = typeOrListener ; // Fail fast and in a meaningful way! validateTarget ( target ) ; validateEventType ( type ) ; validateListener ( listener ) ; // Ensure there's at least a guid, even if the function hasn't been used listener = bind ( this , listener ) ; // Remove the dispose listener on this evented object, which was given // the same guid as the event listener in on(). this . off ( 'dispose' , listener ) ; if ( target . nodeName ) { off ( target , type , listener ) ; off ( target , 'dispose' , listener ) ; } else if ( isEvented ( target ) ) { target . off ( type , listener ) ; target . off ( 'dispose' , listener ) ; } } }", "predicted": "type", "expected": "typeOrListener"}
