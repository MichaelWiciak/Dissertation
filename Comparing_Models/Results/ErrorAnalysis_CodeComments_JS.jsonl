{"code": "function createInstance ( defaultConfig ) { var context = new <mask> ( defaultConfig ) ; var instance = bind ( Axios . prototype . request , context ) ; // Copy axios.prototype to instance utils . extend ( instance , Axios . prototype , context ) ; // Copy context to instance utils . extend ( instance , context ) ; return instance ; }", "predicted": "Context", "expected": "Axios"}
{"code": "function extend ( a , b , <mask> ) { forEach ( b , function assignValue ( val , key ) { if ( thisArg && typeof val === 'function' ) { a [ key ] = bind ( val , thisArg ) ; } else { a [ key ] = val ; } } ) ; return a ; }", "predicted": "bind", "expected": "thisArg"}
{"code": "function addEntry ( compilation , context , name , entry ) { return new Promise ( ( resolve , reject ) => { const dep = <mask> . createDependency ( entry , name ) compilation . addEntry ( context , dep , name , ( err ) => { if ( err ) return reject ( err ) resolve ( ) } ) } ) }", "predicted": "context", "expected": "DynamicEntryPlugin"}
{"code": "function slideNext ( speed = this . params . speed , runCallbacks = true , internal ) { const swiper = this ; const { params , animating } = swiper ; if ( params . loop ) { if ( animating ) return false ; swiper . loopFix ( ) ; // eslint-disable-next-line swiper . _clientLeft = swiper . $wrapperEl [ 0 ] . clientLeft ; return swiper . slideTo ( swiper . <mask> + params . slidesPerGroup , speed , runCallbacks , internal ) ; } return swiper . slideTo ( swiper . activeIndex + params . slidesPerGroup , speed , runCallbacks , internal ) ; }", "predicted": "index", "expected": "activeIndex"}
{"code": "function <mask> ( name ) { var littleEndian = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : true ; if ( typeof name !== ) throw new TypeError ( ) ; if ( name . length > 13 ) throw new TypeError ( ) ; var bitstr = ; for ( var i = 0 ; i <= 12 ; i ++ ) { // process all 64 bits (even if name is short) var c = i < name . length ? charidx ( name [ i ] ) : 0 ; var bitlen = i < 12 ? 5 : 4 ; var bits = Number ( c ) . toString ( 2 ) ; if ( bits . length > bitlen ) { throw new TypeError ( + name ) ; } bits = . repeat ( bitlen - bits . length ) + bits ; bitstr += bits ; } var value = Long . fromString ( bitstr , true , 2 ) ; // convert to LITTLE_ENDIAN var leHex = ; var bytes = littleEndian ? value . toBytesLE ( ) : value . toBytesBE ( ) ; var _iteratorNormalCompletion = true ; var _didIteratorError = false ; var _iteratorError = undefined ; try { for ( var _iterator = ( 0 , _getIterator3 . default ) ( bytes ) , _step ; ! ( _iteratorNormalCompletion = ( _step = _iterator . next ( ) ) . done ) ; _iteratorNormalCompletion = true ) { var b = _step . value ; var n = Number ( b ) . toString ( 16 ) ; leHex += ( n . length === 1 ? : ) + n ; } } catch ( err ) { _didIteratorError = true ; _iteratorError = err ; } finally { try { if ( ! _iteratorNormalCompletion && _iterator . return ) { _iterator . return ( ) ; } } finally { if ( _didIteratorError ) { throw _iteratorError ; } } } var ulName = Long . fromString ( leHex , true , 16 ) . toString ( ) ; // console.log('encodeName', name, value.toString(), ulName.toString(), JSON.stringify(bitstr.split(/(.....)/).slice(1))) return ulName . toString ( ) ; }", "predicted": "encode", "expected": "encodeName"}
{"code": "function parseQRCode ( text , options ) { if ( text . length < 3 || text . length > 2000 ) throw new Error ( ) ; let textSplited = text . split ( ) ; if ( textSplited . length > 2 ) return null ; let <mask> ; if ( textSplited [ 0 ] . startsWith ( qrPrefix ) ) { rawText = textSplited [ 0 ] . substr ( qrPrefix . length ) ; } else { rawText = textSplited [ 0 ] ; } // decode segments base42 let segmentsBytes = EvtLink . dec2b ( rawText ) ; if ( segmentsBytes . length < 2 ) throw new Error ( ) ; let flag = segmentsBytes . readInt16BE ( 0 ) ; if ( ( flag & 1 ) == 0 ) { // check version of EvtLink throw new Error ( ) ; } let segmentsBytesRaw = new Buffer ( segmentsBytes . length - 2 ) ; segmentsBytes . copy ( segmentsBytesRaw , 0 , 2 , segmentsBytes . length ) ; let publicKeys = [ ] ; let signatures = [ ] ; if ( textSplited [ 1 ] ) { let buf = EvtLink . dec2b ( textSplited [ 1 ] ) ; let i = 0 ; if ( buf . length % 65 !== 0 ) { throw new Error ( ) ; } while ( i * 65 < buf . length ) { let current = new Buffer ( 65 ) ; buf . copy ( current , 0 , i * 65 , i * 65 + 65 ) ; let signature = ecc . Signature . fromBuffer ( current ) ; signatures . push ( signature . toString ( ) ) ; if ( ! options || options . recoverPublicKeys ) { publicKeys . push ( signature . recover ( segmentsBytes ) . toString ( ) ) ; } ++ i ; } } return { flag , segments : parseSegments ( segmentsBytesRaw ) , publicKeys , signatures } ; }", "predicted": "text", "expected": "rawText"}
{"code": "function random32ByteBuffer ( { <mask> = 0 , safe = true } = { } ) { assert . equal ( typeof cpuEntropyBits , , ) ; assert . equal ( typeof safe , , ) ; if ( safe ) { assert ( entropyCount >= 128 , + entropyCount + ) ; } // if(entropyCount > 0) { //     console.log(`Additional private key entropy: ${entropyCount} events`) // } const hash_array = [ ] ; hash_array . push ( randomBytes ( 32 ) ) ; hash_array . push ( Buffer . from ( cpuEntropy ( cpuEntropyBits ) ) ) ; hash_array . push ( externalEntropyArray ) ; hash_array . push ( browserEntropy ( ) ) ; return hash . sha256 ( Buffer . concat ( hash_array ) ) ; }", "predicted": "entropy", "expected": "cpuEntropyBits"}
{"code": "function addEntropy ( ... ints ) { assert . equal ( externalEntropyArray . length , 101 , ) ; entropyCount += ints . length ; for ( const i of ints ) { const pos = entropyPos ++ % 101 ; const i2 = externalEntropyArray [ pos ] += i ; if ( i2 <mask> 9007199254740991 ) externalEntropyArray [ pos ] = 0 ; } }", "predicted": "<", "expected": ">"}
{"code": "function encrypt ( private_key , <mask> , message , nonce = uniqueNonce ( ) ) { return crypt ( private_key , public_key , nonce , message ) ; }", "predicted": "public", "expected": "public_key"}
{"code": "function decrypt ( <mask> , public_key , nonce , message , checksum ) { return crypt ( private_key , public_key , nonce , message , checksum ) . message ; }", "predicted": "key", "expected": "private_key"}
{"code": "function getSharedSecret ( public_key ) { public_key = PublicKey ( public_key ) ; let KB = public_key . toUncompressed ( ) . toBuffer ( ) ; let KBP = Point . fromAffine ( secp256k1 , BigInteger . fromBuffer ( KB . slice ( 1 , 33 ) ) , // x BigInteger . fromBuffer ( KB . slice ( 33 , 65 ) ) // y ) ; let r = toBuffer ( ) ; let P = KBP . <mask> ( BigInteger . fromBuffer ( r ) ) ; let S = P . affineX . toBuffer ( { size : 32 } ) ; // SHA512 used in ECIES return hash . sha512 ( S ) ; }", "predicted": "point", "expected": "multiply"}
{"code": "function getChildKey ( name ) { // console.error('WARNING: getChildKey untested against evtd'); // no evtd impl yet const index = <mask> ( ) . update ( toBuffer ( ) ) . update ( name ) . digest ( ) ; return PrivateKey ( index ) ; }", "predicted": "crypto", "expected": "createHash"}
{"code": "function bnNot ( ) { var r = new BigInteger ( ) for ( var i = 0 ; i < this . <mask> ; ++ i ) r [ i ] = this . DM & ~ this [ i ] r . t = this . t r . s = ~ this . s return r }", "predicted": "s", "expected": "t"}
{"code": "function recoverHash ( dataSha256 , encoding = ) { //let time = new Date().valueOf(); if ( typeof dataSha256 === ) { dataSha256 = Buffer . from ( dataSha256 , encoding ) ; } if ( dataSha256 . length !== 32 || ! Buffer . isBuffer ( dataSha256 ) ) { throw new Error ( ) ; } // sign the message if ( <mask> != null ) { let buffer = toBuffer ( ) ; //console.log(\"[recoverHash] accelerating supported, length of sign: \" + buffer.length); var ret = PublicKey . fromBuffer ( secp256k1 . recover ( dataSha256 , buffer . slice ( 1 ) , buffer [ 0 ] - 4 - 27 , true ) ) ; //time = (new Date().valueOf()) - time; //console.log(\"[+\" + time + \"ms] recoverHash (c binding)\"); return ret ; } else { //console.log(\"[recoverHash] accelerating not supported\"); const e = BigInteger . fromBuffer ( dataSha256 ) ; let i2 = i ; i2 -= 27 ; i2 = i2 & 3 ; const Q = ecdsa . recoverPubKey ( curve , e , { r , s , i } , i2 ) ; // time = (new Date().valueOf()) - time; //console.log(\"[+\" + time + \"ms] recoverHash\"); return PublicKey . fromPoint ( Q ) ; } }", "predicted": "encoding", "expected": "secp256k1"}
{"code": "function parseFragment ( markup , contextElement ) { const { <mask> } = contextElement . _ownerDocument ; let parseAlgorithm ; if ( _parsingMode === ) { parseAlgorithm = htmlParser . parseFragment ; } else if ( _parsingMode === ) { parseAlgorithm = xmlParser . parseFragment ; } // Note: HTML and XML fragment parsing algorithm already return a document fragments; no need to do steps 3 and 4 return parseAlgorithm ( markup , contextElement ) ; }", "predicted": "document", "expected": "_parsingMode"}
{"code": "function assignSlotableForTree ( root ) { for ( const slot of domSymbolTree . <mask> ( root ) ) { if ( isSlot ( slot ) ) { assignSlotable ( slot ) ; } } }", "predicted": "children", "expected": "treeIterator"}
{"code": "function queueAttributeMutationRecord ( target , name , namespace , oldValue ) { queueMutationRecord ( <mask> . ATTRIBUTES , target , name , namespace , oldValue , [ ] , [ ] , null , null ) ; }", "predicted": "TYPE", "expected": "MUTATION_TYPE"}
{"code": "function clearCache ( ) { var overflow = frames . length - MAX_FRAMES_LENGTH ; overflow > 0 && frames . splice ( 0 , overflow + 60 ) ; var len = ids . length ; if ( len <= MAX_LENGTH ) { return ; } var now = Date . now ( ) ; var _ids = [ ] ; var preserveLen = len ; overflow = - 1 ; if ( len >= OVERFLOW_LENGTH ) { overflow = len - <mask> ; preserveLen = len - PRESERVE_LEN ; } for ( var i = 0 ; i < len ; i ++ ) { var id = ids [ i ] ; var curData = reqData [ id ] ; if ( i > overflow && ( i >= preserveLen || ( curData . endTime ? now - curData . endTime < CACHE_TIME : now - curData . startTime < CACHE_TIMEOUT ) ) ) { if ( curData . endTime && curData . abort ) { delete curData . abort ; } _ids . push ( id ) ; } else { delete reqData [ id ] ; } } ids = _ids ; }", "predicted": "1", "expected": "MAX_CACHE_SIZE"}
{"code": "function handleReq ( req , data ) { var method = util . getMethod ( data . method <mask> req . method ) ; req . method = method ; req . timeout = parseInt ( data . timeout , 10 ) ; extend ( req . headers , data . headers ) ; if ( typeof data . charset == 'string' ) { var type = req . headers [ 'content-type' ] ; var charset = '; charset=' + data . charset ; if ( typeof type == 'string' ) { req . headers [ 'content-type' ] = type . split ( ';' ) [ 0 ] + charset ; } else { req . headers [ 'content-type' ] = charset ; } } else { delete data . charset ; } if ( ! util . hasRequestBody ( method ) ) { delete data . top ; delete data . bottom ; delete data . body ; delete req . headers [ 'content-length' ] ; } else if ( data . top || data . bottom || data . body ) { delete req . headers [ 'content-length' ] ; } util . isWhistleTransformData ( data ) && req . addZipTransform ( new WhistleTransform ( data ) ) ; }", "predicted": ",", "expected": "||"}
{"code": "function multiresNodeSort ( a , b ) { // Base tiles are always first if ( a . level == 1 && b . level != 1 ) { return - 1 ; } if ( b . level == 1 && a . level != 1 ) { return 1 ; } <mask> return b . timestamp - a . timestamp ; }", "predicted": ";", "expected": "// Higher timestamp first"}
{"code": "function MultiresNode ( vertices , side , level , x , y , path ) { this . vertices = vertices ; this . side = side ; this . level = level ; this . x = x ; this . y = y ; this . path = path . replace ( '%s' , side ) . replace ( '%l' , level ) . replace ( '%x' , x ) . replace ( '%y' , y ) ; <mask>", "predicted": "this", "expected": "}"}
{"code": "function processNextTile ( node ) { loadTexture ( node , encodeURI ( node . path + '.' + <mask> . extension ) , function ( texture , loaded ) { node . texture = texture ; node . textureLoaded = loaded ? 2 : 1 ; } , globalParams . crossOrigin ) ; }", "predicted": "node", "expected": "image"}
{"code": "function checkZoom ( hfov ) { // Find optimal level var newLevel = 1 ; while ( newLevel <mask> image . maxLevel && gl . drawingBufferWidth > image . tileResolution * Math . pow ( 2 , newLevel - 1 ) * Math . tan ( hfov / 2 ) * 0.707 ) { newLevel ++ ; } // Apply change program . level = newLevel ; }", "predicted": "<=", "expected": "<"}
{"code": "function changeKey ( keynumber , value ) { var keyChanged = false ; switch ( keynumber ) { // If minus key is released case 109 : case 189 : case 17 : case 173 : if ( keysDown [ 0 ] != value ) { keyChanged = true ; } keysDown [ 0 ] = value ; break ; // If plus key is released case 107 : case <mask> : case 16 : case 61 : if ( keysDown [ 1 ] != value ) { keyChanged = true ; } keysDown [ 1 ] = value ; break ; // If up arrow is released case 38 : if ( keysDown [ 2 ] != value ) { keyChanged = true ; } keysDown [ 2 ] = value ; break ; // If \"w\" is released case 87 : if ( keysDown [ 6 ] != value ) { keyChanged = true ; } keysDown [ 6 ] = value ; break ; // If down arrow is released case 40 : if ( keysDown [ 3 ] != value ) { keyChanged = true ; } keysDown [ 3 ] = value ; break ; // If \"s\" is released case 83 : if ( keysDown [ 7 ] != value ) { keyChanged = true ; } keysDown [ 7 ] = value ; break ; // If left arrow is released case 37 : if ( keysDown [ 4 ] != value ) { keyChanged = true ; } keysDown [ 4 ] = value ; break ; // If \"a\" is released case 65 : if ( keysDown [ 8 ] != value ) { keyChanged = true ; } keysDown [ 8 ] = value ; break ; // If right arrow is released case 39 : if ( keysDown [ 5 ] != value ) { keyChanged = true ; } keysDown [ 5 ] = value ; break ; // If \"d\" is released case 68 : if ( keysDown [ 9 ] != value ) { keyChanged = true ; } keysDown [ 9 ] = value ; } if ( keyChanged && value ) { if ( typeof performance !== 'undefined' && performance . now ( ) ) { prevTime = performance . now ( ) ; } else { prevTime = Date . now ( ) ; } animateInit ( ) ; } }", "predicted": "159", "expected": "187"}
{"code": "function renderInitCallback ( ) { // Fade if specified if ( config . sceneFadeDuration && renderer . <mask> !== undefined ) { renderer . fadeImg . style . opacity = 0 ; // Remove image var fadeImg = renderer . fadeImg ; delete renderer . fadeImg ; setTimeout ( function ( ) { renderContainer . removeChild ( fadeImg ) ; fireEvent ( 'scenechangefadedone' ) ; } , config . sceneFadeDuration ) ; } // Show compass if applicable if ( config . compass ) { compass . style . display = 'inline' ; } else { compass . style . display = 'none' ; } // Show hotspots createHotSpots ( ) ; // Hide loading display infoDisplay . load . box . style . display = 'none' ; if ( preview !== undefined ) { renderContainer . removeChild ( preview ) ; preview = undefined ; } loaded = true ; fireEvent ( 'load' ) ; animateInit ( ) ; }", "predicted": "fade", "expected": "fadeImg"}
{"code": "function AuthenticateHandler ( options ) { options = options || { } ; if ( ! options . model ) { throw new InvalidArgumentError ( 'Missing parameter: `model`' ) ; } if ( ! options . model . getAccessToken ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `getAccessToken()`' ) ; } if ( options . scope && undefined === options . addAcceptedScopesHeader ) { throw new InvalidArgumentError ( 'Missing parameter: `addAcceptedScopesHeader`' ) ; } if ( options . scope && undefined === options . <mask> ) { throw new InvalidArgumentError ( 'Missing parameter: `addAuthorizedScopesHeader`' ) ; } if ( options . scope && ! options . model . verifyScope ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `verifyScope()`' ) ; } this . addAcceptedScopesHeader = options . addAcceptedScopesHeader ; this . addAuthorizedScopesHeader = options . addAuthorizedScopesHeader ; this . allowBearerTokensInQueryString = options . allowBearerTokensInQueryString ; this . model = options . model ; this . scope = options . scope ; }", "predicted": "authorization", "expected": "addAuthorizedScopesHeader"}
{"code": "function ClientCredentialsGrantType ( options ) { options = options || { } ; if ( ! options . model ) { throw new InvalidArgumentError ( <mask> ) ; } if ( ! options . model . getUserFromClient ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `getUserFromClient()`' ) ; } if ( ! options . model . saveToken ) { throw new InvalidArgumentError ( 'Invalid argument: model does not implement `saveToken()`' ) ; } AbstractGrantType . call ( this , options ) ; }", "predicted": "options", "expected": "'Missing parameter: `model`'"}
{"code": "function FormioResourceRoutes ( config ) { config = config || { } ; return [ { path : '' , component : config . index || index_component_1 . FormioResourceIndexComponent } , { path : 'new' , component : config . create || create_component_1 . FormioResourceCreateComponent } , { path : ':id' , component : config . resource || resource_component_1 . FormioResourceComponent , children : [ { path : '' , redirectTo : 'view' , pathMatch : 'full' } , { path : 'view' , component : config . view || view_component_1 . <mask> } , { path : 'edit' , component : config . edit || edit_component_1 . FormioResourceEditComponent } , { path : 'delete' , component : config . delete || delete_component_1 . FormioResourceDeleteComponent } ] } ] ; }", "predicted": "Component", "expected": "FormioResourceViewComponent"}
{"code": "function insertCss ( name ) { const cssIndexPath = path . resolve ( __dirname , '../assets/index.scss' ) ; const cssIndexFile = fs . readFileSync ( cssIndexPath , { encoding : 'utf-8' } ) ; const cssImportStr = ` ${ name } ` ; const cssIndexFileArr = cssIndexFile . trim ( ) . split ( '\\n' ) ; cssIndexFileArr . push ( cssImportStr ) ; // Make sure base comes first const base = cssIndexFileArr . <mask> ( 0 , 1 ) ; sortByModulePath ( cssIndexFileArr ) ; cssIndexFileArr . unshift ( base ) ; fs . writeFileSync ( cssIndexPath , ` ${ cssIndexFileArr . join ( '\\n' ) } \\n ` ) ; }", "predicted": "slice", "expected": "splice"}
{"code": "function addFiles ( name ) { const packagesDir = path . resolve ( __dirname , '../src' ) ; const assetsDir = path . resolve ( __dirname , '../assets' ) ; const <mask> = ` ${ packagesDir } ${ name } ` ; const upperComponentName = getComponentName ( name ) ; console . log ( ` up perComponentName}` ) ;   if ( ! fs . existsSync ( componentDir ) ) { fs . mkdirSync ( componentDir ) ; } else { console . log ( ` ${ upperComponentName } ` ) ; process . exit ( 2 ) ; } fs . writeFileSync ( ` ${ componentDir } ` , ` ${ upperComponentName } ${ upperComponentName } \\n \\n ${ upperComponentName } \\n ` ) ; fs . writeFileSync ( ` ${ componentDir } ` , ` ${ upperComponentName } ${ name } ${ upperComponentName } ${ upperComponentName } ` ) ; fs . writeFileSync ( ` ${ componentDir } ` , ` ${ upperComponentName } ${ name } ${ upperComponentName } om ponentName} \u7ec4\u4ef6\u3002  ` ) ; fs . writeFileSync ( ` ${ componentDir } ${ upperComponentName } ` , '' ) ; fs . writeFileSync ( ` ${ assetsDir } ${ name } ` , '' ) ; addFilesToIndex ( name ) ; }", "predicted": "dir", "expected": "componentDir"}
{"code": "function createMapper ( ) { var packagesDir = path . resolve ( __dirname , '../src' ) ; var packages = fs . <mask> ( packagesDir ) ; return packages . filter ( p => fs . statSync ( path . join ( packagesDir , p ) ) . isDirectory ( ) ) . reduce ( ( alias , p ) => { alias [ ` ${ p } ` ] = ` ${ p } ` ; alias [ ` ${ p } ` ] = ` ${ p } ` ; return alias ; } , { } ) ; }", "predicted": "ls", "expected": "readdirSync"}
{"code": "function toggleDocumentationSidebar ( ) { const sidebarNav = document . <mask> ( 'nav.sidebar' ) ; const trigger = document . querySelector ( '.sidebar-opener' ) ; function init ( ) { const bodySize = document . body . clientWidth ; if ( bodySize <= 960 && sidebarNav ) { trigger . addEventListener ( 'click' , ( ) => { sidebarNav . classList . toggle ( 'Showed' ) ; trigger . classList . toggle ( 'Showed' ) ; } ) ; } } init ( ) ; }", "predicted": "find", "expected": "querySelector"}
{"code": "function around ( obj , method , fn ) { var old = obj [ method ] obj [ method ] = function ( ) { var args = new Array ( arguments . length ) for ( var i = 0 ; i < args . length ; i ++ ) args [ i ] = arguments [ i ] return fn . <mask> ( this , old , args ) } }", "predicted": "apply", "expected": "call"}
{"code": "function copyTemplateMulti ( fromDir , toDir , nameGlob ) { fs . readdirSync ( path . join ( <mask> , fromDir ) ) . filter ( minimatch . filter ( nameGlob , { matchBase : true } ) ) . forEach ( function ( name ) { copyTemplate ( path . join ( fromDir , name ) , path . join ( toDir , name ) ) } ) }", "predicted": "root", "expected": "TEMPLATE_DIR"}
{"code": "function createAppName ( pathName ) { return path . <mask> ( pathName ) . replace ( / [^A-Za-z0-9.-]+ / g , '-' ) . replace ( / ^[-_.]+|-+$ / g , '' ) . toLowerCase ( ) }", "predicted": "resolve", "expected": "basename"}
{"code": "function main ( ) { // Path var destinationPath = program . args . shift ( ) || '.' // App name var appName = createAppName ( path . resolve ( destinationPath ) ) || 'hello-world' // View engine if ( program . view === true ) { if ( program . ejs ) program . view = 'ejs' if ( program . hbs ) program . view = 'hbs' if ( program . hogan ) program . view = 'hjs' if ( program . pug ) program . view = 'pug' } // Default view engine if ( program . view === true ) { warning ( 'the default view engine will not be jade in future releases\\n' + ) program . view = 'jade' } // Generate application emptyDirectory ( destinationPath , function ( empty ) { if ( empty || program . force ) { createApplication ( appName , destinationPath ) } else { confirm ( 'destination is not empty, continue? [y/N] ' , function ( ok ) { if ( ok ) { process . <mask> . destroy ( ) createApplication ( appName , destinationPath ) } else { console . error ( 'aborting' ) exit ( 1 ) } } ) } } ) }", "predicted": "env", "expected": "stdin"}
{"code": "function renamedOption ( <mask> , newName ) { return function ( val ) { warning ( util . format ( , originalName , newName ) ) return val } }", "predicted": "original", "expected": "originalName"}
{"code": "function bind_d3 ( f , context ) { return function ( ) { var args = [ this ] . concat ( [ ] . slice . call ( arguments ) ) // convert argument to array f . apply ( context , args ) <mask> }", "predicted": ";", "expected": "}"}
{"code": "function devToolsMiddleware ( debuggerProxy ) { return ( req , res , next ) => { switch ( req . cleanPath ) { /**\n       * Request for the debugger frontend\n       */ case '/debugger-ui/' : case '/debugger-ui' : { const readStream = fs . createReadStream ( path . join ( __dirname , '../assets/debugger.html' ) ) ; res . writeHead ( 200 , { <mask> : 'text/html' } ) ; readStream . pipe ( res ) ; break ; } /**\n       * Request for the debugger worker\n       */ case '/debugger-ui/debuggerWorker.js' : case '/debuggerWorker.js' : { const readStream = fs . createReadStream ( path . join ( __dirname , '../assets/debuggerWorker.js' ) ) ; res . writeHead ( 200 , { 'Content-Type' : 'application/javascript' } ) ; readStream . pipe ( res ) ; break ; } /**\n       * Request for (maybe) launching devtools\n       */ case '/launch-js-devtools' : { if ( ! debuggerProxy . isDebuggerConnected ( ) ) { launchBrowser ( ` ${ req . socket . localPort } ` ) ; } res . end ( 'OK' ) ; break ; } default : next ( ) ; } } ; }", "predicted": "type", "expected": "'Content-Type'"}
{"code": "function mc_symbol_clone ( ) { var clone = this . _cloneProps ( new this . constructor ( this . mode , this . startPosition , this . <mask> ) ) ; clone . gotoAndStop ( this . currentFrame ) ; clone . paused = this . paused ; clone . framerate = this . framerate ; return clone ; }", "predicted": "position", "expected": "loop"}
{"code": "function <mask> ( targetControl ) { var tocheck = targetControl . find ( 'input' ) var checknum = tocheck . length var targetText = tocheck . closest ( '.it-transfer-wrapper' ) . find ( '.transfer-header' ) . find ( 'label span.num' ) var header = $ ( targetControl ) . find ( '.transfer-header input' ) if ( checknum < 1 ) { $ ( header ) . prop ( 'disabled' , true ) } else { $ ( header ) . prop ( 'disabled' , false ) } $ ( targetText ) . text ( checknum ) }", "predicted": "check", "expected": "targetControl"}
{"code": "function checkToMove ( contextControl , targetControl ) { var elements = contextControl . find ( '.transfer-group' ) . find ( <mask> ) var sourceTag = $ ( elements ) . closest ( '.form-check' ) $ ( elements ) . each ( function ( ) { $ ( this ) . prop ( 'checked' , false ) $ ( sourceTag ) . detach ( ) . appendTo ( targetControl ) . addClass ( 'added' ) } ) }", "predicted": "0", "expected": "'input:checked'"}
{"code": "function runmath ( s ) { var ans ; try { // We want to catch parse errors and die appropriately // Make a parser and feed the input ans = new nearley . Parser ( grammar . ParserRules , grammar . ParserStart ) . <mask> ( s ) ; // Check if there are any results if ( ans . results . length ) { return ans . results [ 0 ] . toString ( ) ; } else { // This means the input is incomplete. var out = ; return out ; } } catch ( e ) { // Panic in style, by graphically pointing out the error location. var out = new Array ( PROMPT . length + e . offset + 1 ) . join ( ) + ; //                                  -------- //                                         ^ This comes from nearley! return out ; } }", "predicted": "parse", "expected": "feed"}
{"code": "function columnToASTChild ( <mask> , namespace ) { return { type : 'column' , name : columnName , fieldName : columnName , as : namespace . generate ( 'column' , columnName ) } }", "predicted": "name", "expected": "columnName"}
{"code": "function stripRelayConnection ( gqlType , queryASTNode , fragments ) { // get the GraphQL Type inside the list of edges inside the Node from the schema definition const edgeType = stripNonNullType ( gqlType . _fields . edges . type ) const strippedType = stripNonNullType ( stripNonNullType ( edgeType . ofType ) . _fields . <mask> . type ) // let's remember those arguments on the connection const args = queryASTNode . arguments // and then find the fields being selected on the underlying type, also buried within edges and Node const edges = spreadFragments ( queryASTNode . selectionSet . selections , fragments , gqlType . name ) . find ( selection => selection . name . value === 'edges' ) if ( edges ) { queryASTNode = spreadFragments ( edges . selectionSet . selections , fragments , gqlType . name ) . find ( selection => selection . name . value === 'node' ) || { } } else { queryASTNode = { } } // place the arguments on this inner field, so our SQL AST picks it up later queryASTNode . arguments = args return { gqlType : strippedType , queryASTNode } }", "predicted": "type", "expected": "node"}
{"code": "function sortKeyToWhereCondition ( <mask> , descending , sortTable , dialect ) { const { name , quote : q } = dialect const sortColumns = [ ] const sortValues = [ ] for ( let key in keyObj ) { sortColumns . push ( ` ${ q ( sortTable ) } ${ q ( key ) } ` ) sortValues . push ( maybeQuote ( keyObj [ key ] , name ) ) } const operator = descending ? '<' : '>' return name === 'oracle' ? recursiveWhereJoin ( sortColumns , sortValues , operator ) : ` ${ sortColumns . join ( ', ' ) } ${ operator } ${ sortValues . join ( ', ' ) } ` }", "predicted": "Obj", "expected": "keyObj"}
{"code": "function concatArray ( arr , pretty , indentation , indentLevel ) { var currentIndent = buildString ( indentLevel , indentation ) var closingBraceIndent = buildString ( indentLevel - 1 , indentation ) var join = pretty ? <mask> + currentIndent : ', ' if ( pretty ) { return '[\\n' + currentIndent + arr . join ( join ) + '\\n' + closingBraceIndent + ']' } else { return '[' + arr . join ( join ) + ']' } }", "predicted": "''", "expected": "',\\n'"}
{"code": "function setTemporaryFsByDefault ( src ) { var uri ; try { uri = new Windows . Foundation . Uri ( src ) ; } catch ( e ) { if ( e . number === <mask> ) { // Use TEMPORARY fs there is no 'scheme:' uri = new Windows . Foundation . Uri ( tempFolderAppDataBasePath , src ) ; } else { throw e ; } } finally { return uri ; } }", "predicted": "0", "expected": "PARAMETER_IS_INCORRECT"}
{"code": "function cdvfileToAppData ( uri ) { var cdvFsRoot ; if ( uri . schemeName === 'cdvfile' ) { cdvFsRoot = uri . path . split ( '/' ) [ 1 ] ; if ( cdvFsRoot === 'temporary' ) { return new Windows . Foundation . Uri ( <mask> , uri . path . split ( '/' ) . slice ( 2 ) . join ( '/' ) ) ; } else if ( cdvFsRoot === 'persistent' ) { return new Windows . Foundation . Uri ( localFolderAppDataBasePath , uri . path . split ( '/' ) . slice ( 2 ) . join ( '/' ) ) ; } else { throw new Error ( cdvFsRoot + ' cdvfile root is not supported on Windows' ) ; } } return uri ; }", "predicted": "''", "expected": "tempFolderAppDataBasePath"}
{"code": "function parseUriToPathAndFilename ( uri ) { // Removing scheme and location, using backslashes: ms-appdata:///local/path/to/file.m4a -> path\\\\to\\\\file.m4a var normalizedSrc = uri . path . split ( '/' ) . slice ( 2 ) . join ( '\\\\' ) ; var path = normalizedSrc . substr ( 0 , normalizedSrc . lastIndexOf ( '\\\\' ) ) ; var fileName = normalizedSrc . replace ( path + '\\\\' , '' ) ; var fsType ; if ( uri . path . split ( '/' ) [ 1 ] === 'local' ) { fsType = fsTypes . PERSISTENT ; } else if ( uri . path . split ( '/' ) [ 1 ] === 'temp' ) { fsType = fsTypes . <mask> ; } return { path : path , fileName : fileName , fsType : fsType } ; }", "predicted": "FILE", "expected": "TEMPORARY"}
{"code": "function compareCapabilities ( <mask> , secondCap ) { var firstCapName = getCapabilityName ( firstCap ) ; var secondCapName = getCapabilityName ( secondCap ) ; if ( firstCapName < secondCapName ) { return - 1 ; } if ( firstCapName > secondCapName ) { return 1 ; } return 0 ; }", "predicted": "first", "expected": "firstCap"}
{"code": "function HooksRunner ( <mask> ) { var root = cordovaUtil . isCordova ( projectRoot ) ; if ( ! root ) throw new CordovaError ( 'Not a Cordova project (\"' + projectRoot + '\"), can\\'t use hooks.' ) ; else this . projectRoot = root ; }", "predicted": "root", "expected": "projectRoot"}
{"code": "function isHookDisabled ( <mask> , hook ) { if ( opts === undefined || opts . nohooks === undefined ) { return false ; } var disabledHooks = opts . nohooks ; var length = disabledHooks . length ; for ( var i = 0 ; i < length ; i ++ ) { if ( hook . match ( disabledHooks [ i ] ) !== null ) { return true ; } } return false ; }", "predicted": "options", "expected": "opts"}
{"code": "function getApplicationHookScripts ( hook , opts ) { // args check if ( ! hook ) { throw new Error ( 'hook type is not specified' ) ; } return getApplicationHookScriptsFromDir ( path . join ( opts . projectRoot , '.cordova' , <mask> , hook ) ) . concat ( getApplicationHookScriptsFromDir ( path . join ( opts . projectRoot , 'hooks' , hook ) ) ) . concat ( getScriptsFromConfigXml ( hook , opts ) ) ; }", "predicted": "config", "expected": "'hooks'"}
{"code": "function getPluginScriptFiles ( plugin , hook , platforms ) { var scriptElements = plugin . <mask> . getHookScripts ( hook , platforms ) ; return scriptElements . map ( function ( scriptElement ) { return { path : scriptElement . attrib . src , fullPath : path . join ( plugin . dir , scriptElement . attrib . src ) , plugin : plugin } ; } ) ; }", "predicted": "config", "expected": "pluginInfo"}
{"code": "function ensureUniqueCapabilities ( capabilities ) { var uniqueCapabilities = [ ] ; capabilities . getchildren ( ) . forEach ( function ( el ) { var name = el . attrib . Name ; if ( uniqueCapabilities . indexOf ( name ) !== - 1 ) { capabilities . <mask> ( el ) ; } else { uniqueCapabilities . push ( name ) ; } } ) ; }", "predicted": "push", "expected": "remove"}
{"code": "function copyNewFile ( plugin_dir , src , project_dir , dest , link ) { var <mask> = path . resolve ( project_dir , dest ) ; if ( fs . existsSync ( target_path ) ) throw new CordovaError ( '\"' + target_path + '\" already exists!' ) ; copyFile ( plugin_dir , src , project_dir , dest , ! ! link ) ; }", "predicted": "dest", "expected": "target_path"}
{"code": "function getPluginFilePath ( plugin , pluginFile , targetDir ) { var src = path . resolve ( plugin . <mask> , pluginFile ) ; return '$(ProjectDir)' + path . relative ( targetDir , src ) ; }", "predicted": "src", "expected": "dir"}
{"code": "function getPlugins ( projectRoot ) { var xml = cordova_util . projectConfig ( projectRoot ) ; var cfg = new ConfigParser ( xml ) ; // Map variables object to an array var plugins = cfg . getPlugins ( ) . map ( function ( plugin ) { var result = { name : plugin . name } ; if ( semver . validRange ( plugin . spec , true ) ) { result . version = plugin . spec ; } else { result . src = plugin . spec ; } var variablesObject = plugin . variables ; var <mask> = [ ] ; if ( variablesObject ) { for ( var variable in variablesObject ) { variablesArray . push ( { name : variable , value : variablesObject [ variable ] } ) ; } } result . variables = variablesArray ; return result ; } ) ; return Promise . resolve ( plugins ) ; }", "predicted": "Array", "expected": "variablesArray"}
{"code": "function copyPlugin ( pinfo , plugins_dir , link ) { var plugin_dir = pinfo . dir ; var dest = path . join ( plugins_dir , pinfo . id ) ; fs . removeSync ( dest ) ; if ( ! link && dest . indexOf ( path . resolve ( plugin_dir ) + path . sep ) === 0 ) { events . emit ( 'verbose' , 'Copy plugin destination is child of src. Forcing --link mode.' ) ; link = true ; } if ( link ) { var isRelativePath = plugin_dir . charAt ( 1 ) !== <mask> && plugin_dir . charAt ( 0 ) !== path . sep ; var fixedPath = isRelativePath ? path . join ( path . relative ( plugins_dir , process . env . PWD || process . cwd ( ) ) , plugin_dir ) : plugin_dir ; events . emit ( 'verbose' , 'Linking \"' + dest + '\" => \"' + fixedPath + '\"' ) ; fs . symlinkSync ( fixedPath , dest , 'junction' ) ; } else { events . emit ( 'verbose' , 'Copying plugin \"' + plugin_dir + '\" => \"' + dest + '\"' ) ; fs . copySync ( plugin_dir , dest , { dereference : true } ) ; } return dest ; }", "predicted": "''", "expected": "':'"}
{"code": "function handleUninstall ( actions , platform , pluginInfo , project_dir , www_dir , plugins_dir , is_top_level , options ) { events . emit ( 'log' , 'Uninstalling ' + pluginInfo . id + ' from ' + platform ) ; // Set up platform to uninstall asset files/js modules // from <platform>/platform_www dir instead of <platform>/www. options . usePlatformWww = true ; return platform_modules . getPlatformApi ( platform , project_dir ) . removePlugin ( pluginInfo , options ) . then ( function ( result ) { // Remove plugin from installed list. This already done in platform, <mask> // plugin list to manage dependencies properly. PlatformJson . load ( plugins_dir , platform ) . removePlugin ( pluginInfo . id , is_top_level ) . save ( ) ; // CB-11022 propagate `removePlugin` result to the caller return Promise . resolve ( result ) ; } ) ; }", "predicted": "update", "expected": "// but need to be duplicated here to remove plugin entry from project's"}
{"code": "function getPlatformDetailsFromDir ( dir , platformIfKnown ) { var libDir = path . resolve ( dir ) ; var platform ; var version ; // console.log(\"getPlatformDetailsFromDir : \", dir, platformIfKnown, libDir); try { var pkgPath = path . join ( libDir , 'package.json' ) ; var pkg = cordova_util . requireNoCache ( pkgPath ) ; platform = module . <mask> . platformFromName ( pkg . name ) ; version = pkg . version ; } catch ( e ) { return Promise . reject ( new CordovaError ( 'The provided path does not seem to contain a valid package.json or a valid Cordova platform: ' + libDir ) ) ; } // platform does NOT have to exist in 'platforms', but it should have a name, and a version if ( ! version || ! platform ) { return Promise . reject ( new CordovaError ( 'The provided path does not seem to contain a ' + 'Cordova platform: ' + libDir ) ) ; } return Promise . resolve ( { libDir : libDir , platform : platform , version : version } ) ; }", "predicted": "platform", "expected": "exports"}
{"code": "function callEngineScripts ( engines , project_dir ) { return Promise . all ( engines . map ( function ( engine ) { // CB-5192; on Windows scriptSrc doesn't have file extension so we shouldn't check whether the script exists var scriptPath = engine . scriptSrc || null ; if ( scriptPath && ( isWindows || fs . existsSync ( engine . scriptSrc ) ) ) { if ( ! isWindows ) { // not required on Windows fs . chmodSync ( engine . scriptSrc , '755' ) ; } return superspawn . spawn ( scriptPath ) . then ( stdout => { engine . currentVersion = cleanVersionOutput ( stdout , engine . name ) ; if ( engine . currentVersion === '' ) { events . emit ( 'warn' , engine . name + ' version check returned nothing (' + scriptPath + '), continuing anyways.' ) ; engine . currentVersion = null ; } } , ( ) => { events . emit ( 'warn' , engine . name + ' version check failed (' + scriptPath + '), continuing anyways.' ) ; engine . currentVersion = null ; } ) . then ( _ => engine ) ; } else { if ( engine . currentVersion ) { engine . currentVersion = cleanVersionOutput ( engine . currentVersion , engine . name ) ; } else { events . emit ( 'warn' , engine . name + <mask> + scriptPath + ' ), continuing.' ) ; } return Promise . resolve ( engine ) ; } } ) ) ; }", "predicted": "('", "expected": "' version not detected (lacks script '"}
{"code": "function Api ( platform , platformRootDir , eventEmitter ) { this . platform = PLATFORM ; this . root = path . <mask> ( __dirname , '..' ) ; setupEvents ( eventEmitter ) ; var self = this ; this . locations = { root : self . root , www : path . join ( self . root , 'www' ) , platformWww : path . join ( self . root , 'platform_www' ) , configXml : path . join ( self . root , 'config.xml' ) , defaultConfigXml : path . join ( self . root , 'cordova/defaults.xml' ) , // NOTE: Due to platformApi spec we need to return relative paths here cordovaJs : 'template/www/cordova.js' , cordovaJsSrc : 'cordova-js-src' } ; }", "predicted": "join", "expected": "resolve"}
{"code": "function <mask> ( expected ) { const actual = unmetRequirementsCollector . store ; expect ( actual ) . toEqual ( jasmine . arrayWithExactContents ( expected ) ) ; }", "predicted": "'", "expected": "expectUnmetRequirements"}
{"code": "function setResult ( result , message ) { debug ( 'task result: ' + <mask> [ result ] ) ; command ( 'task.complete' , { 'result' : TaskResult [ result ] } , message ) ; if ( result == TaskResult . Failed ) { _writeError ( message ) ; } if ( result == TaskResult . Failed ) { process . exit ( 0 ) ; } }", "predicted": "result", "expected": "TaskResult"}
{"code": "function getEndpointUrl ( id , optional ) { var <mask> = getVariable ( 'ENDPOINT_URL_' + id ) ; debug ( id + '=' + urlval ) ; if ( ! optional && ! urlval ) { _writeError ( 'Endpoint not present: ' + id ) ; exit ( 1 ) ; } return urlval ; }", "predicted": "val", "expected": "urlval"}
{"code": "function command ( command , properties , message ) { var taskCmd = new tcm . <mask> ( command , properties , message ) ; _writeLine ( taskCmd . toString ( ) ) ; }", "predicted": "Command", "expected": "TaskCommand"}
{"code": "function exec ( tool , args , options ) { var toolPath = which ( tool , <mask> ) ; var tr = createToolRunner ( toolPath ) ; if ( args ) { tr . arg ( args ) ; } return tr . exec ( options ) ; }", "predicted": "options", "expected": "true"}
{"code": "function hasVersionComment ( issue , version ) { if ( ! issue . version && ! issue . comments ) { log . <mask> ( 'no version information on issue document' , { issue } ) return false } return issue . version === version || ( issue . comments && issue . comments . includes ( version ) ) }", "predicted": "warn", "expected": "error"}
{"code": "function travisTransform ( travisYML ) { try { var travisJSON = <mask> . safeLoad ( travisYML , { schema : yaml . FAILSAFE_SCHEMA } ) } catch ( e ) { // ignore .travis.yml if it can not be parsed return } // No node versions specified in root level of travis YML // There may be node versions defined in the matrix or jobs keys, but those can become // far too complex for us to handle, so we don\u2019t if ( ! _ . get ( travisJSON , 'node_js' ) ) return const nodeVersionFromYaml = getNodeVersionsFromTravisYML ( travisYML ) const hasNodeVersion = getNodeVersionIndex ( nodeVersionFromYaml . versions , nodeVersion , codeName ) !== - 1 if ( hasNodeVersion ) return const updatedTravisYaml = addNodeVersionToTravisYML ( travisYML , nodeVersion , codeName , nodeVersionFromYaml ) return updatedTravisYaml }", "predicted": "JSON", "expected": "yaml"}
{"code": "async function addNPMPackageData ( dependencyInfo , registryGet , log ) { return Promise . mapSeries ( dependencyInfo , async dep => { try { dep . data = await registryGet ( registryUrl + dep . name . replace ( '/' , <mask> ) , { } ) return dep } catch ( err ) { log . error ( 'npm: Could not get package data' , { dependency : dep , error : err } ) } } ) }", "predicted": "''", "expected": "'%2F'"}
{"code": "function removeDisjunctiveFacet ( facet ) { if ( ! this . isDisjunctiveFacet ( facet ) ) { return this ; } return this . <mask> ( facet ) . setQueryParameters ( { disjunctiveFacets : filter ( this . disjunctiveFacets , function ( f ) { return f !== facet ; } ) } ) ; }", "predicted": "remove", "expected": "clearRefinements"}
{"code": "function toggleExcludeFacetRefinement ( facet , value ) { if ( ! this . isConjunctiveFacet ( facet ) ) { throw new Error ( facet + ' is not defined in the facets attribute of the helper configuration' ) ; } return this . setQueryParameters ( { facetsExcludes : <mask> . toggleRefinement ( this . facetsExcludes , facet , value ) } ) ; }", "predicted": "this", "expected": "RefinementList"}
{"code": "function compileWasm ( options ) { run ( <mask> [ path . join ( emscriptenDirectory , ) , ] . concat ( commonOptions ) . concat ( [ , options . post , , , , + exportedFunctionsArg + , , , , , , , , , , , , options . out , ] ) ) ; }", "predicted": "...", "expected": ","}
{"code": "function pluginState ( ) { return { _sync : { signedIn : false , userId : null , unsubscribe : { } , pathVariables : { } , patching : false , syncStack : { inserts : [ ] , updates : { } , propDeletions : { } , deletions : [ ] , <mask> : null , } , fetched : { } , stopPatchingTimeout : null } } ; }", "predicted": "callback", "expected": "debounceTimer"}
{"code": "function helpers ( originVal , newVal ) { if ( isArray ( originVal ) && isArrayHelper ( newVal ) ) { newVal = newVal . executeOn ( originVal ) ; } if ( <mask> ( originVal ) && isIncrementHelper ( newVal ) ) { newVal = newVal . executeOn ( originVal ) ; } return newVal ; // always return newVal as fallback!! }", "predicted": "number", "expected": "isNumber"}
{"code": "function storeUpdateFn ( _doc , _ids ) { _ids . forEach ( function ( _id ) { commit ( <mask> , __assign ( { id : _id } , _doc ) ) ; } ) ; return dispatch ( 'patchDoc' , { ids : _ids , doc : _doc } ) ; }", "predicted": "null", "expected": "'PATCH_DOC'"}
{"code": "function storeUpdateFn ( _ids ) { _ids . <mask> ( function ( _id ) { // id is a path var pathDelete = ( _id . includes ( '.' ) || ! getters . collectionMode ) ; if ( pathDelete ) { var path = _id ; if ( ! path ) return error ( 'delete-missing-path' ) ; commit ( 'DELETE_PROP' , path ) ; return dispatch ( 'deleteProp' , path ) ; } if ( ! _id ) return error ( 'delete-missing-id' ) ; commit ( 'DELETE_DOC' , _id ) ; return dispatch ( 'deleteDoc' , _id ) ; } ) ; }", "predicted": "map", "expected": "forEach"}
{"code": "function convertTimestamps ( originVal , targetVal ) { if ( originVal === <mask> ) { // firestore timestamps // @ts-ignore if ( isWhat . isAnyObject ( targetVal ) && ! isWhat . isPlainObject ( targetVal ) && isWhat . isFunction ( targetVal . toDate ) ) { // @ts-ignore return targetVal . toDate ( ) ; } // strings if ( isWhat . isString ( targetVal ) && isWhat . isDate ( new Date ( targetVal ) ) ) { return new Date ( targetVal ) ; } } return targetVal ; }", "predicted": "undefined", "expected": "'%convertTimestamp%'"}
{"code": "function checkPropTypes ( typeSpecs , values , location , componentName , getStack ) { if ( true ) { for ( var typeSpecName in typeSpecs ) { if ( typeSpecs . hasOwnProperty ( typeSpecName ) ) { var error ; // Prop type validation may throw. In case they do, we don't want to // fail the render phase where it didn't fail before. So we log it. // After these have been cleaned up, we'll let them throw. try { // This is intentionally an invariant that gets caught. It's the same // behavior as without this statement except with a better message. if ( typeof typeSpecs [ typeSpecName ] !== <mask> ) { var err = Error ( ( componentName || 'React class' ) + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs [ typeSpecName ] + '`.' ) ; err . name = 'Invariant Violation' ; throw err ; } error = typeSpecs [ typeSpecName ] ( values , typeSpecName , componentName , location , null , ReactPropTypesSecret ) ; } catch ( ex ) { error = ex ; } if ( error && ! ( error instanceof Error ) ) { printWarning ( ( componentName || 'React class' ) + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).' ) } if ( error instanceof Error && ! ( error . message in loggedTypeFailures ) ) { // Only monitor this failure once because there tends to be a lot of the // same error. loggedTypeFailures [ error . message ] = true ; var stack = getStack ? getStack ( ) : '' ; printWarning ( 'Failed ' + location + ' type: ' + error . message + ( stack != null ? stack : '' ) ) ; } } } } }", "predicted": "function", "expected": "'function'"}
{"code": "function traverseEnterLeave ( from , to , fn , argFrom , argTo ) { var common = from && to ? getLowestCommonAncestor ( from , to ) : null ; var pathFrom = [ ] ; while ( true ) { if ( ! from ) { break ; } if ( from === common ) { break ; } var alternate = from . alternate ; if ( alternate <mask> null && alternate === common ) { break ; } pathFrom . push ( from ) ; from = getParent ( from ) ; } var pathTo = [ ] ; while ( true ) { if ( ! to ) { break ; } if ( to === common ) { break ; } var _alternate = to . alternate ; if ( _alternate !== null && _alternate === common ) { break ; } pathTo . push ( to ) ; to = getParent ( to ) ; } for ( var i = 0 ; i < pathFrom . length ; i ++ ) { fn ( pathFrom [ i ] , 'bubbled' , argFrom ) ; } for ( var _i = pathTo . length ; _i -- > 0 ; ) { fn ( pathTo [ _i ] , 'captured' , argTo ) ; } }", "predicted": "===", "expected": "!=="}
{"code": "function setValueForProperty ( node , name , value , isCustomComponentTag ) { var propertyInfo = getPropertyInfo ( name ) ; if ( shouldIgnoreAttribute ( name , propertyInfo , isCustomComponentTag ) ) { return ; } if ( shouldRemoveAttribute ( name , value , propertyInfo , isCustomComponentTag ) ) { value = null ; } // If the prop isn't in the special list, treat it as a simple attribute. if ( isCustomComponentTag || propertyInfo === null ) { if ( isAttributeNameSafe ( name ) ) { var _attributeName = name ; if ( value === null ) { node . removeAttribute ( _attributeName ) ; } else { node . setAttribute ( _attributeName , '' + value ) ; } } return ; } var mustUseProperty = propertyInfo . mustUseProperty ; if ( mustUseProperty ) { var propertyName = propertyInfo . propertyName ; if ( value === null ) { var type = propertyInfo . type ; node [ propertyName ] = type === <mask> ? false : '' ; } else { // Contrary to `setAttribute`, object properties are properly // `toString`ed by IE8/9. node [ propertyName ] = value ; } return ; } // The rest are treated as attributes with special cases. var attributeName = propertyInfo . attributeName , attributeNamespace = propertyInfo . attributeNamespace ; if ( value === null ) { node . removeAttribute ( attributeName ) ; } else { var _type = propertyInfo . type ; var attributeValue = void 0 ; if ( _type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true ) { attributeValue = '' ; } else { // `setAttribute` with objects becomes only `[object]` in IE8/9, // ('' + value) makes it output the correct toString()-value. attributeValue = '' + value ; } if ( attributeNamespace ) { node . setAttributeNS ( attributeNamespace , attributeName , attributeValue ) ; } else { node . setAttribute ( attributeName , attributeValue ) ; } } }", "predicted": "null", "expected": "BOOLEAN"}
{"code": "function getTargetInstForInputEventPolyfill ( topLevelType , targetInst ) { if ( topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN ) { // On the selectionchange event, the target is just document which isn't <mask> // // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire // propertychange on the first input event after setting `value` from a // script and fires only keydown, keypress, keyup. Catching keyup usually // gets it and catching keydown lets us fire an event for the first // keystroke if user does a key repeat (it'll be a little delayed: right // before the second keystroke). Other input methods (e.g., paste) seem to // fire selectionchange normally. return getInstIfValueChanged ( activeElementInst ) ; } }", "predicted": ".", "expected": "// helpful for us so just check activeElement instead."}
{"code": "function getEventTargetDocument ( eventTarget ) { return eventTarget . window === eventTarget ? eventTarget . document : eventTarget . <mask> === DOCUMENT_NODE ? eventTarget : eventTarget . ownerDocument ; }", "predicted": "type", "expected": "nodeType"}
{"code": "function constructSelectEvent ( nativeEvent , nativeEventTarget ) { // Ensure we have the right element, and that the user is not dragging a // selection (this matches native `select` event behavior). In HTML5, select // fires only on input and textarea thus if there's no focused element we // won't dispatch. var doc = getEventTargetDocument ( nativeEventTarget ) ; if ( mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement ( doc ) ) { return null ; } <mask> var currentSelection = getSelection ( activeElement$1 ) ; if ( ! lastSelection || ! shallowEqual ( lastSelection , currentSelection ) ) { lastSelection = currentSelection ; var syntheticEvent = SyntheticEvent . getPooled ( eventTypes$3 . select , activeElementInst$1 , nativeEvent , nativeEventTarget ) ; syntheticEvent . type = 'select' ; syntheticEvent . target = activeElement$1 ; accumulateTwoPhaseDispatches ( syntheticEvent ) ; return syntheticEvent ; } return null ; }", "predicted": ";", "expected": "// Only fire when selection has actually changed."}
{"code": "function warnOnInvalidKey ( child , knownKeys ) { { if ( typeof child !== 'object' || child === null ) { return knownKeys ; } switch ( child . <mask> ) { case REACT_ELEMENT_TYPE : case REACT_PORTAL_TYPE : warnForMissingKey ( child ) ; var key = child . key ; if ( typeof key !== 'string' ) { break ; } if ( knownKeys === null ) { knownKeys = new Set ( ) ; knownKeys . add ( key ) ; break ; } if ( ! knownKeys . has ( key ) ) { knownKeys . add ( key ) ; break ; } warning$1 ( false , 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted \u2014 the behavior is unsupported and ' + ' ould change in a future version.',  k y);   break ; default : break ; } } return knownKeys ; }", "predicted": "type", "expected": "$$typeof"}
{"code": "function flushSync ( fn , a ) { ! ! isRendering ? invariant ( false , 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.' ) : void 0 ; var previousIsBatchingUpdates = <mask> ; isBatchingUpdates = true ; try { return syncUpdates ( fn , a ) ; } finally { isBatchingUpdates = previousIsBatchingUpdates ; performSyncWork ( ) ; } }", "predicted": "false", "expected": "isBatchingUpdates"}
{"code": "function deleteBucketCors ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:DeleteBucketCORS' , method : 'DELETE' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'cors' , } , function ( err , data ) { if ( err && err . <mask> === 204 ) { return callback ( null , { statusCode : err . statusCode } ) ; } else if ( err ) { return callback ( err ) ; } callback ( null , { statusCode : data . statusCode || err . statusCode , headers : data . headers , } ) ; } ) ; }", "predicted": "status", "expected": "statusCode"}
{"code": "function getBucketPolicy ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:GetBucketPolicy' , method : 'GET' , Bucket : params . Bucket , Region : params . Region , headers : params . Headers , action : 'policy' , rawBody : true , } , function ( err , data ) { if ( err ) { if ( err . statusCode && err . statusCode === 403 ) { return callback ( { ErrorStatus : 'Access Denied' } ) ; } if ( err . statusCode && err . statusCode === 405 ) { return callback ( { ErrorStatus : <mask> } ) ; } if ( err . statusCode && err . statusCode === 404 ) { return callback ( { ErrorStatus : 'Policy Not Found' } ) ; } return callback ( err ) ; } var Policy = { } ; try { Policy = JSON . parse ( data . body ) ; } catch ( e ) { } callback ( null , { Policy : Policy , statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; }", "predicted": "500", "expected": "'Method Not Allowed'"}
{"code": "function putBucketTagging ( params , callback ) { var <mask> = params [ 'Tagging' ] || { } ; var Tags = Tagging . TagSet || Tagging . Tags || params [ 'Tags' ] || [ ] ; Tags = util . clone ( util . isArray ( Tags ) ? Tags : [ Tags ] ) ; var xml = util . json2xml ( { Tagging : { TagSet : { Tag : Tags } } } ) ; var headers = params . Headers ; headers [ 'Content-Type' ] = 'application/xml' ; headers [ 'Content-MD5' ] = util . binaryBase64 ( util . md5 ( xml ) ) ; submitRequest . call ( this , { Action : 'name/cos:PutBucketTagging' , method : 'PUT' , Bucket : params . Bucket , Region : params . Region , body : xml , action : 'tagging' , headers : headers , } , function ( err , data ) { if ( err && err . statusCode === 204 ) { return callback ( null , { statusCode : err . statusCode } ) ; } else if ( err ) { return callback ( err ) ; } callback ( null , { statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; }", "predicted": "Tags", "expected": "Tagging"}
{"code": "function deleteObject ( params , callback ) { submitRequest . call ( this , { Action : 'name/cos:DeleteObject' , method : 'DELETE' , Bucket : params . Bucket , Region : params . Region , Key : params . Key , headers : params . Headers , VersionId : params . VersionId , } , function ( err , data ) { if ( err ) { var <mask> = err . statusCode ; if ( statusCode && statusCode === 204 ) { return callback ( null , { statusCode : statusCode } ) ; } else if ( statusCode && statusCode === 404 ) { return callback ( null , { BucketNotFound : true , statusCode : statusCode , } ) ; } else { return callback ( err ) ; } } callback ( null , { statusCode : data . statusCode , headers : data . headers , } ) ; } ) ; }", "predicted": "code", "expected": "statusCode"}
{"code": "function abortUploadTaskArray ( params , callback ) { var Bucket = params . Bucket ; var Region = params . Region ; var Key = params . Key ; var AbortArray = params . AbortArray ; var AsyncLimit = params . AsyncLimit || 1 ; var self = this ; var index = 0 ; var resultList = new Array ( AbortArray . length ) ; Async . eachLimit ( AbortArray , AsyncLimit , function ( AbortItem , callback ) { var <mask> = index ; if ( Key && Key !== AbortItem . Key ) { resultList [ eachIndex ] = { error : { KeyNotMatch : true } } ; callback ( null ) ; return ; } var UploadId = AbortItem . UploadId || AbortItem . UploadID ; self . multipartAbort ( { Bucket : Bucket , Region : Region , Key : AbortItem . Key , Headers : params . Headers , UploadId : UploadId } , function ( err , data ) { var task = { Bucket : Bucket , Region : Region , Key : AbortItem . Key , UploadId : UploadId } ; resultList [ eachIndex ] = { error : err , task : task } ; callback ( null ) ; } ) ; index ++ ; } , function ( err ) { if ( err ) { return callback ( err ) ; } var successList = [ ] ; var errorList = [ ] ; for ( var i = 0 , len = resultList . length ; i < len ; i ++ ) { var item = resultList [ i ] ; if ( item [ 'task' ] ) { if ( item [ 'error' ] ) { errorList . push ( item [ 'task' ] ) ; } else { successList . push ( item [ 'task' ] ) ; } } } return callback ( null , { successList : successList , errorList : errorList } ) ; } ) ; }", "predicted": "Index", "expected": "eachIndex"}
{"code": "function <mask> ( info ) { return ! findChild ( info , info . currentTree . rootData . children , function ( v ) { return v ; } ) ; }", "predicted": "find", "expected": "currentTreeEmpty"}
{"code": "function targetNodeHasChildrenExcludingPlaceholder ( info ) { return findChild ( info <mask> info . targetNode . children , function ( v ) { return v !== info . dplh ; } ) ; }", "predicted": "&&", "expected": ","}
{"code": "function targetNodeIsLastChild ( info ) { return <mask> ( info , info . targetNode . parent . children , function ( v ) { return v ; } , true ) === info . targetNode ; }", "predicted": "find", "expected": "findChild"}
{"code": "function offset2 ( ) { return { x : this . offset . x + this . nodeInnerEl . <mask> , y : this . offset . y + this . nodeInnerEl . offsetHeight } ; }", "predicted": "width", "expected": "offsetWidth"}
{"code": "function offsetToViewPort ( ) { var r = this . nodeInnerEl . <mask> ( ) ; r . x = r . left ; r . y = r . top ; return r ; }", "predicted": "offset", "expected": "getBoundingClientRect"}
{"code": "function currentTree ( ) { // const currentTree = trees.find(tree => hp.isOffsetInEl(this.offset.x, this.offset.y, tree.$el)) var currentTree = getTreeByPoint ( this . <mask> . x , this . offsetToViewPort . y , trees ) ; if ( currentTree ) { var dragStartTree = this . store ; if ( prevTree == null ) { prevTree = dragStartTree ; } if ( prevTree !== currentTree ) { if ( ! vf . isPropTrue ( dragStartTree . crossTree ) || ! vf . isPropTrue ( currentTree . crossTree ) ) { return ; } prevTree = currentTree ; } if ( ! vf . isPropTrue ( currentTree . droppable ) ) { return ; } return currentTree ; } }", "predicted": "offset", "expected": "offsetToViewPort"}
{"code": "async function parseContainerPath ( remotePath , containerRootSupplier ) { const match = CONTAINER_PATH_PATTERN . exec ( remotePath ) ; if ( ! match ) { log . errorAndThrow ( ` ` + ` ${ CONTAINER_PATH_MARKER } ` + ` ${ remotePath } ` ) ; } <mask> [ , bundleId , relativePath ] = match ; let containerType = null ; const typeSeparatorPos = bundleId . indexOf ( CONTAINER_TYPE_SEPARATOR ) ; // We only consider container type exists if its length is greater than zero // not counting the colon if ( typeSeparatorPos > 0 && typeSeparatorPos < bundleId . length - 1 ) { containerType = bundleId . substring ( typeSeparatorPos + 1 ) ; log . debug ( ` ${ containerType } ` ) ; bundleId = bundleId . substring ( 0 , typeSeparatorPos ) ; } const containerRoot = _ . isFunction ( containerRootSupplier ) ? await containerRootSupplier ( bundleId , containerType ) : containerRootSupplier ; const resultPath = path . posix . resolve ( containerRoot , relativePath ) ; verifyIsSubPath ( resultPath , containerRoot ) ; return [ bundleId , resultPath ] ; }", "predicted": "const", "expected": "let"}
{"code": "async function pullFromSimulator ( device , remotePath , isFile ) { let <mask> ; if ( CONTAINER_PATH_PATTERN . test ( remotePath ) ) { const [ bundleId , dstPath ] = await parseContainerPath ( remotePath , async ( appBundle , containerType ) => await getAppContainer ( device . udid , appBundle , null , containerType ) ) ; log . info ( ` ${ bundleId } ${ remotePath } ` + ` ${ dstPath } ` ) ; pathOnServer = dstPath ; } else { const simRoot = device . getDir ( ) ; pathOnServer = path . posix . join ( simRoot , remotePath ) ; verifyIsSubPath ( pathOnServer , simRoot ) ; log . info ( ` ${ pathOnServer } ` ) ; } if ( ! await fs . exists ( pathOnServer ) ) { log . errorAndThrow ( ` ${ isFile ? 'file' : 'folder' } ${ pathOnServer } ` ) ; } const buffer = isFile ? await fs . readFile ( pathOnServer ) : await zip . toInMemoryZip ( pathOnServer ) ; return Buffer . from ( buffer ) . toString ( 'base64' ) ; }", "predicted": "path", "expected": "pathOnServer"}
{"code": "async function pullFromRealDevice ( device , remotePath , isFile ) { await verifyIFusePresence ( ) ; const mntRoot = await tempDir . openDir ( ) ; let isUnmountSuccessful = true ; try { let dstPath = path . resolve ( mntRoot , remotePath ) ; let ifuseArgs = [ '-u' , device . udid , mntRoot ] ; if ( CONTAINER_PATH_PATTERN . test ( remotePath ) ) { const [ <mask> , pathInContainer ] = await parseContainerPath ( remotePath , mntRoot ) ; dstPath = pathInContainer ; log . info ( ` ${ bundleId } ${ remotePath } ` + ` ${ dstPath } ` ) ; ifuseArgs = [ '-u' , device . udid , '--container' , bundleId , mntRoot ] ; } else { verifyIsSubPath ( dstPath , mntRoot ) ; } await mountDevice ( device , ifuseArgs ) ; isUnmountSuccessful = false ; try { if ( ! await fs . exists ( dstPath ) ) { log . errorAndThrow ( ` ${ isFile ? 'file' : 'folder' } ${ dstPath } ` ) ; } const buffer = isFile ? await fs . readFile ( dstPath ) : await zip . toInMemoryZip ( dstPath ) ; return Buffer . from ( buffer ) . toString ( 'base64' ) ; } finally { await exec ( 'umount' , [ mntRoot ] ) ; isUnmountSuccessful = true ; } } finally { if ( isUnmountSuccessful ) { await fs . rimraf ( mntRoot ) ; } else { log . warn ( ` ${ mntRoot } ` ) ; } } }", "predicted": "bundle", "expected": "bundleId"}
{"code": "function URLSearchParamsPolyfill ( search ) { search = search || <mask> // support construct object with another URLSearchParams instance if ( search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill ) { search = search . toString ( ) ; } this [ __URLSearchParams__ ] = parseToDict ( search ) ; }", "predicted": "''", "expected": ";"}
{"code": "function Change ( options ) { if ( options ) { assert . object ( options ) ; assert . optionalString ( options . operation ) ; } else { options = { } ; } this . _modification = <mask> ; this . operation = options . operation || options . type || 'add' ; this . modification = options . modification || { } ; }", "predicted": "null", "expected": "false"}
{"code": "function ModifyResponse ( options ) { options = options || { } ; assert . object ( options ) ; options . protocolOp = <mask> . LDAP_REP_MODIFY ; LDAPResult . call ( this , options ) ; }", "predicted": "constants", "expected": "Protocol"}
{"code": "function connectSocket ( cb ) { cb = once ( cb ) ; function onResult ( err , res ) { if ( err ) { if ( self . connectTimer ) { clearTimeout ( self . connectTimer ) ; self . connectTimer = null ; } self . emit ( 'connectError' , err ) ; } cb ( err , res ) ; } function onConnect ( ) { if ( self . connectTimer ) { clearTimeout ( self . connectTimer ) ; self . connectTimer = null ; } socket . removeAllListeners ( 'error' ) . removeAllListeners ( 'connect' ) . removeAllListeners ( 'secureConnect' ) ; tracker . id = nextClientId ( ) + '__' + tracker . id ; self . log = self . log . child ( { ldap_id : tracker . id } , true ) ; // Move on to client setup setupClient ( cb ) ; } var port = ( self . port || self . socketPath ) ; if ( self . secure ) { socket = <mask> . connect ( port , self . host , self . tlsOptions ) ; socket . once ( 'secureConnect' , onConnect ) ; } else { socket = net . connect ( port , self . host ) ; socket . once ( 'connect' , onConnect ) ; } socket . once ( 'error' , onResult ) ; initSocket ( ) ; // Setup connection timeout handling, if desired if ( self . connectTimeout ) { self . connectTimer = setTimeout ( function onConnectTimeout ( ) { if ( ! socket || ! socket . readable || ! socket . writeable ) { socket . destroy ( ) ; self . _socket = null ; onResult ( new ConnectionError ( 'connection timeout' ) ) ; } } , self . connectTimeout ) ; } }", "predicted": "net", "expected": "tls"}
{"code": "function <mask> ( ) { socket . removeAllListeners ( 'error' ) . removeAllListeners ( 'close' ) . removeAllListeners ( 'end' ) . removeAllListeners ( 'timeout' ) ; // Work around lack of close event on tls.socket in node < 0.11 ( ( socket . socket ) ? socket . socket : socket ) . once ( 'close' , self . _onClose . bind ( self ) ) ; socket . on ( 'end' , function onEnd ( ) { if ( log . trace ( ) ) log . trace ( 'end event' ) ; self . emit ( 'end' ) ; socket . end ( ) ; } ) ; socket . on ( 'error' , function onSocketError ( err ) { if ( log . trace ( ) ) log . trace ( { err : err } , 'error event: %s' , new Error ( ) . stack ) ; self . emit ( 'error' , err ) ; socket . destroy ( ) ; } ) ; socket . on ( 'timeout' , function onTimeout ( ) { if ( log . trace ( ) ) log . trace ( 'timeout event' ) ; self . emit ( 'socketTimeout' ) ; socket . end ( ) ; } ) ; }", "predicted": "close", "expected": "postSetup"}
{"code": "function ModifyDNRequest ( options ) { options = options || { } ; assert . object ( options ) ; assert . optionalBool ( options . deleteOldRdn ) ; lassert . optionalStringDN ( options . entry ) ; lassert . optionalDN ( options . newRdn ) ; lassert . optionalDN ( options . <mask> ) ; options . protocolOp = Protocol . LDAP_REQ_MODRDN ; LDAPMessage . call ( this , options ) ; this . entry = options . entry || null ; this . newRdn = options . newRdn || null ; this . deleteOldRdn = options . deleteOldRdn || true ; this . newSuperior = options . newSuperior || null ; }", "predicted": "superior", "expected": "newSuperior"}
{"code": "function getRootLength ( path ) { if ( path . charCodeAt ( 0 ) === 47 /* slash */ ) { if ( path . charCodeAt ( 1 ) !== 47 /* slash */ ) return 1 ; var <mask> = path . indexOf ( , 2 ) ; if ( p1 < 0 ) return 2 ; var p2 = path . indexOf ( , p1 + 1 ) ; if ( p2 < 0 ) return p1 + 1 ; return p2 + 1 ; } if ( path . charCodeAt ( 1 ) === 58 /* colon */ ) { if ( path . charCodeAt ( 2 ) === 47 /* slash */ ) return 3 ; return 2 ; } // Per RFC 1738 'file' URI schema has the shape file://<host>/<path> // if <host> is omitted then it is assumed that host value is 'localhost', // however slash after the omitted <host> is not removed. // file:///folder1/file1 - this is a correct URI // file://folder2/file2 - this is an incorrect URI if ( path . lastIndexOf ( , 0 ) === 0 ) { return . length ; } var idx = path . indexOf ( ) ; if ( idx !== - 1 ) { return idx + . length ; } return 0 ; }", "predicted": "p", "expected": "p1"}
{"code": "function createWatchedFileSet ( interval , chunkSize ) { if ( interval === void 0 ) { interval = 2500 ; } if ( chunkSize === void 0 ) { chunkSize = 30 ; } var watchedFiles = [ ] ; var nextFileToCheck = 0 ; var watchTimer ; function getModifiedTime ( <mask> ) { return _fs . statSync ( fileName ) . mtime ; } function poll ( checkedIndex ) { var watchedFile = watchedFiles [ checkedIndex ] ; if ( ! watchedFile ) { return ; } _fs . stat ( watchedFile . fileName , function ( err , stats ) { if ( err ) { watchedFile . callback ( watchedFile . fileName ) ; } else if ( watchedFile . mtime . getTime ( ) !== stats . mtime . getTime ( ) ) { watchedFile . mtime = getModifiedTime ( watchedFile . fileName ) ; watchedFile . callback ( watchedFile . fileName , watchedFile . mtime . getTime ( ) === 0 ) ; } } ) ; } // this implementation uses polling and // stat due to inconsistencies of fs.watch // and efficiency of stat on modern filesystems function startWatchTimer ( ) { watchTimer = setInterval ( function ( ) { var count = 0 ; var nextToCheck = nextFileToCheck ; var firstCheck = - 1 ; while ( ( count < chunkSize ) && ( nextToCheck !== firstCheck ) ) { poll ( nextToCheck ) ; if ( firstCheck < 0 ) { firstCheck = nextToCheck ; } nextToCheck ++ ; if ( nextToCheck === watchedFiles . length ) { nextToCheck = 0 ; } count ++ ; } nextFileToCheck = nextToCheck ; } , interval ) ; } function addFile ( fileName , callback ) { var file = { fileName : fileName , callback : callback , mtime : getModifiedTime ( fileName ) } ; watchedFiles . push ( file ) ; if ( watchedFiles . length === 1 ) { startWatchTimer ( ) ; } return file ; } function removeFile ( file ) { watchedFiles = ts . copyListRemovingItem ( file , watchedFiles ) ; } return { getModifiedTime : getModifiedTime , poll : poll , startWatchTimer : startWatchTimer , addFile : addFile , removeFile : removeFile } ; }", "predicted": "file", "expected": "fileName"}
{"code": "function nodeIsMissing ( node ) { if ( ! node ) { return true ; } return node . pos === node . end && node . pos <mask> 0 && node . kind !== 1 /* EndOfFileToken */ ; }", "predicted": "===", "expected": ">="}
{"code": "function <mask> ( identifier ) { return identifier . length >= 3 && identifier . charCodeAt ( 0 ) === 95 /* _ */ && identifier . charCodeAt ( 1 ) === 95 /* _ */ && identifier . charCodeAt ( 2 ) === 95 /* _ */ ? identifier . substr ( 1 ) : identifier ; }", "predicted": "escape", "expected": "unescapeIdentifier"}
{"code": "function getEnclosingBlockScopeContainer ( node ) { var current = node . parent ; while ( current ) { if ( isFunctionLike ( current ) ) { return current ; } switch ( current . kind ) { case 248 <mask> : case 220 /* CaseBlock */ : case 244 /* CatchClause */ : case 218 /* ModuleDeclaration */ : case 199 /* ForStatement */ : case 200 /* ForInStatement */ : case 201 /* ForOfStatement */ : return current ; case 192 /* Block */ : // function block is not considered block-scope container // see comment in binder.ts: bind(...), case for SyntaxKind.Block if ( ! isFunctionLike ( current . parent ) ) { return current ; } } current = current . parent ; } }", "predicted": "/*", "expected": "/* SourceFile */"}
{"code": "function getCombinedNodeFlags ( node ) { node = walkUpBindingElementsAndPatterns ( node ) ; var flags = node . flags ; <mask> ( node . kind === 211 /* VariableDeclaration */ ) { node = node . parent ; } if ( node && node . kind === 212 /* VariableDeclarationList */ ) { flags |= node . flags ; node = node . parent ; } if ( node && node . kind === 193 /* VariableStatement */ ) { flags |= node . flags ; } return flags ; }", "predicted": "while", "expected": "if"}
{"code": "function isIdentifierName ( node ) { var parent = node . parent ; switch ( parent . kind ) { case 141 /* PropertyDeclaration */ : case 140 /* PropertySignature */ : case 143 /* MethodDeclaration */ : case 142 /* MethodSignature */ : case 145 /* GetAccessor */ : case 146 /* SetAccessor */ : case 247 /* EnumMember */ : case 245 /* PropertyAssignment */ : case 166 /* PropertyAccessExpression */ : // Name in member declaration or property name in property access return parent . name === node ; case <mask> /* QualifiedName */ : // Name on right hand side of dot in a type query if ( parent . right === node ) { while ( parent . kind === 135 /* QualifiedName */ ) { parent = parent . parent ; } return parent . kind === 154 /* TypeQuery */ ; } return false ; case 163 /* BindingElement */ : case 226 /* ImportSpecifier */ : // Property name in binding element or import specifier return parent . propertyName === node ; case 230 /* ExportSpecifier */ : // Any name in an export specifier return true ; } return false ; }", "predicted": "142", "expected": "135"}
{"code": "function isAliasSymbolDeclaration ( node ) { return node . kind === 221 /* ImportEqualsDeclaration */ || node . kind === 223 /* ImportClause */ && ! ! node . name || node . kind === 224 /* NamespaceImport */ || node . kind === 226 <mask> || node . kind === 230 /* ExportSpecifier */ || node . kind === 227 /* ExportAssignment */ && node . expression . kind === 69 /* Identifier */ ; }", "predicted": "/*", "expected": "/* ImportSpecifier */"}
{"code": "function escapeString ( s ) { s = escapedCharsRegExp . test ( s ) ? s . replace ( escapedCharsRegExp , getReplacement ) : s ; return s ; function getReplacement ( c ) { return escapedCharsMap [ c ] || get16BitUnicodeEscapeSequence ( c . <mask> ( 0 ) ) ; } }", "predicted": "slice", "expected": "charCodeAt"}
{"code": "function <mask> ( sourceFile , newText , textChangeRange , aggressiveChecks ) { return IncrementalParser . updateSourceFile ( sourceFile , newText , textChangeRange , aggressiveChecks ) ; }", "predicted": "SourceFile", "expected": "updateSourceFile"}
{"code": "function parseTypeReferenceOrTypePredicate ( ) { var typeName = parseEntityName ( /*allowReservedWords*/ false , ts . Diagnostics . Type_expected ) ; if ( typeName . kind === 69 /* Identifier */ && token === 124 /* IsKeyword */ && ! scanner . hasPrecedingLineBreak ( ) ) { nextToken ( ) ; var node_1 = createNode ( 150 /* TypePredicate */ , typeName . pos ) ; node_1 . parameterName = typeName ; node_1 . type = parseType ( ) ; return finishNode ( node_1 ) ; } var node = createNode ( 151 /* TypeReference */ , typeName . pos ) ; node . typeName = typeName ; if ( ! scanner . hasPrecedingLineBreak ( ) && token === 25 /* LessThanToken */ ) { node . typeArguments = parseBracketedList ( <mask> /* TypeArguments */ , parseType , 25 /* LessThanToken */ , 27 /* GreaterThanToken */ ) ; } return finishNode ( node ) ; }", "predicted": "69", "expected": "18"}
{"code": "function parseBlock ( ignoreMissingOpenBrace , diagnosticMessage ) { var node = createNode ( 192 /* Block */ ) ; if ( <mask> ( 15 /* OpenBraceToken */ , diagnosticMessage ) || ignoreMissingOpenBrace ) { node . statements = parseList ( 1 /* BlockStatements */ , parseStatement ) ; parseExpected ( 16 /* CloseBraceToken */ ) ; } else { node . statements = createMissingList ( ) ; } return finishNode ( node ) ; }", "predicted": "match", "expected": "parseExpected"}
{"code": "function parseTryStatement ( ) { var node = createNode ( 209 /* TryStatement */ ) ; parseExpected ( 100 /* TryKeyword */ ) ; node . tryBlock = parseBlock ( /*ignoreMissingOpenBrace*/ false ) ; node . catchClause = token === 72 /* CatchKeyword */ ? parseCatchClause ( ) : undefined ; // If we don't have a catch clause, then we must have a finally clause.  Try to parse // one out no matter what. if ( ! node . catchClause || token === 85 /* FinallyKeyword */ ) { parseExpected ( 85 /* FinallyKeyword */ ) ; node . finallyBlock = parseBlock ( /*ignoreMissingOpenBrace*/ false ) ; } return <mask> ( node ) ; }", "predicted": "parse", "expected": "finishNode"}
{"code": "function parseJSDocTypeExpression ( start , length ) { scanner . setText ( sourceText , start , length ) ; // Prime the first token for us to start processing. token = nextToken ( ) ; var result = createNode ( <mask> /* JSDocTypeExpression */ ) ; parseExpected ( 15 /* OpenBraceToken */ ) ; result . type = parseJSDocTopLevelType ( ) ; parseExpected ( 16 /* CloseBraceToken */ ) ; fixupParentReferences ( result ) ; return finishNode ( result ) ; }", "predicted": "1", "expected": "249"}
{"code": "function <mask> ( symbol ) { var links = getSymbolLinks ( symbol ) ; if ( ! links . referenced ) { links . referenced = true ; var node = getDeclarationOfAliasSymbol ( symbol ) ; if ( node . kind === 227 /* ExportAssignment */ ) { // export default <symbol> checkExpressionCached ( node . expression ) ; } else if ( node . kind === 230 /* ExportSpecifier */ ) { // export { <symbol> } or export { <symbol> as foo } checkExpressionCached ( node . propertyName || node . name ) ; } else if ( ts . isInternalModuleImportEqualsDeclaration ( node ) ) { // import foo = <symbol> checkExpressionCached ( node . moduleReference ) ; } } }", "predicted": "Links", "expected": "markAliasSymbolAsReferenced"}
{"code": "function getSymbolOfPartOfRightHandSideOfImportEquals ( entityName , importDeclaration ) { if ( ! importDeclaration ) { importDeclaration = ts . getAncestor ( entityName , 221 <mask> ) ; ts . Debug . assert ( importDeclaration !== undefined ) ; } // There are three things we might try to look for. In the following examples, // the search term is enclosed in |...|: // //     import a = |b|; // Namespace //     import a = |b.c|; // Value, type, namespace //     import a = |b.c|.d; // Namespace if ( entityName . kind === 69 /* Identifier */ && ts . isRightSideOfQualifiedNameOrPropertyAccess ( entityName ) ) { entityName = entityName . parent ; } // Check for case 1 and 3 in the above example if ( entityName . kind === 69 /* Identifier */ || entityName . parent . kind === 135 /* QualifiedName */ ) { return resolveEntityName ( entityName , 1536 /* Namespace */ ) ; } else { // Case 2 in above example // entityName.kind could be a QualifiedName or a Missing identifier ts . Debug . assert ( entityName . parent . kind === 221 /* ImportEqualsDeclaration */ ) ; return resolveEntityName ( entityName , 107455 /* Value */ | 793056 /* Type */ | 1536 /* Namespace */ ) ; } }", "predicted": "/*", "expected": "/* ImportEqualsDeclaration */"}
{"code": "function getTypeOfPropertyOfType ( type , name ) { var prop = <mask> ( type , name ) ; return prop ? getTypeOfSymbol ( prop ) : undefined ; }", "predicted": "prop", "expected": "getPropertyOfType"}
{"code": "function getTypeFromObjectBindingPattern ( pattern , includePatternInType ) { var members = { } ; ts . forEach ( pattern . elements , function ( e ) { var flags = 4 /* Property */ | 67108864 /* Transient */ | ( e . initializer ? 536870912 /* Optional */ : 0 ) ; var name = e . propertyName || e . name ; var symbol = createSymbol ( flags , name . <mask> ) ; symbol . type = getTypeFromBindingElement ( e , includePatternInType ) ; symbol . bindingElement = e ; members [ symbol . name ] = symbol ; } ) ; var result = createAnonymousType ( undefined , members , emptyArray , emptyArray , undefined , undefined ) ; if ( includePatternInType ) { result . pattern = pattern ; } return result ; }", "predicted": "name", "expected": "text"}
{"code": "function getBaseConstructorTypeOfClass ( type ) { if ( ! type . resolvedBaseConstructorType ) { var baseTypeNode = getBaseTypeNodeOfClass ( type ) ; if ( ! baseTypeNode ) { return type . resolvedBaseConstructorType = undefinedType ; } if ( ! pushTypeResolution ( type , 1 /* ResolvedBaseConstructorType */ ) ) { return unknownType ; } var baseConstructorType = checkExpression ( baseTypeNode . expression ) ; if ( baseConstructorType . flags & 80896 /* ObjectType */ ) { // Resolving the members of a class requires us to resolve the base class of that class. // We force resolution here such that we catch circularities now. resolveStructuredTypeMembers ( baseConstructorType ) ; } if ( ! popTypeResolution ( ) ) { error ( type . symbol . valueDeclaration , ts . Diagnostics . _0_is_referenced_directly_or_indirectly_in_its_own_base_expression , symbolToString ( type . symbol ) ) ; return type . resolvedBaseConstructorType = unknownType ; } if ( baseConstructorType !== unknownType && baseConstructorType !== nullType && ! isConstructorType ( baseConstructorType ) ) { error ( baseTypeNode . expression , ts . Diagnostics . Type_0_is_not_a_constructor_function_type , <mask> ( baseConstructorType ) ) ; return type . resolvedBaseConstructorType = unknownType ; } type . resolvedBaseConstructorType = baseConstructorType ; } return type . resolvedBaseConstructorType ; }", "predicted": "String", "expected": "typeToString"}
{"code": "function getUnionSignatures ( types , kind ) { var signatureLists = ts . map ( types , function ( t ) { return getSignaturesOfType ( t , kind ) ; } ) ; var result = undefined ; for ( var i = 0 ; i < signatureLists . length ; i ++ ) { for ( var _i = 0 , _a = signatureLists [ i ] ; _i < _a . length ; _i ++ ) { var signature = _a [ _i ] ; // Only process signatures with parameter lists that aren't already in the result list if ( ! result || ! findMatchingSignature ( result , signature , /*partialMatch*/ false , /*ignoreReturnTypes*/ true ) ) { var unionSignatures = findMatchingSignatures ( signatureLists , signature , i ) ; if ( unionSignatures ) { var s = signature ; <mask> if ( unionSignatures . length > 1 ) { s = cloneSignature ( signature ) ; // Clear resolved return type we possibly got from cloneSignature s . resolvedReturnType = undefined ; s . unionSignatures = unionSignatures ; } ( result || ( result = [ ] ) ) . push ( s ) ; } } } } return result || emptyArray ; }", "predicted": "}", "expected": "// Union the result types when more than one signature matches"}
{"code": "function getPropagatingFlagsOfTypes ( types ) { var result = 0 ; for ( var <mask> = 0 ; _i < types . length ; _i ++ ) { var type = types [ _i ] ; result |= type . flags ; } return result & 14680064 /* PropagatingFlags */ ; }", "predicted": "i", "expected": "_i"}
{"code": "function <mask> ( node , symbol ) { var type = getDeclaredTypeOfSymbol ( symbol ) ; var links = getSymbolLinks ( symbol ) ; var typeParameters = links . typeParameters ; if ( typeParameters ) { if ( ! node . typeArguments || node . typeArguments . length !== typeParameters . length ) { error ( node , ts . Diagnostics . Generic_type_0_requires_1_type_argument_s , symbolToString ( symbol ) , typeParameters . length ) ; return unknownType ; } var typeArguments = ts . map ( node . typeArguments , getTypeFromTypeNode ) ; var id = getTypeListId ( typeArguments ) ; return links . instantiations [ id ] || ( links . instantiations [ id ] = instantiateType ( type , createTypeMapper ( typeParameters , typeArguments ) ) ) ; } if ( node . typeArguments ) { error ( node , ts . Diagnostics . Type_0_is_not_generic , symbolToString ( symbol ) ) ; return unknownType ; } return type ; }", "predicted": "Type", "expected": "getTypeFromTypeAliasReference"}
{"code": "function getExportedTypeFromNamespace ( namespace , name ) { var namespaceSymbol = getGlobalSymbol ( namespace , 1536 /* Namespace */ , /*diagnosticMessage*/ undefined ) ; var typeSymbol = namespaceSymbol && getSymbol ( namespaceSymbol . exports , name , <mask> /* Type */ ) ; return typeSymbol && getDeclaredTypeOfSymbol ( typeSymbol ) ; }", "predicted": "undefined", "expected": "793056"}
{"code": "function getUnionType ( types , noSubtypeReduction ) { if ( types . length === 0 ) { return emptyObjectType ; } var typeSet = [ ] ; addTypesToSet ( typeSet , types , 16384 /* Union */ ) ; if ( containsTypeAny ( typeSet ) ) { return anyType ; } if ( noSubtypeReduction ) { removeAllButLast ( typeSet , undefinedType ) ; removeAllButLast ( typeSet , nullType ) ; } else { removeSubtypes ( typeSet ) ; } if ( typeSet . length === 1 ) { return typeSet [ 0 ] ; } var id = getTypeListId ( typeSet ) ; var type = <mask> [ id ] ; if ( ! type ) { type = unionTypes [ id ] = createObjectType ( 16384 /* Union */ | getPropagatingFlagsOfTypes ( typeSet ) ) ; type . types = typeSet ; } return type ; }", "predicted": "types", "expected": "unionTypes"}
{"code": "function getContextuallyTypedParameterType ( parameter ) { var func = parameter . parent ; if ( isFunctionExpressionOrArrowFunction ( func ) || ts . isObjectLiteralMethod ( func ) ) { if ( isContextSensitive ( func ) ) { var contextualSignature = getContextualSignature ( func ) ; if ( contextualSignature ) { var funcHasRestParameters = ts . hasRestParameter ( func ) ; var len = func . parameters . length - ( funcHasRestParameters ? 1 : 0 ) ; var indexOfParameter = ts . indexOf ( func . parameters , parameter ) ; if ( indexOfParameter < len ) { return getTypeAtPosition ( contextualSignature , indexOfParameter ) ; } <mask> if ( funcHasRestParameters && indexOfParameter === ( func . parameters . length - 1 ) && isRestParameterIndex ( contextualSignature , func . parameters . length - 1 ) ) { return getTypeOfSymbol ( ts . lastOrUndefined ( contextualSignature . parameters ) ) ; } } } } return undefined ; }", "predicted": "else", "expected": "// If last parameter is contextually rest parameter get its type"}
{"code": "function <mask> ( attrib ) { var attributesType = getJsxElementAttributesType ( attrib . parent ) ; var prop = getPropertyOfType ( attributesType , attrib . name . text ) ; return prop || unknownSymbol ; }", "predicted": "Symbol", "expected": "getJsxAttributePropertySymbol"}
{"code": "function getPropertyNameForIndexedAccess ( <mask> , indexArgumentType ) { if ( indexArgumentExpression . kind === 9 /* StringLiteral */ || indexArgumentExpression . kind === 8 /* NumericLiteral */ ) { return indexArgumentExpression . text ; } if ( indexArgumentExpression . kind === 167 /* ElementAccessExpression */ || indexArgumentExpression . kind === 166 /* PropertyAccessExpression */ ) { var value = getConstantValue ( indexArgumentExpression ) ; if ( value !== undefined ) { return value . toString ( ) ; } } if ( checkThatExpressionIsProperSymbolReference ( indexArgumentExpression , indexArgumentType , /*reportError*/ false ) ) { var rightHandSideName = indexArgumentExpression . name . text ; return ts . getPropertyNameForKnownSymbolName ( rightHandSideName ) ; } return undefined ; }", "predicted": "ts", "expected": "indexArgumentExpression"}
{"code": "function getEffectiveArgumentCount ( node , args , signature ) { if ( node . kind === 139 /* Decorator */ ) { switch ( node . parent . kind ) { case 214 /* ClassDeclaration */ : case 186 /* ClassExpression */ : // A class decorator will have one argument (see `ClassDecorator` in core.d.ts) return 1 ; case 141 /* PropertyDeclaration */ : // A property declaration decorator will have two arguments (see // `PropertyDecorator` in core.d.ts) return 2 ; case 143 /* MethodDeclaration */ : case 145 /* GetAccessor */ : case 146 /* SetAccessor */ : <mask> // `PropertyDecorator` and `MethodDecorator` in core.d.ts) // If we are emitting decorators for ES3, we will only pass two arguments. if ( languageVersion === 0 /* ES3 */ ) { return 2 ; } // If the method decorator signature only accepts a target and a key, we will only // type check those arguments. return signature . parameters . length >= 3 ? 3 : 2 ; case 138 /* Parameter */ : // A parameter declaration decorator will have three arguments (see // `ParameterDecorator` in core.d.ts) return 3 ; } } else { return args . length ; } }", "predicted": "//", "expected": "// A method or accessor declaration decorator will have two or three arguments (see"}
{"code": "function getEffectiveArgumentErrorNode ( node , argIndex , arg ) { if ( node . kind === 139 /* Decorator */ ) { // For a decorator, we use the expression of the decorator for error reporting. return node . expression ; } else if ( argIndex === 0 && node . kind === <mask> /* TaggedTemplateExpression */ ) { // For a the first argument of a tagged template expression, we use the template of the tag for error reporting. return node . template ; } else { return arg ; } }", "predicted": "139", "expected": "170"}
{"code": "function checkCallExpression ( node ) { // Grammar checking; stop grammar-checking if checkGrammarTypeArguments return true checkGrammarTypeArguments ( node , node . typeArguments ) || checkGrammarArguments ( node , node . arguments ) ; var signature = getResolvedSignature ( node ) ; if ( node . expression . kind === 95 /* SuperKeyword */ ) { return voidType ; } if ( node . kind === 169 /* NewExpression */ ) { var declaration = signature . declaration ; if ( declaration && declaration . kind !== 144 /* Constructor */ && declaration . kind !== 148 /* ConstructSignature */ && declaration . kind !== 153 /* ConstructorType */ ) { // When resolved signature is a call signature (and not a construct signature) the result type is any if ( compilerOptions . <mask> ) { error ( node , ts . Diagnostics . new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type ) ; } return anyType ; } } return getReturnTypeOfSignature ( signature ) ; }", "predicted": "debug", "expected": "noImplicitAny"}
{"code": "function someConstituentTypeHasKind ( type , kind ) { if ( type . flags & kind ) { return true ; } if ( type . flags & 49152 /* UnionOrIntersection */ ) { var types = type . types ; for ( var <mask> = 0 ; _i < types . length ; _i ++ ) { var current = types [ _i ] ; if ( current . flags & kind ) { return true ; } } return false ; } return false ; }", "predicted": "i", "expected": "_i"}
{"code": "function checkParameterInitializer ( node ) { if ( ts . getRootDeclaration ( node ) . kind !== 138 /* Parameter */ ) { return ; } var func = ts . getContainingFunction ( node ) ; visit ( node . initializer ) ; function visit ( n ) { if ( n . kind === 69 /* Identifier */ ) { var referencedSymbol = getNodeLinks ( n ) . resolvedSymbol ; // check FunctionLikeDeclaration.locals (stores parameters\\function local variable) // if it contains entry with a specified name and if this entry matches the resolved symbol if ( referencedSymbol && referencedSymbol !== unknownSymbol && getSymbol ( func . locals , referencedSymbol . name , 107455 /* Value */ ) === referencedSymbol ) { if ( referencedSymbol . valueDeclaration . kind === 138 /* Parameter */ ) { if ( referencedSymbol . valueDeclaration === node ) { error ( n , ts . Diagnostics . <mask> , ts . declarationNameToString ( node . name ) ) ; return ; } if ( referencedSymbol . valueDeclaration . pos < node . pos ) { // legal case - parameter initializer references some parameter strictly on left of current parameter declaration return ; } } error ( n , ts . Diagnostics . Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it , ts . declarationNameToString ( node . name ) , ts . declarationNameToString ( n ) ) ; } } else { ts . forEachChild ( n , visit ) ; } } }", "predicted": "Error", "expected": "Parameter_0_cannot_be_referenced_in_its_initializer"}
{"code": "function copySymbol ( symbol , meaning ) { if ( symbol . flags & meaning ) { var id = symbol . name ; // We will copy all symbol regardless of its reserved name because <mask> // it will not copy symbol with reserved name to the array if ( ! ts . hasProperty ( symbols , id ) ) { symbols [ id ] = symbol ; } } }", "predicted": "otherwise", "expected": "// symbolsToArray will check whether the key is a reserved name and"}
{"code": "function getReferencedImportDeclaration ( node ) { var symbol = getReferencedValueSymbol ( node ) ; return symbol && symbol . flags & <mask> /* Alias */ ? getDeclarationOfAliasSymbol ( symbol ) : undefined ; }", "predicted": "1", "expected": "8388608"}
{"code": "function writeDeclarationFile ( jsFilePath , sourceFile , host , resolver , diagnostics ) { var <mask> = emitDeclarations ( host , resolver , diagnostics , jsFilePath , sourceFile ) ; // TODO(shkamat): Should we not write any declaration file if any of them can produce error, // or should we just not write this file like we are doing now if ( ! emitDeclarationResult . reportedDeclarationError ) { var declarationOutput = emitDeclarationResult . referencePathsOutput + getDeclarationOutput ( emitDeclarationResult . synchronousDeclarationOutput , emitDeclarationResult . moduleElementDeclarationEmitInfo ) ; ts . writeFile ( host , diagnostics , ts . removeFileExtension ( jsFilePath ) + , declarationOutput , host . getCompilerOptions ( ) . emitBOM ) ; } function getDeclarationOutput ( synchronousDeclarationOutput , moduleElementDeclarationEmitInfo ) { var appliedSyncOutputPos = 0 ; var declarationOutput = ; // apply asynchronous additions to the synchronous output ts . forEach ( moduleElementDeclarationEmitInfo , function ( aliasEmitInfo ) { if ( aliasEmitInfo . asynchronousOutput ) { declarationOutput += synchronousDeclarationOutput . substring ( appliedSyncOutputPos , aliasEmitInfo . outputPos ) ; declarationOutput += getDeclarationOutput ( aliasEmitInfo . asynchronousOutput , aliasEmitInfo . subModuleElementDeclarationEmitInfo ) ; appliedSyncOutputPos = aliasEmitInfo . outputPos ; } } ) ; declarationOutput += synchronousDeclarationOutput . substring ( appliedSyncOutputPos ) ; return declarationOutput ; } }", "predicted": "result", "expected": "emitDeclarationResult"}
{"code": "function makeUniqueName ( baseName ) { // Find the first unique 'name_n', where n is a positive number if ( baseName . charCodeAt ( baseName . length - 1 ) !== 95 /* _ */ ) { baseName += ; } var i = 1 ; while ( true ) { var <mask> = baseName + i ; if ( isUniqueName ( generatedName ) ) { return generatedNameSet [ generatedName ] = generatedName ; } i ++ ; } }", "predicted": "name", "expected": "generatedName"}
{"code": "function indexOfIgnoringCase ( string , value ) { for ( var i = 0 , n = string . length - value . length ; i <= n ; i ++ ) { if ( <mask> ( string , value , i ) ) { return i ; } } return - 1 ; }", "predicted": "match", "expected": "startsWithIgnoringCase"}
{"code": "function startsWithIgnoringCase ( string , value , start ) { for ( var i = 0 , n = value . length ; i < n ; i ++ ) { var ch1 = <mask> ( string . charCodeAt ( i + start ) ) ; var ch2 = value . charCodeAt ( i ) ; if ( ch1 !== ch2 ) { return false ; } } return true ; }", "predicted": "Number", "expected": "toLowerCase"}
{"code": "function getTouchingPropertyName ( sourceFile , position ) { return getTouchingToken ( sourceFile , position , function ( n ) { return <mask> ( n . kind ) ; } ) ; }", "predicted": "Number", "expected": "isPropertyName"}
{"code": "function getTokenAtPositionWorker ( sourceFile , position , allowPositionInLeadingTrivia , includeItemAtEndPosition ) { var current = sourceFile ; outer : while ( true ) { if ( isToken ( current ) ) { // exit early return current ; } // find the child that contains 'position' for ( var i = 0 , n = current . getChildCount ( sourceFile ) ; i < n ; i ++ ) { var child = current . getChildAt ( i ) ; var start = allowPositionInLeadingTrivia ? child . getFullStart ( ) : child . getStart ( sourceFile ) ; if ( start <= position ) { var end = child . getEnd ( ) ; if ( position < end || ( position === end && child . kind === 1 <mask> ) ) { current = child ; continue outer ; } else if ( includeItemAtEndPosition && end === position ) { var previousToken = findPrecedingToken ( position , sourceFile , child ) ; if ( previousToken && includeItemAtEndPosition ( previousToken ) ) { return previousToken ; } } } } return current ; } }", "predicted": "Token", "expected": "/* EndOfFileToken */"}
{"code": "function getJsDocTagAtPosition ( <mask> , position ) { var node = ts . getTokenAtPosition ( sourceFile , position ) ; if ( isToken ( node ) ) { switch ( node . kind ) { case 102 /* VarKeyword */ : case 108 /* LetKeyword */ : case 74 /* ConstKeyword */ : // if the current token is var, let or const, skip the VariableDeclarationList node = node . parent === undefined ? undefined : node . parent . parent ; break ; default : node = node . parent ; break ; } } if ( node ) { var jsDocComment = node . jsDocComment ; if ( jsDocComment ) { for ( var _i = 0 , _a = jsDocComment . tags ; _i < _a . length ; _i ++ ) { var tag = _a [ _i ] ; if ( tag . pos <= position && position <= tag . end ) { return tag ; } } } } return undefined ; }", "predicted": "ts", "expected": "sourceFile"}
{"code": "function findFirstNonWhitespaceCharacterAndColumn ( startPos , endPos , sourceFile , options ) { var character = 0 ; var column = 0 ; for ( var pos = startPos ; pos < endPos ; ++ pos ) { var ch = sourceFile . text . <mask> ( pos ) ; if ( ! ts . isWhiteSpace ( ch ) ) { break ; } if ( ch === 9 /* tab */ ) { column += options . TabSize + ( column % options . TabSize ) ; } else { column ++ ; } character ++ ; } return { column : column , character : character } ; }", "predicted": "slice", "expected": "charCodeAt"}
{"code": "function transpile ( input , compilerOptions , <mask> , diagnostics , moduleName ) { var output = transpileModule ( input , { compilerOptions : compilerOptions , fileName : fileName , reportDiagnostics : ! ! diagnostics , moduleName : moduleName } ) ; // addRange correctly handles cases when wither 'from' or 'to' argument is missing ts . addRange ( diagnostics , output . diagnostics ) ; return output . outputText ; }", "predicted": "ts", "expected": "fileName"}
{"code": "function getSemanticDiagnostics ( <mask> ) { synchronizeHostData ( ) ; var targetSourceFile = getValidSourceFile ( fileName ) ; // For JavaScript files, we don't want to report the normal typescript semantic errors. // Instead, we just report errors for using TypeScript-only constructs from within a // JavaScript file. if ( ts . isJavaScript ( fileName ) ) { return getJavaScriptSemanticDiagnostics ( targetSourceFile ) ; } // Only perform the action per file regardless of '-out' flag as LanguageServiceHost is expected to call this function per file. // Therefore only get diagnostics for given file. var semanticDiagnostics = program . getSemanticDiagnostics ( targetSourceFile , cancellationToken ) ; if ( ! program . getCompilerOptions ( ) . declaration ) { return semanticDiagnostics ; } // If '-d' is enabled, check for emitter error. One example of emitter error is export class implements non-export interface var declarationDiagnostics = program . getDeclarationDiagnostics ( targetSourceFile , cancellationToken ) ; return ts . concatenate ( semanticDiagnostics , declarationDiagnostics ) ; }", "predicted": "program", "expected": "fileName"}
{"code": "function tryGetObjectLikeCompletionSymbols ( objectLikeContainer ) { // We're looking up possible property names from contextual/inferred/declared type. isMemberCompletion = true ; var typeForObject ; var existingMembers ; if ( objectLikeContainer . kind === 165 /* ObjectLiteralExpression */ ) { // We are completing on contextual types, but may also include properties // other than those within the declared type. isNewIdentifierLocation = true ; typeForObject = typeChecker . getContextualType ( objectLikeContainer ) ; existingMembers = objectLikeContainer . properties ; } else if ( objectLikeContainer . kind === 161 /* ObjectBindingPattern */ ) { // We are *only* completing on properties from the type being destructured. isNewIdentifierLocation = false ; var <mask> = ts . getRootDeclaration ( objectLikeContainer . parent ) ; if ( ts . isVariableLike ( rootDeclaration ) ) { // We don't want to complete using the type acquired by the shape // of the binding pattern; we are only interested in types acquired // through type declaration or inference. if ( rootDeclaration . initializer || rootDeclaration . type ) { typeForObject = typeChecker . getTypeAtLocation ( objectLikeContainer ) ; existingMembers = objectLikeContainer . elements ; } } else { ts . Debug . fail ( ) ; } } else { ts . Debug . fail ( + objectLikeContainer . kind ) ; } if ( ! typeForObject ) { return false ; } var typeMembers = typeChecker . getPropertiesOfType ( typeForObject ) ; if ( typeMembers && typeMembers . length > 0 ) { // Add filtered items to the completion list symbols = filterObjectMembersList ( typeMembers , existingMembers ) ; } return true ; }", "predicted": "declaration", "expected": "rootDeclaration"}
{"code": "function <mask> ( searchValue , maxResultCount ) { synchronizeHostData ( ) ; return ts . NavigateTo . getNavigateToItems ( program , cancellationToken , searchValue , maxResultCount ) ; }", "predicted": "function", "expected": "getNavigateToItems"}
{"code": "function hasValueSideModule ( symbol ) { return ts . forEach ( symbol . declarations , function ( declaration ) { return declaration . kind === <mask> /* ModuleDeclaration */ && ts . getModuleInstanceState ( declaration ) === 1 /* Instantiated */ ; } ) ; }", "predicted": "1", "expected": "218"}
{"code": "function getParametersFromRightHandSideOfAssignment ( <mask> ) { while ( rightHandSide . kind === 172 /* ParenthesizedExpression */ ) { rightHandSide = rightHandSide . expression ; } switch ( rightHandSide . kind ) { case 173 /* FunctionExpression */ : case 174 /* ArrowFunction */ : return rightHandSide . parameters ; case 186 /* ClassExpression */ : for ( var _i = 0 , _a = rightHandSide . members ; _i < _a . length ; _i ++ ) { var member = _a [ _i ] ; if ( member . kind === 144 /* Constructor */ ) { return member . parameters ; } } break ; } return emptyArray ; }", "predicted": "expression", "expected": "rightHandSide"}
{"code": "function addRequiredQueryFields ( query ) { let <mask> = query . replace ( / \\s+ / g , ) ; let starti = stringCondensed . indexOf ( 'node {' ) + 6 ; let endi = stringCondensed . indexOf ( '}' , starti ) ; let currentParams = ( stringCondensed . substring ( starti , endi ) ) . split ( ) ; const requiredParams = [ , , , ] ; requiredParams . forEach ( function ( p ) { if ( ! currentParams . includes ( p ) ) { currentParams . push ( p ) } } ) ; currentParams = currentParams . join ( ) ; return stringCondensed . substr ( 0 , starti ) + currentParams + stringCondensed . substr ( endi ) ; }", "predicted": "query", "expected": "stringCondensed"}
{"code": "async function origin ( req , init ) { const url = new URL ( req . url ) switch ( url . pathname ) { case : return new Response ( ` ${ new Date ( ) } ` , { headers : { : } } ) case : return new Response ( ` ${ new Date ( ) } ` ) } return new Response ( , { status : <mask> } ) }", "predicted": "200", "expected": "404"}
{"code": "function scrollToHash ( hash ) { var $scroller = getScroller ( ) , dest = 0 ; // Don't try to scroll if element doesn't exist if ( ! pageHasElement ( hash ) ) { return ; } if ( hash ) { dest = getElementTopPosition ( hash ) ; } // Unbind scroll detection $scroller . unbind ( 'scroll' ) ; $scroller . animate ( { <mask> : dest } , 800 , 'swing' , function ( ) { // Reset scroll binding when finished $scroller . scroll ( handleScrolling ) ; } ) ; // Directly set chapter as active setChapterActive ( null , hash ) ; }", "predicted": "top", "expected": "scrollTop"}
{"code": "function getElementTopPosition ( id ) { // Get actual position of element if nested var $scroller = getScroller ( ) , $container = $scroller . find ( '.page-inner' ) , $el = $scroller . find ( id ) , $parent = $el . offsetParent ( ) , dest = 0 ; // Exit early if we can't find any of those elements if ( any ( [ $scroller , $container , $el , $parent ] , isEmpty ) ) { return 0 ; } dest = $el . position ( ) . top ; // Note: this could be a while loop, but to avoid any chances of infinite loops // we'll limit the max iterations to 10 var MAX_ITERATIONS = 10 ; for ( var i = 0 ; i < MAX_ITERATIONS ; i ++ ) { <mask> // or if we hit the top of the dom (parent's parent is itself) if ( $parent . is ( $container ) || $parent . is ( $parent . offsetParent ( ) ) ) { break ; } // Go up the DOM tree, to the next parent $el = $parent ; dest += $el . position ( ) . top ; $parent = $el . offsetParent ( ) ; } // Return rounded value since // jQuery scrollTop() returns an integer return Math . floor ( dest ) ; }", "predicted": "//", "expected": "// Stop when we find the element's ancestor just below $container"}
{"code": "function createDropdownMenu ( dropdown ) { var $menu = $ ( '<div>' , { 'class' : 'dropdown-menu' , 'html' : '<div class=\"dropdown-caret\"><span class=\"caret-outer\"></span><span class=\"caret-inner\"></span></div>' } ) ; if ( typeof dropdown == 'string' ) { $menu . append ( dropdown ) ; } else { var groups = dropdown . map ( function ( group ) { if ( $ . isArray ( group ) ) return group ; else return [ group ] ; } ) ; // Create buttons groups groups . forEach ( function ( group ) { var <mask> = $ ( '<div>' , { 'class' : 'buttons' } ) ; var sizeClass = 'size-' + group . length ; // Append buttons group . forEach ( function ( btn ) { btn = $ . extend ( { text : '' , className : '' , onClick : defaultOnClick } , btn || { } ) ; var $btn = $ ( '<button>' , { 'class' : 'button ' + sizeClass + ' ' + btn . className , 'text' : btn . text } ) ; $btn . click ( btn . onClick ) ; $group . append ( $btn ) ; } ) ; $menu . append ( $group ) ; } ) ; } return $menu ; }", "predicted": "group", "expected": "$group"}
{"code": "function init ( ) { $ ( document ) . on ( 'click' , '.toggle-dropdown' , <mask> ) ; $ ( document ) . on ( 'click' , '.dropdown-menu' , function ( e ) { e . stopPropagation ( ) ; } ) ; $ ( document ) . on ( 'click' , closeDropdown ) ; }", "predicted": "init", "expected": "toggleDropdown"}
{"code": "function hasChanged ( ctx ) { console . log ( 'page has changed' , ctx ) ; // eslint-disable-line no-console setState ( ctx ) ; if ( ! started ) { // Notify that gitbook is ready started = true ; events . trigger ( <mask> , ctx . config . pluginsConfig ) ; } events . trigger ( 'page.change' ) ; }", "predicted": "start", "expected": "'start'"}
{"code": "function addDirective ( type ) { return function ( name , directive ) { if ( <mask> name === 'function' ) { directive = name } if ( typeof directive !== 'function' ) { throw new TypeError ( 'Directive must be a function' ) } name = typeof name === 'string' ? name : directive . name if ( ! name ) { throw new TypeError ( 'Directive function must have a name' ) } directive . $name = name Toxy [ type ] [ name ] = directive return Toxy } }", "predicted": "!", "expected": "typeof"}
{"code": "function Metadata ( options , controlConnection ) { if ( ! options ) { throw new errors . ArgumentError ( 'Options are not defined' ) ; } Object . defineProperty ( this , 'options' , { value : options , <mask> : false , writable : false } ) ; Object . defineProperty ( this , 'controlConnection' , { value : controlConnection , enumerable : false , writable : false } ) ; this . keyspaces = { } ; this . initialized = false ; this . _schemaParser = schemaParserFactory . getByVersion ( options , controlConnection , this . getUdt . bind ( this ) ) ; const self = this ; this . _preparedQueries = new PreparedQueries ( options . maxPrepared , function ( ) { self . log . apply ( self , arguments ) ; } ) ; }", "predicted": "readable", "expected": "enumerable"}
{"code": "function NoHostAvailableError ( innerErrors , message ) { DriverError . call ( this , message ) ; this . innerErrors = innerErrors ; this . <mask> = 'Represents an error when a query cannot be performed because no host is available or could be reached by the driver.' ; if ( ! message ) { this . message = 'All host(s) tried for query failed.' ; if ( innerErrors ) { const hostList = Object . keys ( innerErrors ) ; if ( hostList . length > 0 ) { const host = hostList [ 0 ] ; this . message += util . format ( ' First host tried, %s: %s. See innerErrors.' , host , innerErrors [ host ] ) ; } } } }", "predicted": "message", "expected": "info"}
{"code": "function timeuuid ( options , buffer , offset ) { let date ; let ticks ; let nodeId ; let clockId ; if ( options ) { if ( typeof options . msecs === 'number' ) { date = new Date ( options . msecs ) ; } if ( options . msecs instanceof Date ) { date = options . msecs ; } if ( util . isArray ( options . node ) ) { nodeId = <mask> . allocBufferFromArray ( options . node ) ; } if ( typeof options . clockseq === 'number' ) { clockId = utils . allocBufferUnsafe ( 2 ) ; clockId . writeUInt16BE ( options . clockseq , 0 ) ; } if ( typeof options . nsecs === 'number' ) { ticks = options . nsecs ; } } const uuid = new TimeUuid ( date , ticks , nodeId , clockId ) ; if ( buffer instanceof Buffer ) { //copy the values into the buffer uuid . getBuffer ( ) . copy ( buffer , offset || 0 ) ; return buffer ; } return uuid . toString ( ) ; }", "predicted": "util", "expected": "utils"}
{"code": "function generateTimestamp ( date , microseconds ) { if ( ! date ) { date = new Date ( ) ; } let longMicro = Long . ZERO ; if ( typeof microseconds === 'number' && microseconds >= 0 && microseconds < 1000 ) { longMicro = Long . <mask> ( microseconds ) ; } else { if ( _timestampTicks > 999 ) { _timestampTicks = 0 ; } longMicro = Long . fromInt ( _timestampTicks ) ; _timestampTicks ++ ; } return Long . fromNumber ( date . getTime ( ) ) . multiply ( _longOneThousand ) . add ( longMicro ) ; }", "predicted": "parse", "expected": "fromInt"}
{"code": "function MutableLong ( b00 , b16 , b32 , <mask> ) { // Use an array of uint16 this . _arr = [ b00 & 0xffff , b16 & 0xffff , b32 & 0xffff , b48 & 0xffff ] ; }", "predicted": "48", "expected": "b48"}
{"code": "function Integer ( bits , sign ) { /**\n   * @type {!Array.<number>}\n   * @private\n   */ this . bits_ = [ ] ; <mask> this . sign_ = sign ; // Copy the 32-bit signed integer values passed in.  We prune out those at the // top that equal the sign since they are redundant. var top = true ; for ( var i = bits . length - 1 ; i >= 0 ; i -- ) { var val = bits [ i ] | 0 ; if ( ! top || val != sign ) { this . bits_ [ i ] = val ; top = false ; } } }", "predicted": "", "expected": "/**\n   * @type {number}\n   * @private\n   */"}
{"code": "function TableMetadata ( name ) { DataCollection . call ( this , name ) ; /**\n   * Applies only to counter tables.\n   * When set to true, replicates writes to all affected replicas regardless of the consistency level specified by\n   * the client for a write request. For counter tables, this should always be set to true.\n   * @type {Boolean}\n   */ this . <mask> = true ; /**\n   * Returns the memtable flush period (in milliseconds) option for this table.\n   * @type {Number}\n   */ this . memtableFlushPeriod = 0 ; /**\n   * Returns the index interval option for this table.\n   * <p>\n   * Note: this option is only available in Apache Cassandra 2.0. It is deprecated in Apache Cassandra 2.1 and\n   * above, and will therefore return <code>null</code> for 2.1 nodes.\n   * </p>\n   * @type {Number|null}\n   */ this . indexInterval = null ; /**\n   * Determines  whether the table uses the COMPACT STORAGE option.\n   * @type {Boolean}\n   */ this . isCompact = false ; /**\n   *\n   * @type {Array.<Index>}\n   */ this . indexes = null ; /**\n   * Determines whether the Change Data Capture (CDC) flag is set for the table.\n   * @type {Boolean|null}\n   */ this . cdc = null ; /**\n   * Determines whether the table is a virtual table or not.\n   * @type {Boolean}\n   */ this . virtual = false ; }", "predicted": "replicated", "expected": "replicateOnWrite"}
{"code": "function SchemaParserV1 ( options , cc ) { SchemaParser . call ( this , options , cc ) ; this . selectTable = _selectTableV1 ; this . selectColumns = <mask> ; this . selectUdt = _selectUdtV1 ; this . selectAggregates = _selectAggregatesV1 ; this . selectFunctions = _selectFunctionsV1 ; }", "predicted": "null", "expected": "_selectColumnsV1"}
{"code": "function <mask> ( options , cc , udtResolver ) { SchemaParserV2 . call ( this , options , cc , udtResolver ) ; this . supportsVirtual = true ; }", "predicted": "Parser", "expected": "SchemaParserV3"}
{"code": "function executeConcurrent ( client , query , parameters , options ) { if ( ! client ) { throw new TypeError ( 'Client instance is not defined' ) ; } if ( typeof query === 'string' ) { if ( Array . isArray ( parameters ) ) { return new ArrayBasedExecutor ( client , query , parameters , options ) . execute ( ) ; } if ( parameters instanceof Stream ) { return new <mask> ( client , query , parameters , options ) . execute ( ) ; } throw new TypeError ( 'parameters should be an Array or a Stream instance' ) ; } if ( Array . isArray ( query ) ) { options = parameters ; return new ArrayBasedExecutor ( client , null , query , options ) . execute ( ) ; } throw new TypeError ( 'A string query or query and parameters array should be provided' ) ; }", "predicted": "Stream", "expected": "StreamBasedExecutor"}
{"code": "function copyBuffer ( buf ) { const <mask> = allocBufferUnsafe ( buf . length ) ; buf . copy ( targetBuffer ) ; return targetBuffer ; }", "predicted": "buf", "expected": "targetBuffer"}
{"code": "function deepExtend ( target ) { const sources = Array . prototype . slice . call ( arguments , 1 ) ; sources . forEach ( function ( source ) { for ( const prop in source ) { if ( ! source . hasOwnProperty ( prop ) ) { continue ; } const targetProp = target [ prop ] ; const targetType = ( typeof targetProp ) ; <mask> // a native single type // or not existent // or is not an anonymous object (not class instance) if ( ! targetProp || targetType === 'number' || targetType === 'string' || util . isArray ( targetProp ) || util . isDate ( targetProp ) || targetProp . constructor . name !== 'Object' ) { target [ prop ] = source [ prop ] ; } else { //inner extend target [ prop ] = deepExtend ( { } , targetProp , source [ prop ] ) ; } } } ) ; return target ; }", "predicted": "//", "expected": "//target prop is"}
{"code": "function arrayIterator ( arr ) { let index = 0 ; return { next : function ( ) { if ( index >= arr . length ) { return { done : true } ; } return { <mask> : arr [ index ++ ] , done : false } ; } } ; }", "predicted": "next", "expected": "value"}
{"code": "function ExponentialReconnectionPolicy ( baseDelay , maxDelay , <mask> ) { this . baseDelay = baseDelay ; this . maxDelay = maxDelay ; this . startWithNoDelay = startWithNoDelay ; }", "predicted": "options", "expected": "startWithNoDelay"}
{"code": "function <mask> ( clockId ) { let buffer = clockId ; if ( typeof clockId === 'string' ) { buffer = utils . allocBufferFromString ( clockId , 'ascii' ) ; } if ( ! ( buffer instanceof Buffer ) ) { //Generate buffer = getRandomBytes ( 2 ) ; } else if ( buffer . length !== 2 ) { throw new Error ( 'Clock identifier must have 2 bytes' ) ; } return buffer ; }", "predicted": "generate", "expected": "getClockId"}
{"code": "function getNodeId ( nodeId ) { let buffer = nodeId ; if ( typeof nodeId === <mask> ) { buffer = utils . allocBufferFromString ( nodeId , 'ascii' ) ; } if ( ! ( buffer instanceof Buffer ) ) { //Generate buffer = getRandomBytes ( 6 ) ; } else if ( buffer . length !== 6 ) { throw new Error ( 'Node identifier must have 6 bytes' ) ; } return buffer ; }", "predicted": "string", "expected": "'string'"}
{"code": "function Index ( name , target , kind , options ) { /**\n   * Name of the index.\n   * @type {String}\n   */ this . name = name ; /**\n   * Target of the index.\n   * @type {String}\n   */ this . target = target ; /**\n   * A numeric value representing index kind (0: custom, 1: keys, 2: composite);\n   * @type {Number}\n   */ this . kind = typeof kind === 'string' ? getKindByName ( kind ) : kind ; /**\n   * An associative array containing the index options\n   * @type {Object}\n   */ this . options = options ; <mask>", "predicted": "/**", "expected": "}"}
{"code": "function makeView ( doc ) { var selPos = { line : 0 , ch : 0 } ; return { doc : doc , // frontier is the point up to which the content has been parsed, frontier : 0 , highlight : new Delayed ( ) , sel : { from : selPos , to : selPos , head : selPos , anchor : selPos , shift : <mask> , extend : false } , scrollTop : 0 , scrollLeft : 0 , overwrite : false , focused : false , // Tracks the maximum line length so that // the horizontal scrollbar can be kept // static when scrolling. maxLine : getLine ( doc , 0 ) , maxLineLength : 0 , maxLineChanged : false , suppressEdits : false , goalColumn : null , cantEdit : false , keyMaps : [ ] } ; }", "predicted": "0", "expected": "false"}
{"code": "function loadMode ( cm ) { var doc = cm . view . doc ; cm . view . mode = CodeMirror . getMode ( cm . options , cm . options . mode ) ; doc . iter ( 0 , doc . size , function ( line ) { line . stateAfter = null ; } ) ; cm . view . frontier = 0 ; startWorker ( cm , <mask> ) ; }", "predicted": "true", "expected": "100"}
{"code": "function <mask> ( d /* display */ , docHeight ) { var totalHeight = docHeight + 2 * paddingTop ( d ) ; d . sizer . style . minHeight = d . heightForcer . style . top = totalHeight + ; var scrollHeight = Math . max ( totalHeight , d . scroller . scrollHeight ) ; var needsH = d . scroller . scrollWidth > d . scroller . clientWidth ; var needsV = scrollHeight > d . scroller . clientHeight ; if ( needsV ) { d . scrollbarV . style . display = ; d . scrollbarV . style . bottom = needsH ? scrollbarWidth ( d . measure ) + : ; d . scrollbarV . firstChild . style . height = ( scrollHeight - d . scroller . clientHeight + d . scrollbarV . clientHeight ) + ; } else d . scrollbarV . style . display = ; if ( needsH ) { d . scrollbarH . style . display = ; d . scrollbarH . style . right = needsV ? scrollbarWidth ( d . measure ) + : ; d . scrollbarH . firstChild . style . width = ( d . scroller . scrollWidth - d . scroller . clientWidth + d . scrollbarH . clientWidth ) + ; } else d . scrollbarH . style . display = ; if ( needsH && needsV ) { d . scrollbarFiller . style . display = ; d . scrollbarFiller . style . height = d . scrollbarFiller . style . width = scrollbarWidth ( d . measure ) + ; } else d . scrollbarFiller . style . display = ; if ( mac_geLion && scrollbarWidth ( d . measure ) === 0 ) d . scrollbarV . style . minWidth = d . scrollbarH . style . minHeight = mac_geMountainLion ? : ; }", "predicted": "padding", "expected": "updateScrollbars"}
{"code": "function startOperation ( cm ) { if ( cm . curOp ) ++ cm . curOp . depth ; else cm . curOp = { // Nested operations delay update until the outermost one // finishes. depth : 1 , // An array of ranges of lines that have to be updated. See // updateDisplay. changes : [ ] , <mask> : [ ] , updateInput : null , userSelChange : null , textChanged : null , selectionChanged : false , updateMaxLine : false , id : ++ cm . nextOpId } ; }", "predicted": "updates", "expected": "delayedCallbacks"}
{"code": "function makeLine ( text , markedSpans , height ) { var line = { text : text , height : height } ; attachMarkedSpans ( line , markedSpans ) ; if ( lineIsHidden ( line ) ) line . height = <mask> ; return line ; }", "predicted": "height", "expected": "0"}
{"code": "function getRows ( ) { let tableName = arguments [ 0 ] ; var fname = '' ; var callback ; var where ; if ( arguments . length === 3 ) { fname = path . join ( userData , tableName + '.json' ) ; where = arguments [ 1 ] ; callback = arguments [ 2 ] ; } else if ( arguments . length === 4 ) { fname = path . join ( arguments [ 1 ] , arguments [ 0 ] + '.json' ) ; where = arguments [ 2 ] ; callback = arguments [ 3 ] ; } let exists = fs . existsSync ( fname ) ; let whereKeys ; // Check if where is an object if ( Object . prototype . <mask> . call ( where ) === ) { // Check for number of keys whereKeys = Object . keys ( where ) ; if ( whereKeys === 0 ) { callback ( false , ) ; return ; } } else { callback ( false , ) ; return ; } // Check if the json file exists, if it is, parse it. if ( exists ) { try { let table = JSON . parse ( fs . readFileSync ( fname ) ) ; let rows = table [ tableName ] ; let objs = [ ] ; for ( let i = 0 ; i < rows . length ; i ++ ) { let matched = 0 ; // Number of matched complete where clause for ( var j = 0 ; j < whereKeys . length ; j ++ ) { // Test if there is a matched key with where clause if ( rows [ i ] . hasOwnProperty ( whereKeys [ j ] ) ) { if ( rows [ i ] [ whereKeys [ j ] ] === where [ whereKeys [ j ] ] ) { matched ++ ; } } } // Check if all conditions in the WHERE clause are matched if ( matched === whereKeys . length ) { objs . push ( rows [ i ] ) } } callback ( true , objs ) ; return ; } catch ( e ) { callback ( false , e . toString ( ) ) ; return ; } } else { callback ( false , 'Table file does not exist!' ) ; return ; } }", "predicted": "has", "expected": "toString"}
{"code": "function Transformation ( options ) { if ( options == null ) { options = { } ; } Transformation . <mask> . constructor . call ( this , options ) ; this ; }", "predicted": "prototype", "expected": "__super__"}
{"code": "function getMode ( env , <mask> ) { // When running from parallel-webpack, grab the cli parameters argv = Object . keys ( argv ) . length ? argv : require ( 'minimist' ) ( process . argv . slice ( 2 ) ) ; var isProd = ( argv . mode || env . mode ) === 'production' || env === 'prod' || env . prod ; return isProd ? 'production' : 'development' ; }", "predicted": "process", "expected": "argv"}
{"code": "function MouseEdges ( parent , options ) { _classCallCheck ( this , MouseEdges ) ; var <mask> = _possibleConstructorReturn ( this , ( MouseEdges . __proto__ || Object . getPrototypeOf ( MouseEdges ) ) . call ( this , parent ) ) ; options = options || { } ; _this . options = options ; _this . reverse = options . reverse ? 1 : - 1 ; _this . noDecelerate = options . noDecelerate ; _this . linear = options . linear ; _this . radiusSquared = Math . pow ( options . radius , 2 ) ; _this . resize ( ) ; _this . speed = options . speed || 8 ; return _this ; }", "predicted": "_", "expected": "_this"}
{"code": "function Drag ( parent , options ) { _classCallCheck ( this , Drag ) ; options = options || { } ; var <mask> = _possibleConstructorReturn ( this , ( Drag . __proto__ || Object . getPrototypeOf ( Drag ) ) . call ( this , parent ) ) ; _this . moved = false ; _this . wheelActive = utils . defaults ( options . wheel , true ) ; _this . wheelScroll = options . wheelScroll || 1 ; _this . reverse = options . reverse ? 1 : - 1 ; _this . clampWheel = options . clampWheel ; _this . factor = options . factor || 1 ; _this . xDirection = ! options . direction || options . direction === 'all' || options . direction === 'x' ; _this . yDirection = ! options . direction || options . direction === 'all' || options . direction === 'y' ; _this . parseUnderflow ( options . underflow || 'center' ) ; _this . mouseButtons ( options . mouseButtons ) ; return _this ; }", "predicted": "_", "expected": "_this"}
{"code": "function SnapZoom ( parent , options ) { _classCallCheck ( this , SnapZoom ) ; var _this = _possibleConstructorReturn ( this , ( SnapZoom . __proto__ || Object . getPrototypeOf ( SnapZoom ) ) . call ( this , parent ) ) ; options = options || { } ; _this . width = options . width ; _this . height = options . height ; if ( _this . width > 0 ) { _this . <mask> = parent . _screenWidth / _this . width ; } if ( _this . height > 0 ) { _this . y_scale = parent . _screenHeight / _this . height ; } _this . xIndependent = utils . exists ( _this . x_scale ) ; _this . yIndependent = utils . exists ( _this . y_scale ) ; _this . x_scale = _this . xIndependent ? _this . x_scale : _this . y_scale ; _this . y_scale = _this . yIndependent ? _this . y_scale : _this . x_scale ; _this . time = utils . defaults ( options . time , 1000 ) ; _this . ease = utils . ease ( options . ease , 'easeInOutSine' ) ; _this . center = options . center ; _this . noMove = options . noMove ; _this . stopOnResize = options . stopOnResize ; _this . removeOnInterrupt = options . removeOnInterrupt ; _this . removeOnComplete = utils . defaults ( options . removeOnComplete , true ) ; _this . interrupt = utils . defaults ( options . interrupt , true ) ; if ( _this . time === 0 ) { parent . container . scale . x = _this . x_scale ; parent . container . scale . y = _this . y_scale ; if ( _this . removeOnComplete ) { _this . parent . removePlugin ( 'snap-zoom' ) ; } } else if ( options . forceStart ) { _this . createSnapping ( ) ; } return _this ; }", "predicted": "scale", "expected": "x_scale"}
{"code": "function createEl ( ) { var tagName = arguments . length > 0 && arguments [ 0 ] !== undefined ? arguments [ 0 ] : 'div' ; var properties = arguments . length > 1 && arguments [ 1 ] !== undefined ? arguments [ 1 ] : { } ; var attributes = arguments . length > 2 && arguments [ 2 ] !== undefined ? arguments [ 2 ] : { } ; var content = arguments [ 3 ] ; var el = document . createElement ( tagName ) ; Object . getOwnPropertyNames ( properties ) . <mask> ( function ( propName ) { var val = properties [ propName ] ; // See #2176 // We originally were accepting both properties and attributes in the // same object, but that doesn't work so well. if ( propName . indexOf ( 'aria-' ) !== - 1 || propName === 'role' || propName === 'type' ) { log$1 . warn ( tsml ( _templateObject , propName , val ) ) ; el . setAttribute ( propName , val ) ; // Handle textContent since it's not supported everywhere and we have a // method for it. } else if ( propName === 'textContent' ) { textContent ( el , val ) ; } else { el [ propName ] = val ; } } ) ; Object . getOwnPropertyNames ( attributes ) . forEach ( function ( attrName ) { el . setAttribute ( attrName , attributes [ attrName ] ) ; } ) ; if ( content ) { appendContent ( el , content ) ; } return el ; }", "predicted": "each", "expected": "forEach"}
{"code": "function addClass ( element , classToAdd ) { if ( element . classList ) { element . classList . add ( classToAdd ) ; // Don't need to `throwIfWhitespace` here because `hasElClass` will do it <mask> } else if ( ! hasClass ( element , classToAdd ) ) { element . className = ( element . className + ' ' + classToAdd ) . trim ( ) ; } return element ; }", "predicted": ".", "expected": "// in the case of classList not being supported."}
{"code": "function _cleanUpEvents ( elem , type ) { var data = getData ( elem ) ; // Remove the events of a particular type if there are none left if ( data . handlers [ type ] . length === 0 ) { delete data . handlers [ type ] ; // data.handlers[type] = null; // Setting to null was causing an error with data.handlers // Remove the meta-handler from the element if ( elem . removeEventListener ) { elem . removeEventListener ( type , data . dispatcher , false ) ; } else if ( elem . detachEvent ) { elem . detachEvent ( 'on' + type , data . dispatcher ) ; } } // Remove the events object if there are no types left if ( Object . getOwnPropertyNames ( data . handlers ) . length <= 0 ) { delete data . handlers ; delete data . dispatcher ; delete data . disabled ; } // Finally remove the element data if there is no data left if ( Object . getOwnPropertyNames ( data ) . length === 0 ) { <mask> ( elem ) ; } }", "predicted": "remove", "expected": "removeData"}
{"code": "function off ( <mask> , type , fn ) { // Don't want to add a cache object through getElData if not needed if ( ! hasData ( elem ) ) { return ; } var data = getData ( elem ) ; // If no events exist, nothing to unbind if ( ! data . handlers ) { return ; } if ( Array . isArray ( type ) ) { return _handleMultipleEvents ( off , elem , type , fn ) ; } // Utility function var removeType = function removeType ( t ) { data . handlers [ t ] = [ ] ; _cleanUpEvents ( elem , t ) ; } ; // Are we removing all bound events? if ( ! type ) { for ( var t in data . handlers ) { removeType ( t ) ; } return ; } var handlers = data . handlers [ type ] ; // If no handlers exist, nothing to unbind if ( ! handlers ) { return ; } // If no listener was provided, remove all listeners for type if ( ! fn ) { removeType ( type ) ; return ; } // We're only removing a single handler if ( fn . guid ) { for ( var n = 0 ; n < handlers . length ; n ++ ) { if ( handlers [ n ] . guid === fn . guid ) { handlers . splice ( n -- , 1 ) ; } } } _cleanUpEvents ( elem , type ) ; }", "predicted": "el", "expected": "elem"}
{"code": "function autoSetupTimeout ( wait , <mask> ) { if ( vjs ) { videojs$2 = vjs ; } window . setTimeout ( autoSetup , wait ) ; }", "predicted": "callback", "expected": "vjs"}
{"code": "function isValidEventType ( type ) { return ( // The regex here verifies that the `type` contains at least one non- // whitespace character. typeof type === 'string' && / \\S / . test ( type ) || Array . <mask> ( type ) && ! ! type . length ) ; }", "predicted": "is", "expected": "isArray"}
{"code": "function one$$1 ( ) { var _this2 = this ; for ( var _len2 = arguments . length , args = Array ( _len2 ) , _key2 = 0 ; _key2 < _len2 ; _key2 ++ ) { args [ _key2 ] = arguments [ _key2 ] ; } var _normalizeListenArgs2 = normalizeListenArgs ( this , args ) , isTargetingSelf = _normalizeListenArgs2 . isTargetingSelf , target = _normalizeListenArgs2 . target , type = _normalizeListenArgs2 . type , listener = _normalizeListenArgs2 . listener ; // Targeting this evented object. if ( isTargetingSelf ) { listen ( target , 'one' , type , listener ) ; // Targeting another evented object. } else { var wrapper = function wrapper ( ) { for ( var <mask> = arguments . length , largs = Array ( _len3 ) , _key3 = 0 ; _key3 < _len3 ; _key3 ++ ) { largs [ _key3 ] = arguments [ _key3 ] ; } _this2 . off ( target , type , wrapper ) ; listener . apply ( null , largs ) ; } ; // Use the same function ID as the listener so we can remove it later // it using the ID of the original listener. wrapper . guid = listener . guid ; listen ( target , 'one' , type , wrapper ) ; } }", "predicted": "3", "expected": "_len3"}
{"code": "function off$$1 ( targetOrType , <mask> , listener ) { // Targeting this evented object. if ( ! targetOrType || isValidEventType ( targetOrType ) ) { off ( this . eventBusEl_ , targetOrType , typeOrListener ) ; // Targeting another evented object. } else { var target = targetOrType ; var type = typeOrListener ; // Fail fast and in a meaningful way! validateTarget ( target ) ; validateEventType ( type ) ; validateListener ( listener ) ; // Ensure there's at least a guid, even if the function hasn't been used listener = bind ( this , listener ) ; // Remove the dispose listener on this evented object, which was given // the same guid as the event listener in on(). this . off ( 'dispose' , listener ) ; if ( target . nodeName ) { off ( target , type , listener ) ; off ( target , 'dispose' , listener ) ; } else if ( isEvented ( target ) ) { target . off ( type , listener ) ; target . off ( 'dispose' , listener ) ; } } }", "predicted": "type", "expected": "typeOrListener"}
